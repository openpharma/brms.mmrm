[{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement .landau@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to brms.mmrm","title":"Contributing to brms.mmrm","text":"outlines propose change brms.mmrm. detailed info contributing , tidyverse packages, please see development contributing guide.","code":""},{"path":"/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to brms.mmrm","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to brms.mmrm","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to brms.mmrm","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"RConsortium/brms.mmrm\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to brms.mmrm","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to brms.mmrm","text":"Please note brms.mmrm project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 Eli Lilly Company, Boehringer-Ingelheim, Sage Therapeutics Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/archetypes.html","id":"constructing-an-archetype","dir":"Articles","previous_headings":"","what":"Constructing an archetype","title":"Informative prior archetypes","text":"begin FEV dataset mmrm package, artificial (simulated) dataset clinical trial investigating effect active treatment FEV1 (forced expired volume one second), compared placebo. FEV1 measure quickly lungs can emptied low levels may indicate chronic obstructive pulmonary disease (COPD). dataset tibble 800 rows 7 variables: USUBJID (subject ID), AVISIT (visit number), ARMCD (treatment, TRT PBO), RACE (3-category race), SEX (sex), FEV1_BL (FEV1 baseline, %), FEV1 (FEV1 study visits), WEIGHT (weighting variable). functions listed https://openpharma.github.io/brms.mmrm/reference/index.html#informative-prior-archetypes can create different kinds informative prior archetypes dataset like one . example, suppose want place informative priors successive differences adjacent time points. approach appropriate desirable many situations structure naturally captures prior correlations among adjacent visits clinical trial. , create instance “successive cells” archetype. instance archetype ordinary tibble, adds new columns prefixes \"x_\" \"nuisance_\". new columns constitute custom model matrix describe desired parameterization. effects interest express successive differences: also nuisance variables. nuisance variables continuous covariates, others levels one-hot-encoded concomitant factors interactions concomitant factors baseline /subgroup. nuisance variables centered means reference level model “center” data implicitly conditional subset data.1 addition, nuisance variables automatically dropped order ensure model matrix full-rank, automatic centering brms disabled2. critically important preserve interpretation columns interest make sure informative priors behave expected. factors interest linearly map marginal means. see mapping, call summary() archetype. printed output helps build intuition archetype parameterized parameters .3 , x_PBO_VIS1 serves intercept, x_TRT_VIS1 defined relative x_TRT_VIS1. rest parameters keep original interpretations.","code":"library(brms.mmrm) data(fev_data, package = \"mmrm\") data <- fev_data |>   brm_data(     outcome = \"FEV1\",     group = \"ARMCD\",     time = \"AVISIT\",     patient = \"USUBJID\",     reference_time = \"VIS1\",     reference_group = \"PBO\",     covariates = c(\"WEIGHT\", \"SEX\")   ) |>   brm_data_chronologize(order = \"VISITN\") data #> # A tibble: 800 × 10 #>    USUBJID AVISIT ARMCD RACE                SEX   FEV1_BL  FEV1 WEIGHT VISITN VISITN2 #>    <fct>   <ord>  <fct> <fct>               <fct>   <dbl> <dbl>  <dbl>  <int>   <dbl> #>  1 PT2     VIS1   PBO   Asian               Male     45.0  NA    0.465      1  0.330  #>  2 PT2     VIS2   PBO   Asian               Male     45.0  31.5  0.233      2 -0.820  #>  3 PT2     VIS3   PBO   Asian               Male     45.0  36.9  0.360      3  0.487  #>  4 PT2     VIS4   PBO   Asian               Male     45.0  48.8  0.507      4  0.738  #>  5 PT3     VIS1   PBO   Black or African A… Fema…    43.5  NA    0.682      1  0.576  #>  6 PT3     VIS2   PBO   Black or African A… Fema…    43.5  36.0  0.892      2 -0.305  #>  7 PT3     VIS3   PBO   Black or African A… Fema…    43.5  NA    0.128      3  1.51   #>  8 PT3     VIS4   PBO   Black or African A… Fema…    43.5  37.2  0.222      4  0.390  #>  9 PT5     VIS1   PBO   Black or African A… Male     43.6  32.3  0.411      1 -0.0162 #> 10 PT5     VIS2   PBO   Black or African A… Male     43.6  NA    0.422      2  0.944  #> # ℹ 790 more rows archetype <- brm_archetype_successive_cells(data, baseline = FALSE) archetype #> # A tibble: 800 × 20 #>    x_PBO_VIS1 x_PBO_VIS2 x_PBO_VIS3 x_PBO_VIS4 x_TRT_VIS1 x_TRT_VIS2 x_TRT_VIS3 #>  *      <dbl>      <dbl>      <dbl>      <dbl>      <dbl>      <dbl>      <dbl> #>  1          1          0          0          0          0          0          0 #>  2          1          1          0          0          0          0          0 #>  3          1          1          1          0          0          0          0 #>  4          1          1          1          1          0          0          0 #>  5          1          0          0          0          0          0          0 #>  6          1          1          0          0          0          0          0 #>  7          1          1          1          0          0          0          0 #>  8          1          1          1          1          0          0          0 #>  9          1          0          0          0          0          0          0 #> 10          1          1          0          0          0          0          0 #> # ℹ 790 more rows #> # ℹ 13 more variables: x_TRT_VIS4 <dbl>, nuisance_WEIGHT <dbl>, #> #   nuisance_SEX_Male <dbl>, USUBJID <fct>, AVISIT <ord>, ARMCD <fct>, RACE <fct>, #> #   SEX <fct>, FEV1_BL <dbl>, FEV1 <dbl>, WEIGHT <dbl>, VISITN <int>, VISITN2 <dbl> attr(archetype, \"brm_archetype_interest\") #> [1] \"x_PBO_VIS1\" \"x_PBO_VIS2\" \"x_PBO_VIS3\" \"x_PBO_VIS4\" \"x_TRT_VIS1\" \"x_TRT_VIS2\" #> [7] \"x_TRT_VIS3\" \"x_TRT_VIS4\" attr(archetype, \"brm_archetype_nuisance\") #> [1] \"nuisance_WEIGHT\"   \"nuisance_SEX_Male\" summary(archetype) #> # This is the \"successive cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = x_PBO_VIS1 #> #   PBO:VIS2 = x_PBO_VIS1 + x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 + x_PBO_VIS4 #> #   TRT:VIS1 = x_TRT_VIS1 #> #   TRT:VIS2 = x_TRT_VIS1 + x_TRT_VIS2 #> #   TRT:VIS3 = x_TRT_VIS1 + x_TRT_VIS2 + x_TRT_VIS3 #> #   TRT:VIS4 = x_TRT_VIS1 + x_TRT_VIS2 + x_TRT_VIS3 + x_TRT_VIS4"},{"path":"/articles/archetypes.html","id":"informative-priors","dir":"Articles","previous_headings":"","what":"Informative priors","title":"Informative prior archetypes","text":"Let’s assume want assign informative priors fixed effect parameters interest declared archetype, x_group_1_time_2 x_group_2_time_3. priors may come expert elicitation, historical data, method, might consider distributional families recommended Stan team. However construct priors, brms.mmrm helps assign model without guess automatically-generated names model coefficients R. printed output summary(archetype), parameters interest x_group_1_time_2 x_group_2_time_3 always labeled using treatment groups time points data (subgroup levels, applicable). labeling mechanism regardless archetype choose, way brms.mmrm helps assign priors. brm_prior_label() one way create labeling scheme. call brm_prior_label() assigns univariate prior fixed effect parameter. univariate prior Stan code string. Possible choices documented Stan function reference https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html. alternative brm_prior_label(), can start template manually fill Stan code. labeling scheme, brm_prior_archetype() can create brms prior important fixed effects.4 less common situations, may wish assign priors nuisance parameters. example, model accounts interactions baseline discrete time, may reasonable assign priors slopes based high-quality historical data. requires thorough understanding fixed effect structure model, can done directly brms. First, check formula included nuisance parameters. brm_formula() automatically understands archetypes. \"nuisance_*\" terms nuisance variables, ones involving baseline nuisance_FEV1_BL.AVISITVIS1, nuisance_FEV1_BL.AVISITVIS2, nuisance_FEV1_BL.AVISITVIS3, nuisance_FEV1_BL.AVISITVIS4. overall slope baseline, can interpret term linear rate change outcome variable per unit increase baseline given discrete time point. Suppose use interpretation construct informative priors student_t(4, -0.83, 1), student_t(4, -0.78, 1), student_t(4, -0.86, 1), student_t(4, -0.82, 1), respectively. Use brms::set_prior() c() append priors existing prior object: model still many parameters set priors, brms sets automatic defaults. can see defaults brms::get_prior(). https://paulbuerkner.com/brms/reference/set_prior.html documents many default priors set brms. particular, \"(flat)\" denotes improper uniform prior real numbers.","code":"label <- NULL |>   brm_prior_label(code = \"student_t(4, -7.57, 4.96)\", group = \"PBO\", time = \"VIS1\") |>   brm_prior_label(code = \"student_t(4,  3.14, 7.86)\", group = \"PBO\", time = \"VIS2\") |>   brm_prior_label(code = \"student_t(4,  8.78, 8.18)\", group = \"PBO\", time = \"VIS3\") |>   brm_prior_label(code = \"student_t(4,  3.36, 8.10)\", group = \"PBO\", time = \"VIS4\") |>   brm_prior_label(code = \"student_t(4, -2.96, 4.78)\", group = \"TRT\", time = \"VIS1\") |>   brm_prior_label(code = \"student_t(4,  3.13, 7.64)\", group = \"TRT\", time = \"VIS2\") |>   brm_prior_label(code = \"student_t(4,  7.65, 8.24)\", group = \"TRT\", time = \"VIS3\") |>   brm_prior_label(code = \"student_t(4,  4.64, 8.21)\", group = \"TRT\", time = \"VIS4\") label #> # A tibble: 8 × 3 #>   code                      group time  #>   <chr>                     <chr> <chr> #> 1 student_t(4, -7.57, 4.96) PBO   VIS1  #> 2 student_t(4,  3.14, 7.86) PBO   VIS2  #> 3 student_t(4,  8.78, 8.18) PBO   VIS3  #> 4 student_t(4,  3.36, 8.10) PBO   VIS4  #> 5 student_t(4, -2.96, 4.78) TRT   VIS1  #> 6 student_t(4,  3.13, 7.64) TRT   VIS2  #> 7 student_t(4,  7.65, 8.24) TRT   VIS3  #> 8 student_t(4,  4.64, 8.21) TRT   VIS4 template <- brm_prior_template(archetype) template #> # A tibble: 8 × 3 #>   code  group time  #>   <chr> <chr> <chr> #> 1 <NA>  PBO   VIS1  #> 2 <NA>  PBO   VIS2  #> 3 <NA>  PBO   VIS3  #> 4 <NA>  PBO   VIS4  #> 5 <NA>  TRT   VIS1  #> 6 <NA>  TRT   VIS2  #> 7 <NA>  TRT   VIS3  #> 8 <NA>  TRT   VIS4 label <- template |>   mutate(     code = c(       \"student_t(4, -7.57, 4.96)\",       \"student_t(4,  3.14, 7.86)\",       \"student_t(4,  8.78, 8.18)\",       \"student_t(4,  3.36, 8.10)\",       \"student_t(4, -2.96, 4.78)\",       \"student_t(4,  3.13, 7.64)\",       \"student_t(4,  7.65, 8.24)\",       \"student_t(4,  4.64, 8.21)\"     )   ) label #> # A tibble: 8 × 3 #>   code                      group time  #>   <chr>                     <chr> <chr> #> 1 student_t(4, -7.57, 4.96) PBO   VIS1  #> 2 student_t(4,  3.14, 7.86) PBO   VIS2  #> 3 student_t(4,  8.78, 8.18) PBO   VIS3  #> 4 student_t(4,  3.36, 8.10) PBO   VIS4  #> 5 student_t(4, -2.96, 4.78) TRT   VIS1  #> 6 student_t(4,  3.13, 7.64) TRT   VIS2  #> 7 student_t(4,  7.65, 8.24) TRT   VIS3  #> 8 student_t(4,  4.64, 8.21) TRT   VIS4 prior <- brm_prior_archetype(label = label, archetype = archetype) prior #>                      prior class       coef group resp dpar nlpar   lb   ub source #>  student_t(4, -7.57, 4.96)     b x_PBO_VIS1                       <NA> <NA>   user #>  student_t(4,  3.14, 7.86)     b x_PBO_VIS2                       <NA> <NA>   user #>  student_t(4,  8.78, 8.18)     b x_PBO_VIS3                       <NA> <NA>   user #>  student_t(4,  3.36, 8.10)     b x_PBO_VIS4                       <NA> <NA>   user #>  student_t(4, -2.96, 4.78)     b x_TRT_VIS1                       <NA> <NA>   user #>  student_t(4,  3.13, 7.64)     b x_TRT_VIS2                       <NA> <NA>   user #>  student_t(4,  7.65, 8.24)     b x_TRT_VIS3                       <NA> <NA>   user #>  student_t(4,  4.64, 8.21)     b x_TRT_VIS4                       <NA> <NA>   user brm_formula(archetype) #> FEV1 ~ 0 + x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 + x_PBO_VIS4 + x_TRT_VIS1 + x_TRT_VIS2 + x_TRT_VIS3 + x_TRT_VIS4 + nuisance_WEIGHT + nuisance_SEX_Male + unstr(time = AVISIT, gr = USUBJID)  #> sigma ~ 0 + AVISIT"},{"path":"/articles/archetypes.html","id":"modeling-and-analysis","dir":"Articles","previous_headings":"","what":"Modeling and analysis","title":"Informative prior archetypes","text":"downstream methods brms.mmrm automatically understand work informative prior archetypes. Notably, formula uses custom interest nuisance variables instead original variables data. model can accept archetype, formula, prior. Usage non-archetype workflows. Marginal mean estimation, post-processing, visualization automatically understand archetype without user intervention. plot chunk archetype_compare_data","code":"formula <- brm_formula(archetype) formula #> FEV1 ~ 0 + x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 + x_PBO_VIS4 + x_TRT_VIS1 + x_TRT_VIS2 + x_TRT_VIS3 + x_TRT_VIS4 + nuisance_WEIGHT + nuisance_SEX_Male + unstr(time = AVISIT, gr = USUBJID)  #> sigma ~ 0 + AVISIT model <- brm_model(   data = archetype,   formula = formula,   prior = prior,   refresh = 0 ) #> Compiling Stan program... #> Start sampling brms::prior_summary(model) #>                      prior    class              coef group resp  dpar nlpar lb ub #>                     (flat)        b                                                #>                     (flat)        b nuisance_SEX_Male                              #>                     (flat)        b   nuisance_WEIGHT                              #>  student_t(4, -7.57, 4.96)        b        x_PBO_VIS1                              #>  student_t(4,  3.14, 7.86)        b        x_PBO_VIS2                              #>  student_t(4,  8.78, 8.18)        b        x_PBO_VIS3                              #>  student_t(4,  3.36, 8.10)        b        x_PBO_VIS4                              #>  student_t(4, -2.96, 4.78)        b        x_TRT_VIS1                              #>  student_t(4,  3.13, 7.64)        b        x_TRT_VIS2                              #>  student_t(4,  7.65, 8.24)        b        x_TRT_VIS3                              #>  student_t(4,  4.64, 8.21)        b        x_TRT_VIS4                              #>                     (flat)        b                              sigma             #>                     (flat)        b        AVISITVIS1            sigma             #>                     (flat)        b        AVISITVIS2            sigma             #>                     (flat)        b        AVISITVIS3            sigma             #>                     (flat)        b        AVISITVIS4            sigma             #>       lkj_corr_cholesky(1) Lcortime                                                #>        source #>       default #>  (vectorized) #>  (vectorized) #>          user #>          user #>          user #>          user #>          user #>          user #>          user #>          user #>       default #>  (vectorized) #>  (vectorized) #>  (vectorized) #>  (vectorized) #>       default draws <- brm_marginal_draws(   data = archetype,   formula = formula,   model = model ) summaries_model <- brm_marginal_summaries(draws) summaries_data <- brm_marginal_data(archetype) brm_plot_compare(model = summaries_model, data = summaries_data)"},{"path":"/articles/archetypes.html","id":"all-archetypes","dir":"Articles","previous_headings":"","what":"All archetypes","title":"Informative prior archetypes","text":"brms.mmrm supports variety informative prior archetypes different kinds fixed effects. example, brms.mmrm supports simple cell mean treatment effect parameterizations. archetypes parameterize average across time points data. , x_group_1_time_2 average across time points group 1 algebraic result simplifying (group_1:time_2 + group_1:time_3 + group_1:time_3) / 3. also treatment effect version x_group_2_time_2 becomes time-averaged treatment effect group 2 relative group 1. example vignette uses “successive cells” archetype, fixed effects represent successive differences adjacent time points. also treatment effect version successive differences archetype:","code":"summary(brm_archetype_cells(data, intercept = FALSE)) #> # This is the \"cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = x_PBO_VIS1 #> #   PBO:VIS2 = x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS4 #> #   TRT:VIS1 = x_TRT_VIS1 #> #   TRT:VIS2 = x_TRT_VIS2 #> #   TRT:VIS3 = x_TRT_VIS3 #> #   TRT:VIS4 = x_TRT_VIS4 summary(brm_archetype_effects(data, intercept = FALSE)) #> # This is the \"effects\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = x_PBO_VIS1 #> #   PBO:VIS2 = x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS4 #> #   TRT:VIS1 = x_PBO_VIS1 + x_TRT_VIS1 #> #   TRT:VIS2 = x_PBO_VIS2 + x_TRT_VIS2 #> #   TRT:VIS3 = x_PBO_VIS3 + x_TRT_VIS3 #> #   TRT:VIS4 = x_PBO_VIS4 + x_TRT_VIS4 summary(brm_archetype_average_cells(data, intercept = FALSE)) #> # This is the \"average cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = 4*x_PBO_VIS1 - x_PBO_VIS2 - x_PBO_VIS3 - x_PBO_VIS4 #> #   PBO:VIS2 = x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS4 #> #   TRT:VIS1 = 4*x_TRT_VIS1 - x_TRT_VIS2 - x_TRT_VIS3 - x_TRT_VIS4 #> #   TRT:VIS2 = x_TRT_VIS2 #> #   TRT:VIS3 = x_TRT_VIS3 #> #   TRT:VIS4 = x_TRT_VIS4 summary(brm_archetype_average_effects(data, intercept = FALSE)) #> # This is the \"average effects\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = 4*x_PBO_VIS1 - x_PBO_VIS2 - x_PBO_VIS3 - x_PBO_VIS4 #> #   PBO:VIS2 = x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS4 #> #   TRT:VIS1 = 4*x_PBO_VIS1 - x_PBO_VIS2 - x_PBO_VIS3 - x_PBO_VIS4 + 4*x_TRT_VIS1 - x_TRT_VIS2 - x_TRT_VIS3 - x_TRT_VIS4 #> #   TRT:VIS2 = x_PBO_VIS2 + x_TRT_VIS2 #> #   TRT:VIS3 = x_PBO_VIS3 + x_TRT_VIS3 #> #   TRT:VIS4 = x_PBO_VIS4 + x_TRT_VIS4 summary(brm_archetype_successive_cells(data, intercept = FALSE)) #> # This is the \"successive cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = x_PBO_VIS1 #> #   PBO:VIS2 = x_PBO_VIS1 + x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 + x_PBO_VIS4 #> #   TRT:VIS1 = x_TRT_VIS1 #> #   TRT:VIS2 = x_TRT_VIS1 + x_TRT_VIS2 #> #   TRT:VIS3 = x_TRT_VIS1 + x_TRT_VIS2 + x_TRT_VIS3 #> #   TRT:VIS4 = x_TRT_VIS1 + x_TRT_VIS2 + x_TRT_VIS3 + x_TRT_VIS4 summary(brm_archetype_successive_effects(data, intercept = FALSE)) #> # This is the \"successive effects\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = x_PBO_VIS1 #> #   PBO:VIS2 = x_PBO_VIS1 + x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 + x_PBO_VIS4 #> #   TRT:VIS1 = x_PBO_VIS1 + x_TRT_VIS1 #> #   TRT:VIS2 = x_PBO_VIS1 + x_PBO_VIS2 + x_TRT_VIS1 + x_TRT_VIS2 #> #   TRT:VIS3 = x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 + x_TRT_VIS1 + x_TRT_VIS2 + x_TRT_VIS3 #> #   TRT:VIS4 = x_PBO_VIS1 + x_PBO_VIS2 + x_PBO_VIS3 + x_PBO_VIS4 + x_TRT_VIS1 + x_TRT_VIS2 + x_TRT_VIS3 + x_TRT_VIS4"},{"path":"/articles/archetypes.html","id":"variations-on-archetypes","dir":"Articles","previous_headings":"","what":"Variations on archetypes","title":"Informative prior archetypes","text":"Archetypes can customized. example, consider simple cell means archetype. include intercept term marginal means share, set intercept = TRUE. set constrained longitudinal data analysis (cLDA), set clda = TRUE. constraint pools treatment groups baseline, can help model clinical trials baseline measurement observed randomization. archetypes support cLDA (e.g. brm_archetype_average_cells() brm_archetype_average_effects()).","code":"summary(brm_archetype_cells(data)) #> # This is the \"cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = x_PBO_VIS1 #> #   PBO:VIS2 = x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS4 #> #   TRT:VIS1 = x_TRT_VIS1 #> #   TRT:VIS2 = x_TRT_VIS2 #> #   TRT:VIS3 = x_TRT_VIS3 #> #   TRT:VIS4 = x_TRT_VIS4 summary(brm_archetype_cells(data, intercept = TRUE)) #> # This is the \"cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = x_PBO_VIS1 #> #   PBO:VIS2 = x_PBO_VIS1 + x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS1 + x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS1 + x_PBO_VIS4 #> #   TRT:VIS1 = x_PBO_VIS1 + x_TRT_VIS1 #> #   TRT:VIS2 = x_PBO_VIS1 + x_TRT_VIS2 #> #   TRT:VIS3 = x_PBO_VIS1 + x_TRT_VIS3 #> #   TRT:VIS4 = x_PBO_VIS1 + x_TRT_VIS4 summary(brm_archetype_cells(data, clda = TRUE)) #> # This is the \"cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = x_PBO_VIS1 #> #   PBO:VIS2 = x_PBO_VIS2 #> #   PBO:VIS3 = x_PBO_VIS3 #> #   PBO:VIS4 = x_PBO_VIS4 #> #   TRT:VIS1 = x_PBO_VIS1 #> #   TRT:VIS2 = x_TRT_VIS2 #> #   TRT:VIS3 = x_TRT_VIS3 #> #   TRT:VIS4 = x_TRT_VIS4"},{"path":"/articles/bcva.html","id":"about","dir":"Articles","previous_headings":"","what":"About","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"vignette uses bcva_data dataset mmrm package compare Bayesian MMRM fit, obtained brms.mmrm::brm_model(), frequentist MMRM fit, obtained mmrm::mmrm(). overview parameter estimates differences type MMRM given summary (Tables 4 5) end.","code":""},{"path":"/articles/bcva.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"comparison workflow requires following packages. set seed random number generator ensure statistical reproducibility.","code":"> packages <- c( +   \"dplyr\", +   \"tidyr\", +   \"ggplot2\", +   \"gt\", +   \"gtsummary\", +   \"purrr\", +   \"parallel\", +   \"brms.mmrm\", +   \"mmrm\", +   \"posterior\" + ) > invisible(lapply(packages, library, character.only = TRUE)) > set.seed(123L)"},{"path":[]},{"path":"/articles/bcva.html","id":"pre-processing","dir":"Articles","previous_headings":"Data","what":"Pre-processing","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"analysis exercise uses bcva_data dataset contained mmrm package: According https://openpharma.github.io/mmrm/latest-tag/articles/mmrm_review_methods.html: BCVA dataset contains data randomized longitudinal ophthalmology trial evaluating change baseline corrected visual acuity (BCVA) course 10 visits. BCVA corresponds number letters read visual acuity chart. dataset tibble 8605 rows following notable variables. USUBJID (subject ID) AVISIT (visit number, factor) VISITN (visit number, numeric) ARMCD (treatment, TRT CTL) RACE (3-category race) BCVA_BL (BCVA baseline) BCVA_CHG (BCVA change baseline, primary endpoint analysis) rest pre-processing steps create factors study arm visit apply usual checking standardization steps brms.mmrm::brm_data(). following table shows first rows dataset. Table 1. First rows pre-processed bcva_data dataset.","code":"> data(bcva_data, package = \"mmrm\") > bcva_data <- bcva_data |> +   mutate(AVISIT = gsub(\"VIS0*\", \"VIS\", as.character(AVISIT))) |> +   brm_data( +     outcome = \"BCVA_CHG\", +     group = \"ARMCD\", +     time = \"AVISIT\", +     patient = \"USUBJID\", +     baseline = \"BCVA_BL\", +     reference_group = \"CTL\", +     covariates = \"RACE\" +   ) |> +   brm_data_chronologize(order = \"VISITN\") > head(bcva_data) |> +   gt() |> +   tab_caption(caption = md(\"Table 1. First rows of the pre-processed `bcva_data` dataset.\"))"},{"path":"/articles/bcva.html","id":"descriptive-statistics","dir":"Articles","previous_headings":"Data","what":"Descriptive statistics","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"Table baseline characteristics: Table 2. Baseline characteristics. Table change baseline BCVA 52 weeks: Table 3. Change baseline. following figure shows primary endpoint four study visits data. Figure 1. Change baseline BCVA 4 visit time points.","code":"> bcva_data |> +   select(ARMCD, USUBJID, RACE, BCVA_BL) |> +   distinct() |> +   select(-USUBJID) |> +   tbl_summary( +     by = c(ARMCD), +     statistic = list( +       all_continuous() ~ \"{mean} ({sd})\", +       all_categorical() ~ \"{n} / {N} ({p}%)\" +     ) +   ) |> +   modify_caption(\"Table 2. Baseline characteristics.\") > bcva_data |> +   pull(AVISIT) |> +   unique() |> +   sort() |> +   purrr::map( +     .f = ~ bcva_data |> +       filter(AVISIT %in% .x) |> +       tbl_summary( +         by = ARMCD, +         include = BCVA_CHG, +         type = BCVA_CHG ~ \"continuous2\", +         statistic = BCVA_CHG ~ c( +           \"{mean} ({sd})\", +           \"{median} ({p25}, {p75})\", +           \"{min}, {max}\" +         ), +         label = list(BCVA_CHG = paste(\"Visit \", .x)) +       ) +   ) |> +   tbl_stack(quiet = TRUE) |> +   modify_caption(\"Table 3. Change from baseline.\") > bcva_data |> +   group_by(ARMCD) |> +   ggplot(aes(x = AVISIT, y = BCVA_CHG, fill = factor(ARMCD))) + +   geom_hline(yintercept = 0, col = \"grey\", linewidth = 1.2) + +   geom_boxplot(na.rm = TRUE) + +   labs( +     x = \"Visit\", +     y = \"Change from baseline in BCVA\", +     fill = \"Treatment\" +   ) + +   scale_fill_manual(values = c(\"darkgoldenrod2\", \"coral2\")) + +   theme_bw()"},{"path":[]},{"path":"/articles/bcva.html","id":"bayesian-model","dir":"Articles","previous_headings":"Fitting MMRMs","what":"Bayesian model","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"formula Bayesian model includes additive effects baseline, study visit, race, study-arm--visit interaction. fit model using brms.mmrm::brm_model(). computation takes several minutes size dataset. ensure good basis comparison frequentist model, put extremely diffuse prior intercept. parameters already diffuse flexible priors default. posterior summary model parameters, including fixed effects pairwise correlation among visits within patients.","code":"> b_mmrm_formula <- brm_formula( +   data = bcva_data, +   intercept = TRUE, +   baseline = TRUE, +   group = FALSE, +   time = TRUE, +   baseline_time = FALSE, +   group_time = TRUE, +   correlation = \"unstructured\" + ) > print(b_mmrm_formula) #> BCVA_CHG ~ BCVA_BL + ARMCD:AVISIT + AVISIT + RACE + unstr(time = AVISIT, gr = USUBJID)  #> sigma ~ 0 + AVISIT > b_mmrm_fit <- brm_model( +   data = filter(bcva_data, !is.na(BCVA_CHG)), +   formula = b_mmrm_formula, +   prior = brms::prior(class = \"Intercept\", prior = \"student_t(3, 0, 1000)\"), +   iter = 10000, +   warmup = 2000, +   chains = 4, +   cores = 4, +   seed = 1, +   refresh = 0 + ) > summary(b_mmrm_fit) #>  Family: gaussian  #>   Links: mu = identity; sigma = log  #> Formula: BCVA_CHG ~ BCVA_BL + ARMCD:AVISIT + AVISIT + RACE + unstr(time = AVISIT, gr = USUBJID)  #>          sigma ~ 0 + AVISIT #>    Data: data[!is.na(data[[attr(data, \"brm_outcome\")]]), ] (Number of observations: 8605)  #>   Draws: 4 chains, each with iter = 10000; warmup = 2000; thin = 1; #>          total post-warmup draws = 32000 #>  #> Correlation Structures: #>                     Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS #> cortime(VIS1,VIS2)      0.05      0.03    -0.01     0.11 1.00    63561    23159 #> cortime(VIS1,VIS3)      0.31      0.03     0.25     0.36 1.00    70330    25831 #> cortime(VIS2,VIS3)      0.05      0.03    -0.02     0.11 1.00    67715    22226 #> cortime(VIS1,VIS4)      0.21      0.03     0.15     0.27 1.00    46375    28108 #> cortime(VIS2,VIS4)      0.14      0.03     0.07     0.20 1.00    50232    27277 #> cortime(VIS3,VIS4)     -0.01      0.03    -0.07     0.05 1.00    50449    26940 #> cortime(VIS1,VIS5)      0.17      0.03     0.11     0.23 1.00    49366    27023 #> cortime(VIS2,VIS5)      0.12      0.03     0.05     0.18 1.00    53327    28297 #> cortime(VIS3,VIS5)     -0.01      0.03    -0.07     0.06 1.00    52752    26884 #> cortime(VIS4,VIS5)      0.38      0.03     0.32     0.43 1.00    49514    26959 #> cortime(VIS1,VIS6)      0.26      0.03     0.20     0.32 1.00    45483    26765 #> cortime(VIS2,VIS6)      0.20      0.03     0.14     0.27 1.00    48236    27168 #> cortime(VIS3,VIS6)      0.04      0.03    -0.02     0.11 1.00    51506    27189 #> cortime(VIS4,VIS6)      0.40      0.03     0.35     0.46 1.00    48730    25696 #> cortime(VIS5,VIS6)      0.39      0.03     0.34     0.45 1.00    55438    25998 #> cortime(VIS1,VIS7)      0.07      0.04    -0.00     0.13 1.00    66961    24586 #> cortime(VIS2,VIS7)      0.09      0.03     0.02     0.15 1.00    66564    23212 #> cortime(VIS3,VIS7)     -0.00      0.03    -0.07     0.07 1.00    62299    24284 #> cortime(VIS4,VIS7)      0.15      0.03     0.08     0.22 1.00    70101    23346 #> cortime(VIS5,VIS7)      0.19      0.03     0.13     0.26 1.00    71412    24243 #> cortime(VIS6,VIS7)      0.21      0.04     0.14     0.28 1.00    69307    23697 #> cortime(VIS1,VIS8)      0.05      0.04    -0.02     0.12 1.00    70424    22845 #> cortime(VIS2,VIS8)      0.10      0.04     0.03     0.17 1.00    71230    23497 #> cortime(VIS3,VIS8)     -0.03      0.04    -0.10     0.04 1.00    65689    22667 #> cortime(VIS4,VIS8)      0.17      0.03     0.10     0.24 1.00    68079    23681 #> cortime(VIS5,VIS8)      0.17      0.04     0.10     0.24 1.00    73436    24011 #> cortime(VIS6,VIS8)      0.16      0.04     0.09     0.23 1.00    68602    23567 #> cortime(VIS7,VIS8)      0.05      0.04    -0.02     0.13 1.00    68688    23661 #> cortime(VIS1,VIS9)      0.03      0.04    -0.04     0.10 1.00    70389    23613 #> cortime(VIS2,VIS9)     -0.01      0.04    -0.08     0.07 1.00    72988    22674 #> cortime(VIS3,VIS9)     -0.04      0.04    -0.12     0.03 1.00    73818    23450 #> cortime(VIS4,VIS9)      0.12      0.04     0.04     0.19 1.00    73299    24366 #> cortime(VIS5,VIS9)      0.09      0.04     0.02     0.16 1.00    72264    22069 #> cortime(VIS6,VIS9)      0.17      0.04     0.10     0.24 1.00    74018    24561 #> cortime(VIS7,VIS9)      0.02      0.04    -0.06     0.09 1.00    70521    22326 #> cortime(VIS8,VIS9)      0.06      0.04    -0.02     0.14 1.00    71301    22488 #> cortime(VIS1,VIS10)     0.02      0.04    -0.06     0.10 1.00    62930    25421 #> cortime(VIS2,VIS10)     0.13      0.04     0.05     0.20 1.00    58101    25684 #> cortime(VIS3,VIS10)     0.02      0.04    -0.06     0.10 1.00    60757    24802 #> cortime(VIS4,VIS10)     0.31      0.04     0.24     0.38 1.00    62762    26583 #> cortime(VIS5,VIS10)     0.24      0.04     0.16     0.31 1.00    66606    25076 #> cortime(VIS6,VIS10)     0.30      0.04     0.22     0.37 1.00    67998    23891 #> cortime(VIS7,VIS10)     0.06      0.04    -0.03     0.15 1.00    68944    23170 #> cortime(VIS8,VIS10)     0.09      0.04     0.01     0.18 1.00    71353    23530 #> cortime(VIS9,VIS10)     0.08      0.05    -0.01     0.17 1.00    65710    22799 #>  #> Regression Coefficients: #>                      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS #> Intercept                4.29      0.17     3.96     4.62 1.00    56813 #> BCVA_BL                 -0.00      0.00    -0.01     0.00 1.00    59119 #> AVISIT2                  0.28      0.07     0.14     0.42 1.00    29890 #> AVISIT3                  0.46      0.07     0.33     0.59 1.00    44348 #> AVISIT4                  0.86      0.08     0.70     1.01 1.00    27610 #> AVISIT5                  0.96      0.09     0.79     1.13 1.00    29630 #> AVISIT6                  1.33      0.09     1.16     1.50 1.00    28672 #> AVISIT7                  1.42      0.11     1.21     1.63 1.00    34514 #> AVISIT8                  1.71      0.11     1.49     1.94 1.00    34167 #> AVISIT9                  2.00      0.13     1.75     2.25 1.00    35177 #> AVISIT10                 2.10      0.14     1.82     2.38 1.00    33084 #> RACEBlack                1.04      0.05     0.93     1.15 1.00    53517 #> RACEWhite                2.01      0.05     1.90     2.11 1.00    54553 #> AVISITVIS1:ARMCDTRT      0.54      0.06     0.41     0.66 1.00    34057 #> AVISITVIS2:ARMCDTRT      0.72      0.08     0.57     0.88 1.00    50542 #> AVISITVIS3:ARMCDTRT      1.01      0.09     0.83     1.19 1.00    48732 #> AVISITVIS4:ARMCDTRT      1.10      0.10     0.91     1.31 1.00    36650 #> AVISITVIS5:ARMCDTRT      1.38      0.12     1.16     1.61 1.00    38946 #> AVISITVIS6:ARMCDTRT      1.63      0.12     1.40     1.86 1.00    36052 #> AVISITVIS7:ARMCDTRT      2.02      0.14     1.74     2.29 1.00    45530 #> AVISITVIS8:ARMCDTRT      2.35      0.15     2.06     2.64 1.00    44496 #> AVISITVIS9:ARMCDTRT      2.66      0.16     2.33     2.98 1.00    44251 #> AVISITVIS10:ARMCDTRT     3.07      0.18     2.71     3.43 1.00    41207 #> sigma_AVISITVIS1        -0.01      0.02    -0.05     0.03 1.00    63843 #> sigma_AVISITVIS2         0.23      0.02     0.18     0.27 1.00    77180 #> sigma_AVISITVIS3         0.36      0.02     0.31     0.40 1.00    68147 #> sigma_AVISITVIS4         0.44      0.02     0.40     0.49 1.00    54719 #> sigma_AVISITVIS5         0.57      0.02     0.52     0.61 1.00    60122 #> sigma_AVISITVIS6         0.58      0.02     0.54     0.63 1.00    54741 #> sigma_AVISITVIS7         0.69      0.02     0.64     0.74 1.00    67848 #> sigma_AVISITVIS8         0.74      0.03     0.69     0.79 1.00    73959 #> sigma_AVISITVIS9         0.80      0.03     0.75     0.85 1.00    73387 #> sigma_AVISITVIS10        0.84      0.03     0.79     0.90 1.00    69664 #>                      Tail_ESS #> Intercept               25046 #> BCVA_BL                 22844 #> AVISIT2                 25900 #> AVISIT3                 26347 #> AVISIT4                 26145 #> AVISIT5                 25959 #> AVISIT6                 25061 #> AVISIT7                 27504 #> AVISIT8                 26821 #> AVISIT9                 25947 #> AVISIT10                25296 #> RACEBlack               25805 #> RACEWhite               27113 #> AVISITVIS1:ARMCDTRT     27968 #> AVISITVIS2:ARMCDTRT     25650 #> AVISITVIS3:ARMCDTRT     27016 #> AVISITVIS4:ARMCDTRT     26502 #> AVISITVIS5:ARMCDTRT     25407 #> AVISITVIS6:ARMCDTRT     26418 #> AVISITVIS7:ARMCDTRT     26547 #> AVISITVIS8:ARMCDTRT     26731 #> AVISITVIS9:ARMCDTRT     26034 #> AVISITVIS10:ARMCDTRT    25859 #> sigma_AVISITVIS1        24881 #> sigma_AVISITVIS2        24252 #> sigma_AVISITVIS3        23768 #> sigma_AVISITVIS4        25358 #> sigma_AVISITVIS5        25761 #> sigma_AVISITVIS6        27071 #> sigma_AVISITVIS7        24330 #> sigma_AVISITVIS8        22567 #> sigma_AVISITVIS9        22205 #> sigma_AVISITVIS10       25249 #>  #> Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS #> and Tail_ESS are effective sample size measures, and Rhat is the potential #> scale reduction factor on split chains (at convergence, Rhat = 1)."},{"path":"/articles/bcva.html","id":"frequentist-model","dir":"Articles","previous_headings":"Fitting MMRMs","what":"Frequentist model","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"formula frequentist model , except different syntax specifying covariance structure MMRM. fit model . parameter summaries frequentist model .","code":"> f_mmrm_fit <- mmrm::mmrm( +   formula = BCVA_CHG ~ BCVA_BL + ARMCD:AVISIT + AVISIT + RACE + +     us(AVISIT | USUBJID), +   data = mutate( +     bcva_data, +     AVISIT = factor(as.character(AVISIT), ordered = FALSE) +   ) + ) > summary(f_mmrm_fit) #> mmrm fit #>  #> Formula:     BCVA_CHG ~ BCVA_BL + ARMCD:AVISIT + AVISIT + RACE + us(AVISIT |   #>     USUBJID) #> Data:         #> mutate(bcva_data, AVISIT = factor(as.character(AVISIT), ordered = FALSE)) (used  #> 8605 observations from 1000 subjects with maximum 10 timepoints) #> Covariance:  unstructured (55 variance parameters) #> Method:      Satterthwaite #> Vcov Method: Asymptotic #> Inference:   REML #>  #> Model selection criteria: #>      AIC      BIC   logLik deviance  #>  32181.0  32451.0 -16035.5  32071.0  #>  #> Coefficients:  #>                        Estimate Std. Error         df t value Pr(>|t|)     #> (Intercept)           4.288e+00  1.709e-01  1.065e+03  25.085  < 2e-16 *** #> BCVA_BL              -9.935e-04  2.156e-03  9.905e+02  -0.461    0.645     #> AVISITVIS10           2.101e+00  1.400e-01  7.025e+02  15.003  < 2e-16 *** #> AVISITVIS2            2.810e-01  7.067e-02  9.995e+02   3.976 7.51e-05 *** #> AVISITVIS3            4.573e-01  6.716e-02  9.747e+02   6.809 1.71e-11 *** #> AVISITVIS4            8.570e-01  7.636e-02  9.796e+02  11.222  < 2e-16 *** #> AVISITVIS5            9.638e-01  8.634e-02  9.630e+02  11.163  < 2e-16 *** #> AVISITVIS6            1.334e+00  8.650e-02  9.451e+02  15.421  < 2e-16 *** #> AVISITVIS7            1.417e+00  1.071e-01  8.698e+02  13.233  < 2e-16 *** #> AVISITVIS8            1.711e+00  1.145e-01  8.467e+02  14.944  < 2e-16 *** #> AVISITVIS9            1.996e+00  1.283e-01  7.784e+02  15.549  < 2e-16 *** #> RACEBlack             1.038e+00  5.496e-02  1.011e+03  18.891  < 2e-16 *** #> RACEWhite             2.005e+00  5.198e-02  9.768e+02  38.573  < 2e-16 *** #> AVISITVIS1:ARMCDTRT   5.391e-01  6.282e-02  9.859e+02   8.582  < 2e-16 *** #> AVISITVIS10:ARMCDTRT  3.072e+00  1.815e-01  6.620e+02  16.929  < 2e-16 *** #> AVISITVIS2:ARMCDTRT   7.248e-01  7.984e-02  9.803e+02   9.078  < 2e-16 *** #> AVISITVIS3:ARMCDTRT   1.012e+00  9.163e-02  9.638e+02  11.039  < 2e-16 *** #> AVISITVIS4:ARMCDTRT   1.104e+00  1.004e-01  9.653e+02  11.003  < 2e-16 *** #> AVISITVIS5:ARMCDTRT   1.383e+00  1.147e-01  9.505e+02  12.065  < 2e-16 *** #> AVISITVIS6:ARMCDTRT   1.630e+00  1.189e-01  9.157e+02  13.715  < 2e-16 *** #> AVISITVIS7:ARMCDTRT   2.016e+00  1.382e-01  8.262e+02  14.592  < 2e-16 *** #> AVISITVIS8:ARMCDTRT   2.347e+00  1.474e-01  8.041e+02  15.924  < 2e-16 *** #> AVISITVIS9:ARMCDTRT   2.658e+00  1.644e-01  7.277e+02  16.172  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Covariance estimate: #>         VIS1  VIS10    VIS2    VIS3    VIS4    VIS5   VIS6    VIS7    VIS8 #> VIS1  0.9713 0.0587  0.0630  0.4371  0.3315  0.3056 0.4688  0.1325  0.1020 #> VIS10 0.0587 5.3519  0.3761  0.0719  1.1478  0.9997 1.2558  0.3021  0.4658 #> VIS2  0.0630 0.3761  1.5618  0.0871  0.2684  0.2635 0.4636  0.2180  0.2776 #> VIS3  0.4371 0.0719  0.0871  2.0221 -0.0216 -0.0189 0.1102 -0.0048 -0.0993 #> VIS4  0.3315 1.1478  0.2684 -0.0216  2.4113  1.0475 1.1409  0.4625  0.5659 #> VIS5  0.3056 0.9997  0.2635 -0.0189  1.0475  3.0916 1.2593  0.6911  0.6308 #> VIS6  0.4688 1.2558  0.4636  0.1102  1.1409  1.2593 3.1853  0.7540  0.6094 #> VIS7  0.1325 0.3021  0.2180 -0.0048  0.4625  0.6911 0.7540  3.9272  0.2306 #> VIS8  0.1020 0.4658  0.2776 -0.0993  0.5659  0.6308 0.6094  0.2306  4.3272 #> VIS9  0.0611 0.4141 -0.0153 -0.1321  0.4085  0.3594 0.6823  0.0723  0.2683 #>          VIS9 #> VIS1   0.0611 #> VIS10  0.4141 #> VIS2  -0.0153 #> VIS3  -0.1321 #> VIS4   0.4085 #> VIS5   0.3594 #> VIS6   0.6823 #> VIS7   0.0723 #> VIS8   0.2683 #> VIS9   4.8635"},{"path":"/articles/bcva.html","id":"comparison","dir":"Articles","previous_headings":"","what":"Comparison","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"section compares Bayesian posterior parameter estimates brms.mmrm frequentist parameter estimates mmrm package.","code":""},{"path":"/articles/bcva.html","id":"extract-estimates-from-bayesian-model","dir":"Articles","previous_headings":"Comparison","what":"Extract estimates from Bayesian model","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"extract standardize Bayesian estimates.","code":"> b_mmrm_draws <- b_mmrm_fit |> +   as_draws_df() > visit_levels <- sort(unique(as.character(bcva_data$AVISIT))) > for (level in visit_levels) { +   name <- paste0(\"b_sigma_AVISIT\", level) +   b_mmrm_draws[[name]] <- exp(b_mmrm_draws[[name]]) + } > b_mmrm_summary <- b_mmrm_draws |> +   summarize_draws() |> +   select(variable, mean, sd) |> +   filter(!(variable %in% c(\"Intercept\", \"lprior\", \"lp__\"))) |> +   rename(bayes_estimate = mean, bayes_se = sd) |> +   mutate( +     variable = variable |> +       tolower() |> +       gsub(pattern = \"b_\", replacement = \"\") |> +       gsub(pattern = \"b_sigma_AVISIT\", replacement = \"sigma_\") |> +       gsub(pattern = \"cortime\", replacement = \"correlation\") |> +       gsub(pattern = \"__\", replacement = \"_\") |> +       gsub(pattern = \"avisitvis\", replacement = \"avisit\") +   )"},{"path":"/articles/bcva.html","id":"extract-estimates-from-frequentist-model","dir":"Articles","previous_headings":"Comparison","what":"Extract estimates from frequentist model","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"extract standardize frequentist estimates.","code":"> f_mmrm_fixed <- summary(f_mmrm_fit)$coefficients |> +   as_tibble(rownames = \"variable\") |> +   mutate(variable = tolower(variable)) |> +   mutate(variable = gsub(\"(\", \"\", variable, fixed = TRUE)) |> +   mutate(variable = gsub(\")\", \"\", variable, fixed = TRUE)) |> +   mutate(variable = gsub(\"avisitvis\", \"avisit\", variable)) |> +   rename(freq_estimate = Estimate, freq_se = `Std. Error`) |> +   select(variable, freq_estimate, freq_se) > f_mmrm_variance <- tibble( +   variable = paste0(\"sigma_AVISIT\", visit_levels) |> +     tolower() |> +     gsub(pattern = \"avisitvis\", replacement = \"avisit\"), +   freq_estimate = sqrt(diag(f_mmrm_fit$cov)) + ) > f_diagonal_factor <- diag(1 / sqrt(diag(f_mmrm_fit$cov))) > f_corr_matrix <- f_diagonal_factor %*% f_mmrm_fit$cov %*% f_diagonal_factor > colnames(f_corr_matrix) <- visit_levels > f_mmrm_correlation <- f_corr_matrix |> +   as.data.frame() |> +   as_tibble() |> +   mutate(x1 = visit_levels) |> +   pivot_longer( +     cols = -any_of(\"x1\"), +     names_to = \"x2\", +     values_to = \"freq_estimate\" +   ) |> +   filter( +     as.numeric(gsub(\"[^0-9]\", \"\", x1)) < as.numeric(gsub(\"[^0-9]\", \"\", x2)) +   ) |> +   mutate(variable = sprintf(\"correlation_%s_%s\", x1, x2)) |> +   select(variable, freq_estimate) > f_mmrm_summary <- bind_rows( +   f_mmrm_fixed, +   f_mmrm_variance, +   f_mmrm_correlation + ) |> +   mutate(variable = gsub(\"\\\\s+\", \"\", variable) |> tolower())"},{"path":"/articles/bcva.html","id":"Summary","dir":"Articles","previous_headings":"Comparison","what":"Summary","title":"BCVA data comparison between Bayesian and frequentist MMRMs","text":"first table summarizes parameter estimates model differences estimates (Bayesian minus frequentist). second table shows standard errors estimates differences standard errors. table, “Relative” column shows relative difference (difference divided frequentist quantity). different statistical paradigms estimation procedures, especially regarding covariance parameters, realistic expect Bayesian frequentist approaches yield virtually identical results. Nevertheless, absolute relative differences table show strong agreement brms.mmrm mmrm. Table 4. Comparison parameter estimates Bayesian frequentist MMRMs. Table 5. Comparison parameter standard errors Bayesian frequentist MMRMs.","code":"> b_f_comparison <- full_join( +   x = b_mmrm_summary, +   y = f_mmrm_summary, +   by = \"variable\" + ) |> +   mutate( +     diff_estimate = bayes_estimate - freq_estimate, +     diff_relative_estimate = diff_estimate / freq_estimate, +     diff_se = bayes_se - freq_se, +     diff_relative_se = diff_se / freq_se +   ) |> +   select(variable, ends_with(\"estimate\"), ends_with(\"se\")) > table_estimates <- b_f_comparison |> +   select(variable, ends_with(\"estimate\")) > gt(table_estimates) |> +   fmt_number(decimals = 4) |> +   tab_caption( +     caption = md( +       paste( +         \"Table 4. Comparison of parameter estimates between\", +         \"Bayesian and frequentist MMRMs.\" +       ) +     ) +   ) |> +   cols_label( +     variable = \"Variable\", +     bayes_estimate = \"Bayesian\", +     freq_estimate = \"Frequentist\", +     diff_estimate = \"Difference\", +     diff_relative_estimate = \"Relative\" +   ) > table_se <- b_f_comparison |> +   select(variable, ends_with(\"se\")) |> +   filter(!is.na(freq_se)) > gt(table_se) |> +   fmt_number(decimals = 4) |> +   tab_caption( +     caption = md( +       paste( +         \"Table 5. Comparison of parameter standard errors between\", +         \"Bayesian and frequentist MMRMs.\" +       ) +     ) +   ) |> +   cols_label( +     variable = \"Variable\", +     bayes_se = \"Bayesian\", +     freq_se = \"Frequentist\", +     diff_se = \"Difference\", +     diff_relative_se = \"Relative\" +   )"},{"path":"/articles/fev1.html","id":"about","dir":"Articles","previous_headings":"","what":"About","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"vignette provides example comparison Bayesian MMRM fit, obtained brms.mmrm::brm_model(), frequentist MMRM fit, obtained mmrm::mmrm(). overview parameter estimates differences type MMRM given summary (Tables 4 5) end.","code":""},{"path":"/articles/fev1.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"comparison workflow requires following packages. set seed random number generator ensure statistical reproducibility.","code":"> packages <- c( +   \"dplyr\", +   \"tidyr\", +   \"ggplot2\", +   \"gt\", +   \"gtsummary\", +   \"purrr\", +   \"parallel\", +   \"brms.mmrm\", +   \"mmrm\", +   \"posterior\" + ) > invisible(lapply(packages, library, character.only = TRUE)) > set.seed(123L)"},{"path":[]},{"path":"/articles/fev1.html","id":"pre-processing","dir":"Articles","previous_headings":"Data","what":"Pre-processing","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"analysis exercise uses fev_dat dataset contained mmrm-package: artificial (simulated) dataset clinical trial investigating effect active treatment FEV1 (forced expired volume one second), compared placebo. FEV1 measure quickly lungs can emptied low levels may indicate chronic obstructive pulmonary disease (COPD). dataset tibble 800 rows following notable variables: USUBJID (subject ID) AVISIT (visit number, factor) VISITN (visit number, numeric) ARMCD (treatment, TRT PBO) RACE (3-category race) SEX (female male) FEV1_BL (FEV1 baseline, %) FEV1 (FEV1 study visits) WEIGHT (weighting variable) primary endpoint analysis change baseline FEV1, derive denote FEV1_CHG. rest pre-processing steps create factors study arm visit apply usual checking standardization steps brms.mmrm::brm_data(). following table shows first rows dataset. Table 1. First rows pre-processed fev_dat dataset.","code":"> data(fev_data, package = \"mmrm\") > fev_data <- fev_data |> +   mutate(\"FEV1_CHG\" = FEV1 - FEV1_BL) > fev_data <- brm_data( +   data = fev_data, +   outcome = \"FEV1_CHG\", +   group = \"ARMCD\", +   time = \"AVISIT\", +   patient = \"USUBJID\", +   baseline = \"FEV1_BL\", +   reference_group = \"PBO\", +   covariates = c(\"RACE\", \"SEX\") + ) |> +   brm_data_chronologize(order = \"VISITN\") > head(fev_data) |> +   gt() |> +   tab_caption(caption = md(\"Table 1. First rows of the pre-processed `fev_dat` dataset.\"))"},{"path":"/articles/fev1.html","id":"descriptive-statistics","dir":"Articles","previous_headings":"Data","what":"Descriptive statistics","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"Table baseline characteristics: Table 2. Baseline characteristics. Table change baseline FEV1 52 weeks: Table 3. Change baseline. following figure shows primary endpoint four study visits data. Figure 1. Change baseline FEV1 4 visit time points.","code":"> fev_data |> +   select(ARMCD, USUBJID, SEX, RACE, FEV1_BL) |> +   distinct() |> +   select(-USUBJID) |> +   tbl_summary( +     by = c(ARMCD), +     statistic = list( +       all_continuous() ~ \"{mean} ({sd})\", +       all_categorical() ~ \"{n} / {N} ({p}%)\" +     ) +   ) |> +   modify_caption(\"Table 2. Baseline characteristics.\") > fev_data |> +   pull(AVISIT) |> +   unique() |> +   sort() |> +   purrr::map( +     .f = ~ fev_data |> +       filter(AVISIT %in% .x) |> +       tbl_summary( +         by = ARMCD, +         include = FEV1_CHG, +         type = FEV1_CHG ~ \"continuous2\", +         statistic = FEV1_CHG ~ c( +           \"{mean} ({sd})\", +           \"{median} ({p25}, {p75})\", +           \"{min}, {max}\" +         ), +         label = list(FEV1_CHG = paste(\"Visit \", .x)) +       ) +   ) |> +   tbl_stack(quiet = TRUE) |> +   modify_caption(\"Table 3. Change from baseline.\") > fev_data |> +   group_by(ARMCD) |> +   ggplot(aes(x = AVISIT, y = FEV1_CHG, fill = factor(ARMCD))) + +   geom_hline(yintercept = 0, col = \"grey\", linewidth = 1.2) + +   geom_boxplot(na.rm = TRUE) + +   labs( +     x = \"Visit\", +     y = \"Change from baseline in FEV1\", +     fill = \"Treatment\" +   ) + +   scale_fill_manual(values = c(\"darkgoldenrod2\", \"coral2\")) + +   theme_bw()"},{"path":[]},{"path":"/articles/fev1.html","id":"bayesian-model","dir":"Articles","previous_headings":"Fitting MMRMs","what":"Bayesian model","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"formula Bayesian model includes additive effects baseline, study visit, race, sex, study-arm--visit interaction. fit model using brms.mmrm::brm_model(). ensure good basis comparison frequentist model, put extremely diffuse prior intercept. parameters already diffuse flexible priors default. posterior summary model parameters, including fixed effects pairwise correlation among visits within patients.","code":"> b_mmrm_formula <- brm_formula( +   data = fev_data, +   intercept = TRUE, +   baseline = TRUE, +   group = FALSE, +   time = TRUE, +   baseline_time = FALSE, +   group_time = TRUE, +   correlation = \"unstructured\" + ) > print(b_mmrm_formula) #> FEV1_CHG ~ FEV1_BL + ARMCD:AVISIT + AVISIT + RACE + SEX + unstr(time = AVISIT, gr = USUBJID)  #> sigma ~ 0 + AVISIT > b_mmrm_fit <- brm_model( +   data = filter(fev_data, !is.na(FEV1_CHG)), +   formula = b_mmrm_formula, +   prior = brms::prior(class = \"Intercept\", prior = \"student_t(3, 0, 1000)\"), +   iter = 10000, +   warmup = 2000, +   chains = 4, +   cores = 4, +   seed = 1, +   refresh = 0 + ) > summary(b_mmrm_fit) #>  Family: gaussian  #>   Links: mu = identity; sigma = log  #> Formula: FEV1_CHG ~ FEV1_BL + ARMCD:AVISIT + AVISIT + RACE + SEX + unstr(time = AVISIT, gr = USUBJID)  #>          sigma ~ 0 + AVISIT #>    Data: data[!is.na(data[[attr(data, \"brm_outcome\")]]), ] (Number of observations: 537)  #>   Draws: 4 chains, each with iter = 10000; warmup = 2000; thin = 1; #>          total post-warmup draws = 32000 #>  #> Correlation Structures: #>                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS #> cortime(VIS1,VIS2)     0.36      0.08     0.18     0.52 1.00    48758    26086 #> cortime(VIS1,VIS3)     0.14      0.10    -0.05     0.33 1.00    49018    26172 #> cortime(VIS2,VIS3)     0.04      0.10    -0.16     0.23 1.00    49178    25472 #> cortime(VIS1,VIS4)     0.17      0.11    -0.06     0.38 1.00    49528    25555 #> cortime(VIS2,VIS4)     0.11      0.09    -0.07     0.28 1.00    49509    24007 #> cortime(VIS3,VIS4)     0.01      0.10    -0.18     0.21 1.00    45294    24353 #>  #> Regression Coefficients: #>                            Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS #> Intercept                     24.34      1.41    21.60    27.09 1.00    43678 #> FEV1_BL                       -0.84      0.03    -0.89    -0.78 1.00    56286 #> AVISIT2                        4.80      0.82     3.20     6.40 1.00    31792 #> AVISIT3                       10.37      0.83     8.73    12.01 1.00    29808 #> AVISIT4                       15.20      1.33    12.60    17.83 1.00    35293 #> RACEBlackorAfricanAmerican     1.41      0.59     0.27     2.55 1.00    46945 #> RACEWhite                      5.46      0.63     4.23     6.69 1.00    47801 #> SEXFemale                      0.35      0.51    -0.64     1.36 1.00    49193 #> AVISITVIS1:ARMCDTRT            3.98      1.07     1.89     6.06 1.00    31646 #> AVISITVIS2:ARMCDTRT            3.93      0.83     2.31     5.55 1.00    46665 #> AVISITVIS3:ARMCDTRT            2.98      0.68     1.65     4.31 1.00    52457 #> AVISITVIS4:ARMCDTRT            4.41      1.68     1.06     7.71 1.00    45307 #> sigma_AVISITVIS1               1.83      0.06     1.71     1.95 1.00    50344 #> sigma_AVISITVIS2               1.59      0.06     1.47     1.71 1.00    48248 #> sigma_AVISITVIS3               1.33      0.06     1.21     1.46 1.00    48058 #> sigma_AVISITVIS4               2.28      0.06     2.16     2.41 1.00    51078 #>                            Tail_ESS #> Intercept                     25394 #> FEV1_BL                       24494 #> AVISIT2                       24396 #> AVISIT3                       24188 #> AVISIT4                       24810 #> RACEBlackorAfricanAmerican    25405 #> RACEWhite                     23816 #> SEXFemale                     24919 #> AVISITVIS1:ARMCDTRT           26255 #> AVISITVIS2:ARMCDTRT           23809 #> AVISITVIS3:ARMCDTRT           24705 #> AVISITVIS4:ARMCDTRT           25026 #> sigma_AVISITVIS1              26156 #> sigma_AVISITVIS2              24526 #> sigma_AVISITVIS3              24328 #> sigma_AVISITVIS4              23975 #>  #> Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS #> and Tail_ESS are effective sample size measures, and Rhat is the potential #> scale reduction factor on split chains (at convergence, Rhat = 1)."},{"path":"/articles/fev1.html","id":"frequentist-model","dir":"Articles","previous_headings":"Fitting MMRMs","what":"Frequentist model","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"formula frequentist model , except different syntax specifying covariance structure MMRM. fit model . parameter summaries frequentist model .","code":"> f_mmrm_fit <- mmrm::mmrm( +   formula = FEV1_CHG ~ FEV1_BL + ARMCD:AVISIT + AVISIT + RACE + SEX + +     us(AVISIT | USUBJID), +   data = mutate( +     fev_data, +     AVISIT = factor(as.character(AVISIT), ordered = FALSE) +   ) + ) > summary(f_mmrm_fit) #> mmrm fit #>  #> Formula:      #> FEV1_CHG ~ FEV1_BL + ARMCD:AVISIT + AVISIT + RACE + SEX + us(AVISIT |   #>     USUBJID) #> Data:         #> mutate(fev_data, AVISIT = factor(as.character(AVISIT), ordered = FALSE)) (used  #> 537 observations from 197 subjects with maximum 4 timepoints) #> Covariance:  unstructured (10 variance parameters) #> Method:      Satterthwaite #> Vcov Method: Asymptotic #> Inference:   REML #>  #> Model selection criteria: #>      AIC      BIC   logLik deviance  #>   3381.4   3414.2  -1680.7   3361.4  #>  #> Coefficients:  #>                                Estimate Std. Error        df t value Pr(>|t|) #> (Intercept)                    24.35372    1.40754 257.97000  17.302  < 2e-16 #> FEV1_BL                        -0.84022    0.02777 190.27000 -30.251  < 2e-16 #> AVISITVIS2                      4.79036    0.79848 144.82000   5.999 1.51e-08 #> AVISITVIS3                     10.36601    0.81318 157.08000  12.748  < 2e-16 #> AVISITVIS4                     15.19231    1.30857 139.25000  11.610  < 2e-16 #> RACEBlack or African American   1.41921    0.57874 169.56000   2.452 0.015211 #> RACEWhite                       5.45679    0.61626 157.54000   8.855 1.65e-15 #> SEXFemale                       0.33812    0.49273 166.43000   0.686 0.493529 #> AVISITVIS1:ARMCDTRT             3.98329    1.04540 142.32000   3.810 0.000206 #> AVISITVIS2:ARMCDTRT             3.93076    0.81351 142.26000   4.832 3.46e-06 #> AVISITVIS3:ARMCDTRT             2.98372    0.66567 129.61000   4.482 1.61e-05 #> AVISITVIS4:ARMCDTRT             4.40400    1.66049 132.88000   2.652 0.008970 #>                                   #> (Intercept)                   *** #> FEV1_BL                       *** #> AVISITVIS2                    *** #> AVISITVIS3                    *** #> AVISITVIS4                    *** #> RACEBlack or African American *   #> RACEWhite                     *** #> SEXFemale                         #> AVISITVIS1:ARMCDTRT           *** #> AVISITVIS2:ARMCDTRT           *** #> AVISITVIS3:ARMCDTRT           *** #> AVISITVIS4:ARMCDTRT           **  #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Covariance estimate: #>         VIS1    VIS2    VIS3    VIS4 #> VIS1 37.8301 11.3255  3.4796 10.6844 #> VIS2 11.3255 23.5476  0.7760  5.5103 #> VIS3  3.4796  0.7760 13.8037  0.5683 #> VIS4 10.6844  5.5103  0.5683 92.9625"},{"path":"/articles/fev1.html","id":"comparison","dir":"Articles","previous_headings":"","what":"Comparison","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"section compares Bayesian posterior parameter estimates brms.mmrm frequentist parameter estimates mmrm package.","code":""},{"path":"/articles/fev1.html","id":"extract-estimates-from-bayesian-model","dir":"Articles","previous_headings":"Comparison","what":"Extract estimates from Bayesian model","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"extract standardize Bayesian estimates.","code":"> b_mmrm_draws <- b_mmrm_fit |> +   as_draws_df() > visit_levels <- sort(unique(as.character(fev_data$AVISIT))) > for (level in visit_levels) { +   name <- paste0(\"b_sigma_AVISIT\", level) +   b_mmrm_draws[[name]] <- exp(b_mmrm_draws[[name]]) + } > b_mmrm_summary <- b_mmrm_draws |> +   summarize_draws() |> +   select(variable, mean, sd) |> +   filter(!(variable %in% c(\"Intercept\", \"lprior\", \"lp__\"))) |> +   rename(bayes_estimate = mean, bayes_se = sd) |> +   mutate( +     variable = variable |> +       tolower() |> +       gsub(pattern = \"b_\", replacement = \"\") |> +       gsub(pattern = \"b_sigma_AVISIT\", replacement = \"sigma_\") |> +       gsub(pattern = \"cortime\", replacement = \"correlation\") |> +       gsub(pattern = \"__\", replacement = \"_\") |> +       gsub(pattern = \"avisitvis\", replacement = \"avisit\") +   )"},{"path":"/articles/fev1.html","id":"extract-estimates-from-frequentist-model","dir":"Articles","previous_headings":"Comparison","what":"Extract estimates from frequentist model","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"extract standardize frequentist estimates.","code":"> f_mmrm_fixed <- summary(f_mmrm_fit)$coefficients |> +   as_tibble(rownames = \"variable\") |> +   mutate(variable = tolower(variable)) |> +   mutate(variable = gsub(\"(\", \"\", variable, fixed = TRUE)) |> +   mutate(variable = gsub(\")\", \"\", variable, fixed = TRUE)) |> +   mutate(variable = gsub(\"avisitvis\", \"avisit\", variable)) |> +   rename(freq_estimate = Estimate, freq_se = `Std. Error`) |> +   select(variable, freq_estimate, freq_se) > f_mmrm_variance <- tibble( +   variable = paste0(\"sigma_AVISIT\", visit_levels) |> +     tolower() |> +     gsub(pattern = \"avisitvis\", replacement = \"avisit\"), +   freq_estimate = sqrt(diag(f_mmrm_fit$cov)) + ) > f_diagonal_factor <- diag(1 / sqrt(diag(f_mmrm_fit$cov))) > f_corr_matrix <- f_diagonal_factor %*% f_mmrm_fit$cov %*% f_diagonal_factor > colnames(f_corr_matrix) <- visit_levels > f_mmrm_correlation <- f_corr_matrix |> +   as.data.frame() |> +   as_tibble() |> +   mutate(x1 = visit_levels) |> +   pivot_longer( +     cols = -any_of(\"x1\"), +     names_to = \"x2\", +     values_to = \"freq_estimate\" +   ) |> +   filter( +     as.numeric(gsub(\"[^0-9]\", \"\", x1)) < as.numeric(gsub(\"[^0-9]\", \"\", x2)) +   ) |> +   mutate(variable = sprintf(\"correlation_%s_%s\", x1, x2)) |> +   select(variable, freq_estimate) > f_mmrm_summary <- bind_rows( +   f_mmrm_fixed, +   f_mmrm_variance, +   f_mmrm_correlation + ) |> +   mutate(variable = gsub(\"\\\\s+\", \"\", variable) |> tolower())"},{"path":"/articles/fev1.html","id":"Summary","dir":"Articles","previous_headings":"Comparison","what":"Summary","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"first table summarizes parameter estimates model differences estimates (Bayesian minus frequentist). second table shows standard errors estimates differences standard errors. table, “Relative” column shows relative difference (difference divided frequentist quantity). different statistical paradigms estimation procedures, especially regarding covariance parameters, realistic expect Bayesian frequentist approaches yield virtually identical results. Nevertheless, absolute relative differences table show strong agreement brms.mmrm mmrm. Table 4. Comparison parameter estimates Bayesian frequentist MMRMs. Table 5. Comparison parameter standard errors Bayesian frequentist MMRMs.","code":"> b_f_comparison <- full_join( +   x = b_mmrm_summary, +   y = f_mmrm_summary, +   by = \"variable\" + ) |> +   mutate( +     diff_estimate = bayes_estimate - freq_estimate, +     diff_relative_estimate = diff_estimate / freq_estimate, +     diff_se = bayes_se - freq_se, +     diff_relative_se = diff_se / freq_se +   ) |> +   select(variable, ends_with(\"estimate\"), ends_with(\"se\")) > table_estimates <- b_f_comparison |> +   select(variable, ends_with(\"estimate\")) > gt(table_estimates) |> +   fmt_number(decimals = 4) |> +   tab_caption( +     caption = md( +       paste( +         \"Table 4. Comparison of parameter estimates between\", +         \"Bayesian and frequentist MMRMs.\" +       ) +     ) +   ) |> +   cols_label( +     variable = \"Variable\", +     bayes_estimate = \"Bayesian\", +     freq_estimate = \"Frequentist\", +     diff_estimate = \"Difference\", +     diff_relative_estimate = \"Relative\" +   ) > table_se <- b_f_comparison |> +   select(variable, ends_with(\"se\")) |> +   filter(!is.na(freq_se)) > gt(table_se) |> +   fmt_number(decimals = 4) |> +   tab_caption( +     caption = md( +       paste( +         \"Table 5. Comparison of parameter standard errors between\", +         \"Bayesian and frequentist MMRMs.\" +       ) +     ) +   ) |> +   cols_label( +     variable = \"Variable\", +     bayes_se = \"Bayesian\", +     freq_se = \"Frequentist\", +     diff_se = \"Difference\", +     diff_relative_se = \"Relative\" +   )"},{"path":"/articles/fev1.html","id":"session","dir":"Articles","previous_headings":"","what":"Session info","title":"FEV1 data comparison between Bayesian and frequentist MMRMs","text":"","code":"> sessionInfo() #> R version 4.4.0 (2024-04-24) #> Platform: aarch64-apple-darwin20 #> Running under: macOS Sonoma 14.5 #>  #> Matrix products: default #> BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib  #> LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0 #>  #> locale: #> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #>  #> time zone: America/Indiana/Indianapolis #> tzcode source: internal #>  #> attached base packages: #> [1] parallel  stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] posterior_1.5.0      mmrm_0.3.11          brms.mmrm_1.0.1.9005 #>  [4] purrr_1.0.2          gtsummary_1.9.9.9003 gt_0.10.1            #>  [7] ggplot2_3.5.1        tidyr_1.3.1          dplyr_1.1.4          #> [10] knitr_1.46           #>  #> loaded via a namespace (and not attached): #>  [1] tidyselect_1.2.1     svUnit_1.0.6         farver_2.1.2         #>  [4] loo_2.7.0            tidybayes_3.0.6      fastmap_1.2.0        #>  [7] TH.data_1.1-2        tensorA_0.36.2.1     digest_0.6.35        #> [10] estimability_1.5     lifecycle_1.0.4      StanHeaders_2.32.8   #> [13] processx_3.8.4       survival_3.5-8       magrittr_2.0.3       #> [16] compiler_4.4.0       rlang_1.1.4          sass_0.4.9           #> [19] tools_4.4.0          utf8_1.2.4           labeling_0.4.3       #> [22] bridgesampling_1.1-2 pkgbuild_1.4.4       curl_5.2.1           #> [25] plyr_1.8.9           xml2_1.3.6           abind_1.4-5          #> [28] multcomp_1.4-25      withr_3.0.0          grid_4.4.0           #> [31] stats4_4.4.0         fansi_1.0.6          xtable_1.8-4         #> [34] colorspace_2.1-0     inline_0.3.19        emmeans_1.10.1       #> [37] scales_1.3.0         gtools_3.9.5         MASS_7.3-60.2        #> [40] ggridges_0.5.6       cli_3.6.2            mvtnorm_1.2-4        #> [43] generics_0.1.3       RcppParallel_5.1.7   binom_1.1-1.1        #> [46] reshape2_1.4.4       commonmark_1.9.1     rstan_2.32.6         #> [49] stringr_1.5.1        splines_4.4.0        bayesplot_1.11.1     #> [52] matrixStats_1.3.0    brms_2.21.0          vctrs_0.6.5          #> [55] V8_4.4.2             Matrix_1.7-0         sandwich_3.1-0       #> [58] jsonlite_1.8.8       callr_3.7.6          arrayhelpers_1.1-0   #> [61] ggdist_3.3.2         glue_1.7.0           ps_1.7.6             #> [64] codetools_0.2-20     distributional_0.4.0 stringi_1.8.4        #> [67] gtable_0.3.5         QuickJSR_1.1.3       munsell_0.5.1        #> [70] tibble_3.2.1         pillar_1.9.0         htmltools_0.5.8.1    #> [73] Brobdingnag_1.2-9    TMB_1.9.11           R6_2.5.1             #> [76] Rdpack_2.6           evaluate_0.23        lattice_0.22-6       #> [79] highr_0.10           markdown_1.12        cards_0.1.0.9046     #> [82] rbibutils_2.2.16     backports_1.4.1      trialr_0.1.6         #> [85] rstantools_2.4.0     Rcpp_1.0.12          coda_0.19-4.1        #> [88] gridExtra_2.3        nlme_3.1-164         checkmate_2.3.1      #> [91] xfun_0.43            zoo_1.8-12           pkgconfig_2.0.3"},{"path":"/articles/inference.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example data","title":"Inference","text":"Throughout vignette, use mmrm package’s fev_data dataset, simulation clinical trial chronic obstructive pulmonary disease (COPD) patients (variable USUBJID) randomized different treatment groups (variable ARMCD) measured across four discrete time points (variable AVISIT). given response variable forced expired volume one second (FEV1), interested FEV1 change baseline time point (derived variable FEV_CHG). vignette, impute missing responses order simplify discussion.","code":"library(brms.mmrm) library(dplyr) library(tidyr) data(fev_data, package = \"mmrm\") data <- fev_data |>   group_by(USUBJID) |>   complete(AVISIT) |>   arrange(AVISIT) |>   fill(     any_of(c(\"ARMCD\", \"FEV1_BL\", \"RACE\", \"SEX\", \"WEIGHT\")),     .direction = \"downup\"   ) |>   mutate(FEV1 = na.locf(FEV1, na.rm = FALSE)) |>   mutate(FEV1 = na.locf(FEV1, na.rm = FALSE, fromLast = TRUE)) |>   ungroup() |>   filter(!is.na(FEV1)) |>   mutate(FEV1_CHG = FEV1 - FEV1_BL, USUBJID = as.character(USUBJID)) |>   select(-FEV1) |>   as_tibble() |>   arrange(USUBJID, AVISIT) |>   brm_data(     outcome = \"FEV1_CHG\",     baseline = \"FEV1_BL\",     group = \"ARMCD\",     patient = \"USUBJID\",     time = \"AVISIT\",     covariates = c(\"RACE\", \"SEX\", \"WEIGHT\"),     reference_group = \"PBO\",     reference_time = \"VIS1\"   ) data #> # A tibble: 788 × 10 #>    USUBJID AVISIT ARMCD RACE        SEX   FEV1_BL WEIGHT VISITN VISITN2 FEV1_CHG #>    <chr>   <fct>  <fct> <fct>       <fct>   <dbl>  <dbl>  <int>   <dbl>    <dbl> #>  1 PT10    VIS1   PBO   Black or A… Fema…    57.7  0.795      1 -0.394    -12.7  #>  2 PT10    VIS2   PBO   Black or A… Fema…    57.7  0.823      2 -0.0593   -12.7  #>  3 PT10    VIS3   PBO   Black or A… Fema…    57.7  0.594      3  1.10     -12.7  #>  4 PT10    VIS4   PBO   Black or A… Fema…    57.7  0.207      4  0.763    -12.7  #>  5 PT100   VIS1   PBO   Black or A… Fema…    51.8  0.362      1  1.59     -17.2  #>  6 PT100   VIS2   PBO   Black or A… Fema…    51.8  0.404      2  0.0450   -12.5  #>  7 PT100   VIS3   PBO   Black or A… Fema…    51.8  0.504      3 -0.715    -11.2  #>  8 PT100   VIS4   PBO   Black or A… Fema…    51.8  0.201      4  0.865    -11.2  #>  9 PT102   VIS1   PBO   Asian       Fema…    52.2  0.577      1 -0.416    -16.6  #> 10 PT102   VIS2   PBO   Asian       Fema…    52.2  0.227      2 -0.376     -8.48 #> # ℹ 778 more rows"},{"path":"/articles/inference.html","id":"marginal-means-for-clinical-trials","dir":"Articles","previous_headings":"","what":"Marginal means for clinical trials","title":"Inference","text":"According Lenth (2016), marginal means (formerly “least-squares means”) predictions (usually averaged predictions) point reference grid. reference grid declares combinations levels factors interest. clinical trial repeated measures, often interested mean response combination treatment group discrete time point. FEV1 dataset, interested mean FEV1_CHG standard error combination treatment group time point.1 words, want estimate mean FEV1_CHG group \"TRT\" time \"VIS1\", mean FEV1_CHG group \"TRT\" time \"VIS2\", .2 represent goals reference one row per marginal mean interest columns levels factors interest. seldom trivial estimate marginal means. example, following parameterization includes intercept term, additive terms level factor, interactions capture non-additive relationships among factors, continuous covariates, different FEV1_BL slopes different time points. , model coefficient directly corresponds marginal mean interest. Even terms like AVISITVIS2:ARMCDTRT implicitly condition subset data variables involved. accomplish goals, need carefully construct linear transformation maps model coefficients marginal means interest. transformation evaluate contrasts interesting parameters average uninteresting parameters.","code":"reference_grid <- distinct(data, ARMCD, AVISIT) reference_grid #> # A tibble: 8 × 2 #>   ARMCD AVISIT #>   <fct> <fct>  #> 1 PBO   VIS1   #> 2 PBO   VIS2   #> 3 PBO   VIS3   #> 4 PBO   VIS4   #> 5 TRT   VIS1   #> 6 TRT   VIS2   #> 7 TRT   VIS3   #> 8 TRT   VIS4 brms_mmrm_formula <- brm_formula(data, correlation = \"diagonal\") base_formula <- as.formula(brms_mmrm_formula[[1]]) attr(base_formula, \"nl\") <- NULL attr(base_formula, \"loop\") <- NULL base_formula #> FEV1_CHG ~ FEV1_BL + FEV1_BL:AVISIT + ARMCD + ARMCD:AVISIT +  #>     AVISIT + RACE + SEX + WEIGHT #> attr(,\"center\") #> [1] TRUE #> <environment: 0x55e18607a858> colnames(model.matrix(object = base_formula, data = data)) #>  [1] \"(Intercept)\"                   \"FEV1_BL\"                       #>  [3] \"ARMCDTRT\"                      \"AVISITVIS2\"                    #>  [5] \"AVISITVIS3\"                    \"AVISITVIS4\"                    #>  [7] \"RACEBlack or African American\" \"RACEWhite\"                     #>  [9] \"SEXFemale\"                     \"WEIGHT\"                        #> [11] \"FEV1_BL:AVISITVIS2\"            \"FEV1_BL:AVISITVIS3\"            #> [13] \"FEV1_BL:AVISITVIS4\"            \"AVISITVIS2:ARMCDTRT\"           #> [15] \"AVISITVIS3:ARMCDTRT\"           \"AVISITVIS4:ARMCDTRT\""},{"path":"/articles/inference.html","id":"existing-capabilities","dir":"Articles","previous_headings":"","what":"Existing capabilities","title":"Inference","text":"brms.mmrm::brm_model() returns fitted brms model, brms already tools posterior inference. combination native functions S3 methods, brms integrates posterior loo, also emmeans estimation marginal means downstream contrasts. Despite existing features brms, brms.mmrm implements custom code transform model coefficients marginal means. reference grids emmeans can condition factors explicitly declared model formula supplied brms, whereas brms.mmrm needs flexibility order support informative prior archetypes (Bedrick et al. (1996), Bedrick et al. (1997), Christensen et al. (2010), Rosner et al. (2021)).","code":""},{"path":"/articles/inference.html","id":"how-brms-mmrm-estimates-marginal-means","dir":"Articles","previous_headings":"","what":"How brms.mmrm estimates marginal means","title":"Inference","text":"estimate marginal means, brms.mmrm::brm_transform_marginal() creates special matrix. special matrix encodes equations map model coefficients marginal means.3 Multiplying matrix set model coefficients plugging coefficients equations . produce estimates marginal means. technique similar emmeans::emmeans(weights = \"proportional\")4 (Lenth (2016), Searle et al. (1980)) produces similar estimates. Bayesian MMRMs brms.mmrm, transformation brm_transform_marginal() operates individual draw joint posterior distribution. transformation matrix produced brm_transform_marginal() value transform argument brm_marginal_draws(). way, brm_marginal_draws() produces entire estimated posterior marginal mean, rather point estimates assume normal Student-t distribution.5","code":"transform <- brm_transform_marginal(data = data, formula = brms_mmrm_formula) dim(transform) #> [1]  8 16 transform[, 1:4] #>          b_Intercept b_FEV1_BL b_ARMCDTRT b_AVISITVIS2 #> PBO|VIS1           1  40.12532          0            0 #> PBO|VIS2           1  40.12532          0            1 #> PBO|VIS3           1  40.12532          0            0 #> PBO|VIS4           1  40.12532          0            0 #> TRT|VIS1           1  40.12532          1            0 #> TRT|VIS2           1  40.12532          1            1 #> TRT|VIS3           1  40.12532          1            0 #> TRT|VIS4           1  40.12532          1            0 summary(transform) #> # This is a matrix to transform model parameters to marginal means. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = b_Intercept + 40.13*b_FEV1_BL + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT #> #   PBO:VIS2 = b_Intercept + 40.13*b_FEV1_BL + b_AVISITVIS2 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS2 #> #   PBO:VIS3 = b_Intercept + 40.13*b_FEV1_BL + b_AVISITVIS3 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS3 #> #   PBO:VIS4 = b_Intercept + 40.13*b_FEV1_BL + b_AVISITVIS4 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS4 #> #   TRT:VIS1 = b_Intercept + 40.13*b_FEV1_BL + b_ARMCDTRT + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT #> #   TRT:VIS2 = b_Intercept + 40.13*b_FEV1_BL + b_ARMCDTRT + b_AVISITVIS2 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS2 + b_ARMCDTRT:AVISITVIS2 #> #   TRT:VIS3 = b_Intercept + 40.13*b_FEV1_BL + b_ARMCDTRT + b_AVISITVIS3 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS3 + b_ARMCDTRT:AVISITVIS3 #> #   TRT:VIS4 = b_Intercept + 40.13*b_FEV1_BL + b_ARMCDTRT + b_AVISITVIS4 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS4 + b_ARMCDTRT:AVISITVIS4 model <- lm(formula = base_formula, data = data) marginals_custom <- transform %*% coef(model) marginals_custom #>                [,1] #> PBO|VIS1 -4.5998295 #> PBO|VIS2 -2.5445943 #> PBO|VIS3  0.9841880 #> PBO|VIS4  5.6013241 #> TRT|VIS1 -1.2858526 #> TRT|VIS2  0.8466639 #> TRT|VIS3  3.8011416 #> TRT|VIS4 10.0521521 library(emmeans) #> Welcome to emmeans. #> Caution: You lose important information if you filter this package's results. #> See '? untidy' marginals_emmeans <- emmeans(   object = model,   specs = ~ARMCD:AVISIT,   weights = \"proportional\",   nuisance = c(\"USUBJID\", \"RACE\", \"SEX\") ) |>   as.data.frame() |>   as_tibble() |>   select(ARMCD, AVISIT, emmean) |>   arrange(ARMCD, AVISIT) marginals_emmeans #> # A tibble: 8 × 3 #>   ARMCD AVISIT emmean #>   <fct> <fct>   <dbl> #> 1 PBO   VIS1   -4.60  #> 2 PBO   VIS2   -2.54  #> 3 PBO   VIS3    0.984 #> 4 PBO   VIS4    5.60  #> 5 TRT   VIS1   -1.29  #> 6 TRT   VIS2    0.847 #> 7 TRT   VIS3    3.80  #> 8 TRT   VIS4   10.1 marginals_custom - marginals_emmeans$emmean #>                   [,1] #> PBO|VIS1  0.000000e+00 #> PBO|VIS2  4.440892e-16 #> PBO|VIS3 -1.110223e-16 #> PBO|VIS4 -8.881784e-16 #> TRT|VIS1 -1.110223e-15 #> TRT|VIS2 -5.551115e-16 #> TRT|VIS3 -1.332268e-15 #> TRT|VIS4 -1.776357e-15"},{"path":"/articles/inference.html","id":"how-brm_marginal_draws-works","dir":"Articles","previous_headings":"","what":"How brm_marginal_draws() works","title":"Inference","text":"Let us take closer look equations map model parameters marginal means. equations include terms fixed effects interest, also nuisance variables FEV1_BL, SEX, RACE, WEIGHT. nuisance variables originally part model formula, means marginal mean can interpreted relative fixed value FEV1_BL, fixed proportion female patients, etc. example, dropped 40.13*b_FEV1_BL, PBO:VIS1 placebo mean visit 1 patients FEV1_BL = 0: words, patients breathe air lungs beginning study. Similarly, dropped 0.53*b_SEXFemale, interpret PBO:VIS1 visit 1 placebo mean male patients . Fixed values 40.13 0.53 averages data ensure marginal means apply entire patient population whole. major challenge brm_transform_marginal() condition nuisance values represent appropriate averages data. calculate nuisance values, brm_transform_marginal() uses technique similar weights = \"proportional\" emmeans::emmeans(). replicate brm_transform_marginal(), first create reference grid define factor levels interest means continuous variables condition . use grid construct model matrix desired interactions continuous variables factors interest. column represents model coefficient, row represents marginal mean interest. want predict “average” SEX RACE across data. Since SEX RACE factors, simply take means variables . Rather, construct model matrix turn factor level dummy variable, average dummy variables across entire dataset. process accounts observed frequencies levels data (ideal passive variables experiment directly control), guarding hidden confounding factors interest (can lead Simpson’s paradox).6 Finally, use transformation matrix map estimated model coefficients estimated marginal means. results extremely close estimated marginal means emmeans. brms.mmrm follows procedure , Bayesian context. brm_transform_marginal() creates matrix , brm_marginal_draws() uses transform posterior draws brms model coefficients posterior draws marginal means. posterior draws marginal means support estimation treatment effects (via brm_marginal_draws() brm_marginal_summaries()) posterior probabilities treatment effects (via brm_marginal_probabilities()). fine-tune marginal mean estimation procedure niche use cases, can modify transformation returned brm_transform_marginal() supply transform argument brm_marginal_draws().","code":"summary(transform) #> # This is a matrix to transform model parameters to marginal means. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   PBO:VIS1 = b_Intercept + 40.13*b_FEV1_BL + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT #> #   PBO:VIS2 = b_Intercept + 40.13*b_FEV1_BL + b_AVISITVIS2 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS2 #> #   PBO:VIS3 = b_Intercept + 40.13*b_FEV1_BL + b_AVISITVIS3 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS3 #> #   PBO:VIS4 = b_Intercept + 40.13*b_FEV1_BL + b_AVISITVIS4 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS4 #> #   TRT:VIS1 = b_Intercept + 40.13*b_FEV1_BL + b_ARMCDTRT + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT #> #   TRT:VIS2 = b_Intercept + 40.13*b_FEV1_BL + b_ARMCDTRT + b_AVISITVIS2 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS2 + b_ARMCDTRT:AVISITVIS2 #> #   TRT:VIS3 = b_Intercept + 40.13*b_FEV1_BL + b_ARMCDTRT + b_AVISITVIS3 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS3 + b_ARMCDTRT:AVISITVIS3 #> #   TRT:VIS4 = b_Intercept + 40.13*b_FEV1_BL + b_ARMCDTRT + b_AVISITVIS4 + 0.38*b_RACEBlackorAfricanAmerican + 0.27*b_RACEWhite + 0.53*b_SEXFemale + 0.52*b_WEIGHT + 40.13*b_FEV1_BL:AVISITVIS4 + b_ARMCDTRT:AVISITVIS4 grid <- data |>   mutate(FEV1_BL = mean(FEV1_BL), WEIGHT = mean(WEIGHT)) |>   distinct(ARMCD, AVISIT, FEV1_BL, WEIGHT) |>   arrange(ARMCD, AVISIT) grid #> # A tibble: 8 × 4 #>   ARMCD AVISIT FEV1_BL WEIGHT #>   <fct> <fct>    <dbl>  <dbl> #> 1 PBO   VIS1      40.1  0.519 #> 2 PBO   VIS2      40.1  0.519 #> 3 PBO   VIS3      40.1  0.519 #> 4 PBO   VIS4      40.1  0.519 #> 5 TRT   VIS1      40.1  0.519 #> 6 TRT   VIS2      40.1  0.519 #> 7 TRT   VIS3      40.1  0.519 #> 8 TRT   VIS4      40.1  0.519 transform <- model.matrix(   object = ~ FEV1_BL * AVISIT + ARMCD * AVISIT + WEIGHT,   data = grid ) rownames(transform) <- paste(grid$ARMCD, grid$AVISIT) transform #>          (Intercept)  FEV1_BL AVISITVIS2 AVISITVIS3 AVISITVIS4 ARMCDTRT #> PBO VIS1           1 40.12532          0          0          0        0 #> PBO VIS2           1 40.12532          1          0          0        0 #> PBO VIS3           1 40.12532          0          1          0        0 #> PBO VIS4           1 40.12532          0          0          1        0 #> TRT VIS1           1 40.12532          0          0          0        1 #> TRT VIS2           1 40.12532          1          0          0        1 #> TRT VIS3           1 40.12532          0          1          0        1 #> TRT VIS4           1 40.12532          0          0          1        1 #>             WEIGHT FEV1_BL:AVISITVIS2 FEV1_BL:AVISITVIS3 FEV1_BL:AVISITVIS4 #> PBO VIS1 0.5185461            0.00000            0.00000            0.00000 #> PBO VIS2 0.5185461           40.12532            0.00000            0.00000 #> PBO VIS3 0.5185461            0.00000           40.12532            0.00000 #> PBO VIS4 0.5185461            0.00000            0.00000           40.12532 #> TRT VIS1 0.5185461            0.00000            0.00000            0.00000 #> TRT VIS2 0.5185461           40.12532            0.00000            0.00000 #> TRT VIS3 0.5185461            0.00000           40.12532            0.00000 #> TRT VIS4 0.5185461            0.00000            0.00000           40.12532 #>          AVISITVIS2:ARMCDTRT AVISITVIS3:ARMCDTRT AVISITVIS4:ARMCDTRT #> PBO VIS1                   0                   0                   0 #> PBO VIS2                   0                   0                   0 #> PBO VIS3                   0                   0                   0 #> PBO VIS4                   0                   0                   0 #> TRT VIS1                   0                   0                   0 #> TRT VIS2                   1                   0                   0 #> TRT VIS3                   0                   1                   0 #> TRT VIS4                   0                   0                   1 #> attr(,\"assign\") #>  [1] 0 1 2 2 2 3 4 5 5 5 6 6 6 #> attr(,\"contrasts\") #> attr(,\"contrasts\")$AVISIT #> [1] \"contr.treatment\" #>  #> attr(,\"contrasts\")$ARMCD #> [1] \"contr.treatment\" proportional_factors <- data |>   model.matrix(object = ~ 0 + SEX + RACE) |>   colMeans() |>   t() proportional_factors #>        SEXMale SEXFemale RACEBlack or African American RACEWhite #> [1,] 0.4670051 0.5329949                     0.3756345 0.2690355 transform <- transform |>   bind_cols(proportional_factors) |>   as.matrix() transform <- transform[, names(coef(model))] rownames(transform) <- paste(grid$ARMCD, grid$AVISIT) transform #>          (Intercept)  FEV1_BL ARMCDTRT AVISITVIS2 AVISITVIS3 AVISITVIS4 #> PBO VIS1           1 40.12532        0          0          0          0 #> PBO VIS2           1 40.12532        0          1          0          0 #> PBO VIS3           1 40.12532        0          0          1          0 #> PBO VIS4           1 40.12532        0          0          0          1 #> TRT VIS1           1 40.12532        1          0          0          0 #> TRT VIS2           1 40.12532        1          1          0          0 #> TRT VIS3           1 40.12532        1          0          1          0 #> TRT VIS4           1 40.12532        1          0          0          1 #>          RACEBlack or African American RACEWhite SEXFemale    WEIGHT #> PBO VIS1                     0.3756345 0.2690355 0.5329949 0.5185461 #> PBO VIS2                     0.3756345 0.2690355 0.5329949 0.5185461 #> PBO VIS3                     0.3756345 0.2690355 0.5329949 0.5185461 #> PBO VIS4                     0.3756345 0.2690355 0.5329949 0.5185461 #> TRT VIS1                     0.3756345 0.2690355 0.5329949 0.5185461 #> TRT VIS2                     0.3756345 0.2690355 0.5329949 0.5185461 #> TRT VIS3                     0.3756345 0.2690355 0.5329949 0.5185461 #> TRT VIS4                     0.3756345 0.2690355 0.5329949 0.5185461 #>          FEV1_BL:AVISITVIS2 FEV1_BL:AVISITVIS3 FEV1_BL:AVISITVIS4 #> PBO VIS1            0.00000            0.00000            0.00000 #> PBO VIS2           40.12532            0.00000            0.00000 #> PBO VIS3            0.00000           40.12532            0.00000 #> PBO VIS4            0.00000            0.00000           40.12532 #> TRT VIS1            0.00000            0.00000            0.00000 #> TRT VIS2           40.12532            0.00000            0.00000 #> TRT VIS3            0.00000           40.12532            0.00000 #> TRT VIS4            0.00000            0.00000           40.12532 #>          AVISITVIS2:ARMCDTRT AVISITVIS3:ARMCDTRT AVISITVIS4:ARMCDTRT #> PBO VIS1                   0                   0                   0 #> PBO VIS2                   0                   0                   0 #> PBO VIS3                   0                   0                   0 #> PBO VIS4                   0                   0                   0 #> TRT VIS1                   0                   0                   0 #> TRT VIS2                   1                   0                   0 #> TRT VIS3                   0                   1                   0 #> TRT VIS4                   0                   0                   1 marginals_custom <- transform %*% coef(model) marginals_custom #>                [,1] #> PBO VIS1 -4.5998295 #> PBO VIS2 -2.5445943 #> PBO VIS3  0.9841880 #> PBO VIS4  5.6013241 #> TRT VIS1 -1.2858526 #> TRT VIS2  0.8466639 #> TRT VIS3  3.8011416 #> TRT VIS4 10.0521521 marginals_emmeans |>   bind_cols(custom = as.numeric(marginals_custom)) |>   mutate(difference = custom - emmean) #> # A tibble: 8 × 5 #>   ARMCD AVISIT emmean custom difference #>   <fct> <fct>   <dbl>  <dbl>      <dbl> #> 1 PBO   VIS1   -4.60  -4.60    0        #> 2 PBO   VIS2   -2.54  -2.54    4.44e-16 #> 3 PBO   VIS3    0.984  0.984  -1.11e-16 #> 4 PBO   VIS4    5.60   5.60   -8.88e-16 #> 5 TRT   VIS1   -1.29  -1.29   -1.11e-15 #> 6 TRT   VIS2    0.847  0.847  -5.55e-16 #> 7 TRT   VIS3    3.80   3.80   -1.33e-15 #> 8 TRT   VIS4   10.1   10.1    -1.78e-15"},{"path":"/articles/inference.html","id":"subgroup-analysis","dir":"Articles","previous_headings":"","what":"Subgroup analysis","title":"Inference","text":"Subgroup analysis raises important questions nuisance variables averaged, user responsible choosing approach best suits situation. illustrate, suppose SEX pre-specified subgroup. estimating marginal means, now wish condition \"Female\" vs \"Male\" averaging RACE across whole dataset. emmeans, similar calculated marginals_emmeans , now move SEX nuisance specs: may reasonable cases, mitigates kind hidden confounding subgroup variables may otherwise cause Simpson’s paradox. However, subgroup-specific marginal means, may realistic condition single point estimate levels reference grid. example, model regress pregnancy variable, marginal means SEX = \"Male\" always condition pregnancy = 0 instead mean(data$pregnancy). general, may reasonable condition subgroup-specific averages nuisance variables. However, , responsibility investigate understand hidden interactions confounding dataset. https://cran.r-project.org/package=emmeans/vignettes/interactions.html edifying vignette topic. opt subgroup-specific averages nuisance variables brms.mmrm, set average_within_subgroup = TRUE brm_transform_marginal(), supply output transform argument brm_marginal_draws(). replicate brm_transform_marginal(average_within_subgroup = TRUE) scratch, first create reference grid includes subgroup levels. continuous variable, append corresponding subgroup-specific averages grid. Begin creating variable transformation matrix using new grid. sure include subgroup formula exactly appears formula used fit model. Append subgroup-specific averages levels nuisance factors (case, just RACE). Complete transformation matrix assigning correct row names aligning column order model coefficients. Finally, use custom transform matrix estimate subgroup-specific marginal means. averaged FEV1_BL, WEIGHT, RACE within subgroup levels, results differ emmeans.","code":"emmeans(   object = model,   specs = ~SEX:ARMCD:AVISIT,   weights = \"proportional\",   nuisance = c(\"USUBJID\", \"RACE\") ) #>  SEX    ARMCD AVISIT emmean    SE  df lower.CL upper.CL #>  Male   PBO   VIS1   -5.014 0.752 772   -6.490   -3.538 #>  Female PBO   VIS1   -4.237 0.743 772   -5.696   -2.778 #>  Male   TRT   VIS1   -1.700 0.800 772   -3.270   -0.130 #>  Female TRT   VIS1   -0.923 0.786 772   -2.466    0.620 #>  Male   PBO   VIS2   -2.959 0.752 772   -4.435   -1.482 #>  Female PBO   VIS2   -2.182 0.743 772   -3.640   -0.723 #>  Male   TRT   VIS2    0.433 0.800 772   -1.137    2.003 #>  Female TRT   VIS2    1.209 0.786 772   -0.333    2.752 #>  Male   PBO   VIS3    0.570 0.752 772   -0.906    2.046 #>  Female PBO   VIS3    1.347 0.743 772   -0.112    2.806 #>  Male   TRT   VIS3    3.387 0.800 772    1.816    4.958 #>  Female TRT   VIS3    4.164 0.786 772    2.621    5.707 #>  Male   PBO   VIS4    5.187 0.752 772    3.712    6.663 #>  Female PBO   VIS4    5.964 0.743 772    4.506    7.422 #>  Male   TRT   VIS4    9.638 0.800 772    8.067   11.209 #>  Female TRT   VIS4   10.415 0.786 772    8.872   11.958 #>  #> Results are averaged over the levels of: 1 nuisance factors  #> Confidence level used: 0.95 grid <- data |>   distinct(ARMCD, SEX, AVISIT) |>   arrange(ARMCD, SEX, AVISIT) grid #> # A tibble: 16 × 3 #>    ARMCD SEX    AVISIT #>    <fct> <fct>  <fct>  #>  1 PBO   Male   VIS1   #>  2 PBO   Male   VIS2   #>  3 PBO   Male   VIS3   #>  4 PBO   Male   VIS4   #>  5 PBO   Female VIS1   #>  6 PBO   Female VIS2   #>  7 PBO   Female VIS3   #>  8 PBO   Female VIS4   #>  9 TRT   Male   VIS1   #> 10 TRT   Male   VIS2   #> 11 TRT   Male   VIS3   #> 12 TRT   Male   VIS4   #> 13 TRT   Female VIS1   #> 14 TRT   Female VIS2   #> 15 TRT   Female VIS3   #> 16 TRT   Female VIS4 means <- data |>   group_by(SEX) |>   summarize(FEV1_BL = mean(FEV1_BL), WEIGHT = mean(WEIGHT), .groups = \"drop\") grid <- left_join(x = grid, y = means, by = \"SEX\") grid #> # A tibble: 16 × 5 #>    ARMCD SEX    AVISIT FEV1_BL WEIGHT #>    <fct> <fct>  <fct>    <dbl>  <dbl> #>  1 PBO   Male   VIS1      40.3  0.516 #>  2 PBO   Male   VIS2      40.3  0.516 #>  3 PBO   Male   VIS3      40.3  0.516 #>  4 PBO   Male   VIS4      40.3  0.516 #>  5 PBO   Female VIS1      39.9  0.521 #>  6 PBO   Female VIS2      39.9  0.521 #>  7 PBO   Female VIS3      39.9  0.521 #>  8 PBO   Female VIS4      39.9  0.521 #>  9 TRT   Male   VIS1      40.3  0.516 #> 10 TRT   Male   VIS2      40.3  0.516 #> 11 TRT   Male   VIS3      40.3  0.516 #> 12 TRT   Male   VIS4      40.3  0.516 #> 13 TRT   Female VIS1      39.9  0.521 #> 14 TRT   Female VIS2      39.9  0.521 #> 15 TRT   Female VIS3      39.9  0.521 #> 16 TRT   Female VIS4      39.9  0.521 transform <- model.matrix(   object = ~ FEV1_BL * AVISIT + ARMCD * AVISIT + SEX + WEIGHT,   data = grid ) proportions <- data |>   model.matrix(object = ~ 0 + RACE) |>   as.data.frame() |>   mutate(SEX = data$SEX) |>   group_by(SEX) |>   summarize(across(everything(), mean), .groups = \"drop\") transform <- transform |>   as.data.frame() |>   mutate(SEX = grid$SEX) |>   left_join(y = proportions, by = \"SEX\") |>   select(-SEX) |>   as.matrix() rownames(transform) <- paste(grid$ARMCD, grid$SEX, grid$AVISIT) transform <- transform[, names(coef(model))] transform #>                 (Intercept)  FEV1_BL ARMCDTRT AVISITVIS2 AVISITVIS3 AVISITVIS4 #> PBO Male VIS1             1 40.34215        0          0          0          0 #> PBO Male VIS2             1 40.34215        0          1          0          0 #> PBO Male VIS3             1 40.34215        0          0          1          0 #> PBO Male VIS4             1 40.34215        0          0          0          1 #> PBO Female VIS1           1 39.93534        0          0          0          0 #> PBO Female VIS2           1 39.93534        0          1          0          0 #> PBO Female VIS3           1 39.93534        0          0          1          0 #> PBO Female VIS4           1 39.93534        0          0          0          1 #> TRT Male VIS1             1 40.34215        1          0          0          0 #> TRT Male VIS2             1 40.34215        1          1          0          0 #> TRT Male VIS3             1 40.34215        1          0          1          0 #> TRT Male VIS4             1 40.34215        1          0          0          1 #> TRT Female VIS1           1 39.93534        1          0          0          0 #> TRT Female VIS2           1 39.93534        1          1          0          0 #> TRT Female VIS3           1 39.93534        1          0          1          0 #> TRT Female VIS4           1 39.93534        1          0          0          1 #>                 RACEBlack or African American RACEWhite SEXFemale    WEIGHT #> PBO Male VIS1                       0.4239130 0.2826087         0 0.5161276 #> PBO Male VIS2                       0.4239130 0.2826087         0 0.5161276 #> PBO Male VIS3                       0.4239130 0.2826087         0 0.5161276 #> PBO Male VIS4                       0.4239130 0.2826087         0 0.5161276 #> PBO Female VIS1                     0.3333333 0.2571429         1 0.5206653 #> PBO Female VIS2                     0.3333333 0.2571429         1 0.5206653 #> PBO Female VIS3                     0.3333333 0.2571429         1 0.5206653 #> PBO Female VIS4                     0.3333333 0.2571429         1 0.5206653 #> TRT Male VIS1                       0.4239130 0.2826087         0 0.5161276 #> TRT Male VIS2                       0.4239130 0.2826087         0 0.5161276 #> TRT Male VIS3                       0.4239130 0.2826087         0 0.5161276 #> TRT Male VIS4                       0.4239130 0.2826087         0 0.5161276 #> TRT Female VIS1                     0.3333333 0.2571429         1 0.5206653 #> TRT Female VIS2                     0.3333333 0.2571429         1 0.5206653 #> TRT Female VIS3                     0.3333333 0.2571429         1 0.5206653 #> TRT Female VIS4                     0.3333333 0.2571429         1 0.5206653 #>                 FEV1_BL:AVISITVIS2 FEV1_BL:AVISITVIS3 FEV1_BL:AVISITVIS4 #> PBO Male VIS1              0.00000            0.00000            0.00000 #> PBO Male VIS2             40.34215            0.00000            0.00000 #> PBO Male VIS3              0.00000           40.34215            0.00000 #> PBO Male VIS4              0.00000            0.00000           40.34215 #> PBO Female VIS1            0.00000            0.00000            0.00000 #> PBO Female VIS2           39.93534            0.00000            0.00000 #> PBO Female VIS3            0.00000           39.93534            0.00000 #> PBO Female VIS4            0.00000            0.00000           39.93534 #> TRT Male VIS1              0.00000            0.00000            0.00000 #> TRT Male VIS2             40.34215            0.00000            0.00000 #> TRT Male VIS3              0.00000           40.34215            0.00000 #> TRT Male VIS4              0.00000            0.00000           40.34215 #> TRT Female VIS1            0.00000            0.00000            0.00000 #> TRT Female VIS2           39.93534            0.00000            0.00000 #> TRT Female VIS3            0.00000           39.93534            0.00000 #> TRT Female VIS4            0.00000            0.00000           39.93534 #>                 AVISITVIS2:ARMCDTRT AVISITVIS3:ARMCDTRT AVISITVIS4:ARMCDTRT #> PBO Male VIS1                     0                   0                   0 #> PBO Male VIS2                     0                   0                   0 #> PBO Male VIS3                     0                   0                   0 #> PBO Male VIS4                     0                   0                   0 #> PBO Female VIS1                   0                   0                   0 #> PBO Female VIS2                   0                   0                   0 #> PBO Female VIS3                   0                   0                   0 #> PBO Female VIS4                   0                   0                   0 #> TRT Male VIS1                     0                   0                   0 #> TRT Male VIS2                     1                   0                   0 #> TRT Male VIS3                     0                   1                   0 #> TRT Male VIS4                     0                   0                   1 #> TRT Female VIS1                   0                   0                   0 #> TRT Female VIS2                   1                   0                   0 #> TRT Female VIS3                   0                   1                   0 #> TRT Female VIS4                   0                   0                   1 transform %*% coef(model) #>                       [,1] #> PBO Male VIS1   -5.0812041 #> PBO Male VIS2   -3.0267423 #> PBO Male VIS3    0.5040980 #> PBO Male VIS4    5.1144252 #> PBO Female VIS1 -4.1780538 #> PBO Female VIS2 -2.1221408 #> PBO Female VIS3  1.4048382 #> PBO Female VIS4  6.0279403 #> TRT Male VIS1   -1.7672272 #> TRT Male VIS2    0.3645159 #> TRT Male VIS3    3.3210517 #> TRT Male VIS4    9.5652532 #> TRT Female VIS1 -0.8640769 #> TRT Female VIS2  1.2691174 #> TRT Female VIS3  4.2217919 #> TRT Female VIS4 10.4787682"},{"path":[]},{"path":"/articles/model.html","id":"model","dir":"Articles","previous_headings":"","what":"Model","title":"Model","text":"Let y1,…,yNy_1, \\ldots, y_N independent data points observed individual patients clinical trial. yny_n numeric vector length TT, TT number discrete time points dataset (e.g. patient visits study protocol). model yny_n follows: yn∼Multivariate-Normal(mean=Xnb,variance=Σn) \\begin{aligned} y_n \\sim \\text{Multivariate-Normal}\\left ( \\text{mean} = X_n b, \\ \\text{variance} = \\Sigma_n \\right ) \\end{aligned}  , XnX_n fixed effect model matrix patient nn, specific makeup determined arguments intercept group brm_formula(). bb constant-length vector fixed effect parameters. MMRM brms.mmrm distributional model, means uses linear regression structure mean variance multivariate normal likelihood. particular, T×TT \\times T symmetric positive-definite residual covariance matrix Σn\\Sigma_n patient nn decomposes follows: Σn=diag(σn)⋅Λ⋅diag(σn)σn=exp(Znbσ) \\begin{aligned} \\Sigma_n &= \\text{diag}(\\sigma_n) \\cdot \\Lambda \\cdot \\text{diag}(\\sigma_n) \\\\ \\sigma_n &= \\text{exp} \\left ( Z_n b_\\sigma \\right) \\end{aligned} , σn\\sigma_n vector TT time-specific scalar standard deviations, diag(σn)\\text{diag}(\\sigma_n) diagonal T×TT \\times T matrix. ZnZ_n patient-specific matrix controls distributional parameters bσb_\\sigma map intuitive standard deviation vector σn\\sigma_n. specific makeup ZnZ_n determined sigma argument brm_formula(), turn produced brm_formula_sigma(). Λ\\Lambda symmetric positive-definite correlation matrix diagonal elements equal 1 -diagonal elements -1 1. structure Λ\\Lambda depends correlation argument brm_formula(), describe unstructured parameterization, ARMA, compound symmetry, etc. alternative structures priors available directly brms. specific details, please consult https://paulbuerkner.com/brms/reference/autocor-terms.html ?brms.mmrm::brm_formula.","code":""},{"path":"/articles/model.html","id":"priors","dir":"Articles","previous_headings":"","what":"Priors","title":"Model","text":"scalar components bb modeled independent user-defined priors specified prior argument brm_model(). hyperparameters priors constant. default priors improper uniform non-intercept terms data-dependent Student-t distribution intercept. variance-related distributional parameters bσb_\\sigma given similar priors correlation matrix Λ\\Lambda, default prior brms.mmrm LKJ correlation distribution shape parameter equal 1. choice prior valid unstructured correlation matrices. correlation structures, ARMA, parameterize Λ\\Lambda allow users set priors new specialized parameters.","code":""},{"path":"/articles/model.html","id":"sampling","dir":"Articles","previous_headings":"","what":"Sampling","title":"Model","text":"brms.mmrm, brms, fits model data using Markov chain Monte Carlo (MCMC) capabilities Stan (Stan Development Team 2023). Please read https://mc-stan.org/users/documentation/ details methodology Stan. result MCMC collection draws full joint posterior distribution parameters given data. Individual draws scalar parameters β3\\beta_3 considered draws marginal posterior distribution e.g. β3\\beta_3 given data.","code":""},{"path":"/articles/model.html","id":"imputation-of-missing-outcomes","dir":"Articles","previous_headings":"","what":"Imputation of missing outcomes","title":"Model","text":"missing random (MAR) assumptions, MMRMs require imputation (Holzhauer Weber (2024)). However, outcomes data missing random, targeting alternative estimand, may need impute missing outcomes. brms.mmrm can leverage either two alternative solutions described https://paulbuerkner.com/brms/articles/brms_missings.html. Please see usage vignette details implementation interface.","code":""},{"path":[]},{"path":"/articles/sbc.html","id":"about","dir":"Articles","previous_headings":"","what":"About","title":"Simulation-based calibration checking","text":"vignette shows results simulation-based calibration (SBC) checking study validate implementation models brms.mmrm. SBC checking tests ability Bayesian model recapture parameters used simulate prior predictive data. details SBC checking, please read Modrák et al. (2024) SBC R package (Kim et al. 2022). particular SBC checking study uses targets pipeline viggnettes/sbc/ subdirectory brms.mmrm package source code.","code":""},{"path":"/articles/sbc.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Simulation-based calibration checking","text":"results , SBC rank statistics approximately uniformly distributed. words, posterior distribution brms/Stan MMRM modeling code matches prior datasets simulated. evidence subgroup non-subgroup models brms.mmrm implemented correctly.","code":""},{"path":"/articles/sbc.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Simulation-based calibration checking","text":"show SBC checking results vignette, first load code SBC checking study, use custom functions read plot rank statistics: section SBC checking study based given modeling scenario. scenario shows results 1000 independent simulations prior.","code":"library(dplyr) library(ggplot2) library(tibble) library(tidyr)  source(\"sbc/R/prior.R\") source(\"sbc/R/response.R\") source(\"sbc/R/scenarios.R\")  read_ranks <- function(path) {   fst::read_fst(path) |>     tibble::as_tibble() |>     pivot_longer(       cols = everything(),       names_to = \"parameter\",       values_to = \"rank\"     ) }  plot_ranks <- function(ranks) {   ggplot(ranks) +     geom_histogram(       aes(x = rank),       breaks = seq(from = 0, to = max(ranks$rank), length.out = 10)     ) +     facet_wrap(~parameter) }"},{"path":"/articles/sbc.html","id":"subgroup-scenario","dir":"Articles","previous_headings":"","what":"Subgroup scenario","title":"Simulation-based calibration checking","text":"subgroup scenario distinguishes others presence subgroup factor. Assumptions: 2 treatment groups 2 subgroup levels 3 time points 150 patients per treatment group Baseline covariates (2 continuous 2 categorical) 30% dropout 8% rate independent/sporadic missing response. Model formula: prior randomly generated used simulation analysis: following histograms show SBC rank statistics compare prior parameter draws draws posterior draws. data simulation code modeling code correct consistent, rank statistics approximately uniformly distributed. Fixed effect parameter ranks:  Standard deviation parameter ranks:  Correlation parameter ranks:","code":"#> response ~ group + group:subgroup + group:subgroup:time + group:time + subgroup + subgroup:time + time + continuous1 + continuous2 + balanced + unbalanced + unstr(time = time, gr = patient)  #> sigma ~ 0 + time setup_prior(subgroup) |>   select(prior, class, coef, dpar) |>   as.data.frame() #>                      prior     class                                       coef #> 2  normal(-0.1736, 0.6054)         b                             balancedlevel2 #> 3   normal(-0.0447, 0.855)         b                             balancedlevel3 #> 4   normal(0.0406, 0.5496)         b                                continuous1 #> 5  normal(-0.0324, 0.7433)         b                                continuous2 #> 6  normal(-0.0181, 2.3641)         b                               groupgroup_2 #> 7    normal(0.2398, 1.451)         b            groupgroup_2:subgroupsubgroup_2 #> 8  normal(-0.0082, 2.7447)         b groupgroup_2:subgroupsubgroup_2:timetime_2 #> 9  normal(-0.1206, 0.9984)         b groupgroup_2:subgroupsubgroup_2:timetime_3 #> 10  normal(0.0883, 2.7254)         b                    groupgroup_2:timetime_2 #> 11  normal(0.0347, 0.3068)         b                    groupgroup_2:timetime_3 #> 12  normal(0.1064, 2.8303)         b                         subgroupsubgroup_2 #> 13  normal(0.1894, 1.2434)         b              subgroupsubgroup_2:timetime_2 #> 14 normal(-0.0294, 1.0162)         b              subgroupsubgroup_2:timetime_3 #> 15  normal(0.0649, 2.0052)         b                                 timetime_2 #> 16  normal(0.0826, 1.9545)         b                                 timetime_3 #> 17  normal(0.0491, 1.3319)         b                           unbalancedlevel2 #> 18   normal(-0.156, 1.255)         b                           unbalancedlevel3 #> 19             lkj(1.3461)   cortime                                            #> 20   normal(0.088, 2.6479) Intercept                                            #> 22  normal(0.0879, 2.8273)         b                                 timetime_1 #> 23  normal(0.2299, 2.2228)         b                                 timetime_2 #> 24  normal(0.0095, 2.2667)         b                                 timetime_3 #>     dpar #> 2        #> 3        #> 4        #> 5        #> 6        #> 7        #> 8        #> 9        #> 10       #> 11       #> 12       #> 13       #> 14       #> 15       #> 16       #> 17       #> 18       #> 19       #> 20       #> 22 sigma #> 23 sigma #> 24 sigma ranks_subgroup <- read_ranks(\"sbc/results/subgroup.fst\") ranks_subgroup |>   filter(grepl(\"^b_\", parameter)) |>   filter(!grepl(\"^b_sigma\", parameter)) |>   plot_ranks() ranks_subgroup |>   filter(grepl(\"b_sigma\", parameter)) |>   plot_ranks() ranks_subgroup |>   filter(grepl(\"cortime_\", parameter)) |>   plot_ranks()"},{"path":"/articles/sbc.html","id":"unstructured-scenario","dir":"Articles","previous_headings":"","what":"Unstructured scenario","title":"Simulation-based calibration checking","text":"scenario uses unstructured correlation use subgroup variable. Assumptions: 3 treatment groups subgroup 4 time points 100 patients per treatment group covariate adjustment missing responses Model formula: prior randomly generated used simulation analysis: SBC checking rank statistics: Fixed effect parameter ranks: Log-scale standard deviation parameter ranks:  Correlation parameter ranks:","code":"#> response ~ 0 + group + time + unstr(time = time, gr = patient)  #> sigma ~ 0 + time setup_prior(unstructured) |>   select(prior, class, coef, dpar) |>   as.data.frame() #>                      prior   class         coef  dpar #> 2  normal(-0.1005, 1.6313)       b groupgroup_1       #> 3   normal(0.2389, 0.4785)       b groupgroup_2       #> 4  normal(-0.1541, 1.2388)       b groupgroup_3       #> 5  normal(-0.0835, 2.2302)       b   timetime_2       #> 6  normal(-0.0266, 1.9245)       b   timetime_3       #> 7  normal(-0.1762, 2.2366)       b   timetime_4       #> 8              lkj(1.1812) cortime                    #> 10 normal(-0.0388, 2.5623)       b   timetime_1 sigma #> 11  normal(0.1653, 2.7346)       b   timetime_2 sigma #> 12  normal(0.0359, 2.3959)       b   timetime_3 sigma #> 13   normal(0.127, 2.5864)       b   timetime_4 sigma ranks_unstructured <- read_ranks(\"sbc/results/unstructured.fst\") ranks_unstructured |>   filter(grepl(\"^b_\", parameter)) |>   filter(!grepl(\"^b_sigma\", parameter)) |>   plot_ranks() ranks_unstructured |>   filter(grepl(\"b_sigma\", parameter)) |>   plot_ranks() ranks_unstructured |>   filter(grepl(\"cortime_\", parameter)) |>   plot_ranks()"},{"path":"/articles/sbc.html","id":"autoregressive-moving-average-scenario","dir":"Articles","previous_headings":"","what":"Autoregressive moving average scenario","title":"Simulation-based calibration checking","text":"scenario uses autoregressive moving average (ARMA) model autoregressive order 1 moving average order 1. Assumptions: 2 treatment groups subgroup 3 time points 100 patients per treatment group covariate adjustment missing responses Model formula: prior randomly generated used simulation analysis: SBC checking rank statistics: Fixed effect parameter ranks:  Log-scale standard deviation parameter ranks:  Correlation parameter ranks:","code":"#> response ~ 0 + group + time + arma(time = time, gr = patient, p = 1L, q = 1L, cov = FALSE)  #> sigma ~ 0 + time setup_prior(autoregressive_moving_average) |>   select(prior, class, coef, dpar) |>   as.data.frame() #>                      prior class         coef  dpar #> 1        uniform(0.1, 0.9)    ar                    #> 3   normal(0.1737, 0.3985)     b groupgroup_1       #> 4  normal(-0.1215, 2.1487)     b groupgroup_2       #> 5  normal(-0.0756, 2.4499)     b   timetime_2       #> 6   normal(-0.0672, 1.454)     b   timetime_3       #> 7        uniform(0.1, 0.9)    ma                    #> 9   normal(0.0282, 1.8807)     b   timetime_1 sigma #> 10   normal(0.101, 1.5519)     b   timetime_2 sigma #> 11  normal(0.0335, 0.6042)     b   timetime_3 sigma ranks_autoregressive_moving_average <- read_ranks(   \"sbc/results/autoregressive_moving_average.fst\" ) ranks_autoregressive_moving_average |>   filter(grepl(\"^b_\", parameter)) |>   filter(!grepl(\"^b_sigma\", parameter)) |>   plot_ranks() ranks_autoregressive_moving_average |>   filter(grepl(\"b_sigma\", parameter)) |>   plot_ranks() ranks_autoregressive_moving_average |>   filter(parameter %in% c(\"ar[1]\", \"ma[1]\")) |>   plot_ranks()"},{"path":"/articles/sbc.html","id":"autoregressive-scenario","dir":"Articles","previous_headings":"","what":"Autoregressive scenario","title":"Simulation-based calibration checking","text":"scenario , correlation structure autoregressive order 2. Model formula: prior randomly generated used simulation analysis: SBC checking rank statistics: Fixed effect parameter ranks: Log-scale standard deviation parameter ranks:  Correlation parameter ranks:","code":"#> response ~ 0 + group + time + ar(time = time, gr = patient, p = 2L, cov = FALSE)  #> sigma ~ 0 + time setup_prior(autoregressive) |>   select(prior, class, coef, dpar) |>   as.data.frame() #>                      prior class         coef  dpar #> 1        uniform(0.1, 0.9)    ar                    #> 3  normal(-0.0257, 1.3542)     b groupgroup_1       #> 4  normal(-0.0404, 1.5114)     b groupgroup_2       #> 5   normal(0.1645, 1.6844)     b   timetime_2       #> 6  normal(-0.1432, 0.3371)     b   timetime_3       #> 8   normal(0.1859, 2.9435)     b   timetime_1 sigma #> 9    normal(0.064, 2.2678)     b   timetime_2 sigma #> 10  normal(-0.0904, 1.322)     b   timetime_3 sigma ranks_autoregressive <- read_ranks(\"sbc/results/autoregressive.fst\") ranks_autoregressive |>   filter(grepl(\"^b_\", parameter)) |>   filter(!grepl(\"^b_sigma\", parameter)) |>   plot_ranks() ranks_autoregressive |>   filter(grepl(\"b_sigma\", parameter)) |>   plot_ranks() ranks_autoregressive |>   filter(parameter %in% c(\"ar[1]\", \"ar[2]\")) |>   plot_ranks()"},{"path":"/articles/sbc.html","id":"moving-average-scenario","dir":"Articles","previous_headings":"","what":"Moving average scenario","title":"Simulation-based calibration checking","text":"scenario , uses moving average correlation structure order 2. Model formula: prior randomly generated used simulation analysis: SBC checking rank statistics: Fixed effect parameter ranks: Log-scale standard deviation parameter ranks:  Correlation parameter ranks:","code":"#> response ~ 0 + group + time + ma(time = time, gr = patient, q = 2L, cov = FALSE)  #> sigma ~ 0 + time setup_prior(moving_average) |>   select(prior, class, coef, dpar) |>   as.data.frame() #>                      prior class         coef  dpar #> 2    normal(0.135, 1.0282)     b groupgroup_1       #> 3   normal(0.1832, 1.1802)     b groupgroup_2       #> 4     normal(0.231, 2.435)     b   timetime_2       #> 5  normal(-0.0214, 1.3086)     b   timetime_3       #> 6        uniform(0.1, 0.9)    ma                    #> 8   normal(0.2003, 0.2999)     b   timetime_1 sigma #> 9     normal(0.18, 2.6539)     b   timetime_2 sigma #> 10   normal(0.057, 2.7014)     b   timetime_3 sigma ranks_moving_average <- read_ranks(\"sbc/results/moving_average.fst\") ranks_moving_average |>   filter(grepl(\"^b_\", parameter)) |>   filter(!grepl(\"^b_sigma\", parameter)) |>   plot_ranks() ranks_moving_average |>   filter(grepl(\"b_sigma\", parameter)) |>   plot_ranks() ranks_moving_average |>   filter(parameter %in% c(\"ma[1]\", \"ma[2]\")) |>   plot_ranks()"},{"path":"/articles/sbc.html","id":"compound-symmetry-scenario","dir":"Articles","previous_headings":"","what":"Compound symmetry scenario","title":"Simulation-based calibration checking","text":"scenario , uses compound symmetry correlation structure. Model formula: prior randomly generated used simulation analysis: SBC checking rank statistics: Fixed effect parameter ranks: Log-scale standard deviation parameter ranks:  Correlation parameter ranks:","code":"#> response ~ 0 + group + time + cosy(time = time, gr = patient)  #> sigma ~ 0 + time setup_prior(compound_symmetry) |>   select(prior, class, coef, dpar) |>   as.data.frame() #>                      prior class         coef  dpar #> 2  normal(-0.0733, 0.9602)     b groupgroup_1       #> 3   normal(0.2424, 2.9937)     b groupgroup_2       #> 4   normal(0.1172, 0.4649)     b   timetime_2       #> 5  normal(-0.0516, 0.3823)     b   timetime_3       #> 6        uniform(0.1, 0.9)  cosy                    #> 8   normal(0.1713, 2.6895)     b   timetime_1 sigma #> 9  normal(-0.0965, 0.3201)     b   timetime_2 sigma #> 10 normal(-0.1482, 1.6958)     b   timetime_3 sigma ranks_compound_symmetry <- read_ranks(\"sbc/results/compound_symmetry.fst\") ranks_compound_symmetry |>   filter(grepl(\"^b_\", parameter)) |>   filter(!grepl(\"^b_sigma\", parameter)) |>   plot_ranks() ranks_compound_symmetry |>   filter(grepl(\"b_sigma\", parameter)) |>   plot_ranks() ranks_compound_symmetry |>   filter(parameter == \"cosy\") |>   plot_ranks()"},{"path":"/articles/sbc.html","id":"diagonal-scenario","dir":"Articles","previous_headings":"","what":"Diagonal scenario","title":"Simulation-based calibration checking","text":"scenario , uses diagonal correlation structure (independent time points within patients). Model formula: prior randomly generated used simulation analysis: SBC checking rank statistics: Fixed effect parameter ranks: Log-scale standard deviation parameter ranks:","code":"#> response ~ 0 + group + time  #> sigma ~ group + group:time + time setup_prior(diagonal) |>   select(prior, class, coef, dpar) |>   as.data.frame() #>                      prior     class                    coef  dpar #> 2   normal(0.0688, 0.4554)         b            groupgroup_1       #> 3  normal(-0.0271, 1.1727)         b            groupgroup_2       #> 4  normal(-0.0439, 2.5765)         b              timetime_2       #> 5  normal(-0.1282, 1.0305)         b              timetime_3       #> 7   normal(0.2012, 0.7729)         b            groupgroup_2 sigma #> 8  normal(-0.0137, 0.3341)         b groupgroup_2:timetime_2 sigma #> 9   normal(0.0819, 1.9446)         b groupgroup_2:timetime_3 sigma #> 10 normal(-0.1519, 1.0543)         b              timetime_2 sigma #> 11  normal(0.1583, 1.5648)         b              timetime_3 sigma #> 12  normal(0.0025, 1.3794) Intercept                         sigma ranks_diagonal <- read_ranks(\"sbc/results/diagonal.fst\") ranks_diagonal |>   filter(grepl(\"^b_\", parameter)) |>   filter(!grepl(\"^b_sigma\", parameter)) |>   plot_ranks() ranks_diagonal |>   filter(grepl(\"b_sigma\", parameter)) |>   plot_ranks()"},{"path":[]},{"path":"/articles/simulation.html","id":"simple","dir":"Articles","previous_headings":"","what":"Simple","title":"Simulation","text":"brm_simulate_simple() simulates dataset prior predictive distribution simple special case MMRM.1 data element classed tibble can directly supply brm_formula() brm_model(). parameters element corresponding parameter values simulated joint prior. Arguments brm_simulate_simple() control hyperparameters. model_matrix element regression model matrix fixed effect parameters.","code":"library(brms.mmrm) set.seed(0) sim <- brm_simulate_simple(   n_group = 3,   n_patient = 100,   n_time = 4 ) sim$data #> # A tibble: 1,200 × 4 #>    patient     time   response group   #>    <chr>       <chr>     <dbl> <chr>   #>  1 patient_001 time_1    1.11  group_1 #>  2 patient_001 time_2    2.15  group_1 #>  3 patient_001 time_3    2.54  group_1 #>  4 patient_001 time_4   -1.73  group_1 #>  5 patient_002 time_1    1.11  group_1 #>  6 patient_002 time_2    2.64  group_1 #>  7 patient_002 time_3    1.69  group_1 #>  8 patient_002 time_4    0.783 group_1 #>  9 patient_003 time_1    0.118 group_1 #> 10 patient_003 time_2    2.48  group_1 #> # ℹ 1,190 more rows str(sim$parameters) #> List of 5 #>  $ beta      : num [1:6] 1.263 -0.326 1.33 1.272 0.415 ... #>  $ tau       : num [1:4] -0.092857 -0.029472 -0.000577 0.240465 #>  $ sigma     : num [1:4] 0.911 0.971 0.999 1.272 #>  $ lambda    : num [1:4, 1:4] 1 0.415 -0.818 -0.282 0.415 ... #>  $ covariance: num [1:4, 1:4] 0.831 0.368 -0.745 -0.326 0.368 ... head(sim$model_matrix) #>   groupgroup_1 groupgroup_2 groupgroup_3 timetime_2 timetime_3 timetime_4 #> 1            1            0            0          0          0          0 #> 2            1            0            0          1          0          0 #> 3            1            0            0          0          1          0 #> 4            1            0            0          0          0          1 #> 5            1            0            0          0          0          0 #> 6            1            0            0          1          0          0"},{"path":"/articles/simulation.html","id":"change-from-baseline","dir":"Articles","previous_headings":"","what":"Change from baseline","title":"Simulation","text":"brm_data_change() can convert outcome variable raw response change baseline. applies real datasets passed [brm_data()] well simulated ones e.g. [brm_simulate_simple()]. dataset uses raw response baseline time point \"time_1\" brm_data_change() subtracts baseline, replaces raw response column new change baseline column, adds new column original baseline raw response, adjusts internal attributes classed object accordingly.","code":"sim$data #> # A tibble: 1,200 × 4 #>    patient     time   response group   #>    <chr>       <chr>     <dbl> <chr>   #>  1 patient_001 time_1    1.11  group_1 #>  2 patient_001 time_2    2.15  group_1 #>  3 patient_001 time_3    2.54  group_1 #>  4 patient_001 time_4   -1.73  group_1 #>  5 patient_002 time_1    1.11  group_1 #>  6 patient_002 time_2    2.64  group_1 #>  7 patient_002 time_3    1.69  group_1 #>  8 patient_002 time_4    0.783 group_1 #>  9 patient_003 time_1    0.118 group_1 #> 10 patient_003 time_2    2.48  group_1 #> # ℹ 1,190 more rows brm_data_change(   data = sim$data,   name_change = \"new_change\",   name_baseline = \"new_baseline\" ) #> # A tibble: 900 × 5 #>    patient     time   group   new_change new_baseline #>    <chr>       <chr>  <chr>        <dbl>        <dbl> #>  1 patient_001 time_2 group_1      1.04         1.11  #>  2 patient_001 time_3 group_1      1.43         1.11  #>  3 patient_001 time_4 group_1     -2.84         1.11  #>  4 patient_002 time_2 group_1      1.53         1.11  #>  5 patient_002 time_3 group_1      0.576        1.11  #>  6 patient_002 time_4 group_1     -0.328        1.11  #>  7 patient_003 time_2 group_1      2.37         0.118 #>  8 patient_003 time_3 group_1      3.07         0.118 #>  9 patient_003 time_4 group_1     -1.14         0.118 #> 10 patient_004 time_2 group_1      1.57         1.29  #> # ℹ 890 more rows"},{"path":"/articles/simulation.html","id":"advanced","dir":"Articles","previous_headings":"","what":"Advanced","title":"Simulation","text":"nuanced simulation, build dataset layer layer. Begin brm_simulate_outline() create initial structure random missingness pattern. brm_simulate_outline(), missing responses can come either transitory intercurrent events dropouts. missing column indicates outcome values missing (NA_real_) later step. response column entirely missing now simulated later. Optionally add random continuous covariates brm_simulate_continuous() random categorical covariates using brm_simulate_categorical(). case, covariates non-time-varying, means patient gets one unique value. described next section, brms.mmrm convenient function brm_simulate_prior() simulate outcome variable response using data skeleton prior predictive distribution. However, prefer full custom approach, may need granular details parameterization, requires model matrix. Fortunately, brms supports make_standata() function provide , given dataset formula. may need temporarily set response variable something non-missing, may wish specify custom prior.","code":"data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0.3 )  data #> # A tibble: 800 × 5 #>    patient     time   group   missing response #>    <chr>       <chr>  <chr>   <lgl>      <dbl> #>  1 patient_001 time_1 group_1 FALSE         NA #>  2 patient_001 time_2 group_1 TRUE          NA #>  3 patient_001 time_3 group_1 TRUE          NA #>  4 patient_001 time_4 group_1 TRUE          NA #>  5 patient_002 time_1 group_1 FALSE         NA #>  6 patient_002 time_2 group_1 FALSE         NA #>  7 patient_002 time_3 group_1 TRUE          NA #>  8 patient_002 time_4 group_1 TRUE          NA #>  9 patient_003 time_1 group_1 FALSE         NA #> 10 patient_003 time_2 group_1 FALSE         NA #> # ℹ 790 more rows data <- data |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   )  data #> # A tibble: 800 × 9 #>    patient    time  group missing response biomarker1 biomarker2 status1 status2 #>    <chr>      <chr> <chr> <lgl>      <dbl>      <dbl>      <dbl> <chr>   <chr>   #>  1 patient_0… time… grou… FALSE         NA      0.328     -0.655 present absent  #>  2 patient_0… time… grou… TRUE          NA      0.328     -0.655 present absent  #>  3 patient_0… time… grou… TRUE          NA      0.328     -0.655 present absent  #>  4 patient_0… time… grou… TRUE          NA      0.328     -0.655 present absent  #>  5 patient_0… time… grou… FALSE         NA      1.04      -0.779 absent  absent  #>  6 patient_0… time… grou… FALSE         NA      1.04      -0.779 absent  absent  #>  7 patient_0… time… grou… TRUE          NA      1.04      -0.779 absent  absent  #>  8 patient_0… time… grou… TRUE          NA      1.04      -0.779 absent  absent  #>  9 patient_0… time… grou… FALSE         NA      0.717     -0.954 present absent  #> 10 patient_0… time… grou… FALSE         NA      0.717     -0.954 present absent  #> # ℹ 790 more rows library(brms) formula <- brm_formula(data = mutate(data, response = 0)) formula #> response ~ group + group:time + time + biomarker1 + biomarker2 + status1 + status2 + unstr(time = time, gr = patient)  #> sigma ~ 0 + time  stan_data <- make_standata(   formula = formula,   data = mutate(data, response = 0) ) model_matrix <- stan_data$X head(model_matrix) #>   Intercept groupgroup_2 timetime_2 timetime_3 timetime_4 biomarker1 biomarker2 #> 1         1            0          0          0          0  0.3283275 -0.6547971 #> 2         1            0          1          0          0  0.3283275 -0.6547971 #> 3         1            0          0          1          0  0.3283275 -0.6547971 #> 4         1            0          0          0          1  0.3283275 -0.6547971 #> 5         1            0          0          0          0  1.0385746 -0.7793828 #> 6         1            0          1          0          0  1.0385746 -0.7793828 #>   status1present status2present groupgroup_2:timetime_2 groupgroup_2:timetime_3 #> 1              1              0                       0                       0 #> 2              1              0                       0                       0 #> 3              1              0                       0                       0 #> 4              1              0                       0                       0 #> 5              0              0                       0                       0 #> 6              0              0                       0                       0 #>   groupgroup_2:timetime_4 #> 1                       0 #> 2                       0 #> 3                       0 #> 4                       0 #> 5                       0 #> 6                       0"},{"path":"/articles/simulation.html","id":"prior","dir":"Articles","previous_headings":"","what":"Prior","title":"Simulation","text":"Function brm_simulate_prior() simulates prior predictive distribution. requires dataset formula, accepts custom prior constructed brms::set_prior(). output object sim multiple draws prior predictive distribution. sim$outcome outcome draws, sim$parameters parameter draws. sim$model_matrix model matrix, sim$model full brms model fit object. can pass sim$model functions brms bayesplot pp_check(). addition, sim$data copy original dataset, outcome variable taken final draw prior predictive distribution. addition, missingness pattern automatically applied sim$data$response NA_real_ whenever sim$data$missing equals TRUE.","code":"formula <- brm_formula(data = data)  library(brms) prior <- set_prior(\"student_t(3, 0, 1.3)\", class = \"Intercept\") +   set_prior(\"student_t(3, 0, 1.2)\", class = \"b\") +   set_prior(\"student_t(3, 0, 1.1)\", class = \"b\", dpar = \"sigma\") +   set_prior(\"lkj(1)\", class = \"cortime\")  prior #>                 prior     class coef group resp  dpar nlpar   lb   ub source #>  student_t(3, 0, 1.3) Intercept                             <NA> <NA>   user #>  student_t(3, 0, 1.2)         b                             <NA> <NA>   user #>  student_t(3, 0, 1.1)         b                 sigma       <NA> <NA>   user #>                lkj(1)   cortime                             <NA> <NA>   user  sim <- brm_simulate_prior(   data = data,   formula = formula,   prior = prior,   refresh = 0 ) names(sim) #> [1] \"data\"         \"model\"        \"model_matrix\" \"outcome\"      \"parameters\" sim$data #> # A tibble: 800 × 9 #>    patient    time  group missing response biomarker1 biomarker2 status1 status2 #>    <chr>      <chr> <chr> <lgl>      <dbl>      <dbl>      <dbl> <chr>   <chr>   #>  1 patient_0… time… grou… FALSE      3.90       0.328     -0.655 present absent  #>  2 patient_0… time… grou… TRUE      NA          0.328     -0.655 present absent  #>  3 patient_0… time… grou… TRUE      NA          0.328     -0.655 present absent  #>  4 patient_0… time… grou… TRUE      NA          0.328     -0.655 present absent  #>  5 patient_0… time… grou… FALSE      3.46       1.04      -0.779 absent  absent  #>  6 patient_0… time… grou… FALSE      2.66       1.04      -0.779 absent  absent  #>  7 patient_0… time… grou… TRUE      NA          1.04      -0.779 absent  absent  #>  8 patient_0… time… grou… TRUE      NA          1.04      -0.779 absent  absent  #>  9 patient_0… time… grou… FALSE      5.28       0.717     -0.954 present absent  #> 10 patient_0… time… grou… FALSE      0.120      0.717     -0.954 present absent  #> # ℹ 790 more rows"},{"path":"/articles/simulation.html","id":"posterior","dir":"Articles","previous_headings":"","what":"Posterior","title":"Simulation","text":"brms supports posterior predictive simulations checks functions posteiror_predict(), posterior_epred(), pp_check(). can used brms model fit object either brm_model() brm_simulate_prior(). returned outcome_draws object numeric array posterior predictive draws, one row per draw one column per non-missing observation (row) original data.","code":"data <- sim$data formula <- brm_formula(data = data) model <- brm_model(data = data, formula = formula, refresh = 0) outcome_draws <- posterior_predict(object = model) str(outcome_draws) #>  num [1:4000, 1:659] 4.57 3.84 3.88 3.06 3.48 ...  dim(data) #> [1] 800   9  sum(!is.na(data$response)) #> [1] 659"},{"path":"/articles/subgroup.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Subgroup analysis","text":"subgroup variable must categorical. categorical subgroup level adequate representation among treatment groups discrete time points. Otherwise, marginal means interest may estimable. create special classed dataset brms.mmrm using brm_data(), please supply name subgroup variable reference subgroup level. Post-processing functions use reference subgroup level compare pairs subgroups: example, treatment effect subgroup_2 minus treatment effect reference subgroup level choose.","code":"library(brms.mmrm) library(dplyr) library(magrittr) set.seed(0L) raw_data <- brm_simulate_outline(   n_group = 3,   n_subgroup = 2,   n_patient = 50,   n_time = 3,   rate_dropout = 0,   rate_lapse = 0 ) |>   mutate(response = rnorm(n = n()))  raw_data #> # A tibble: 900 × 6 #>    patient     time   group   subgroup   missing response #>    <chr>       <chr>  <chr>   <chr>      <lgl>      <dbl> #>  1 patient_001 time_1 group_1 subgroup_1 FALSE    1.26    #>  2 patient_001 time_2 group_1 subgroup_1 FALSE   -0.326   #>  3 patient_001 time_3 group_1 subgroup_1 FALSE    1.33    #>  4 patient_002 time_1 group_1 subgroup_1 FALSE    1.27    #>  5 patient_002 time_2 group_1 subgroup_1 FALSE    0.415   #>  6 patient_002 time_3 group_1 subgroup_1 FALSE   -1.54    #>  7 patient_003 time_1 group_1 subgroup_1 FALSE   -0.929   #>  8 patient_003 time_2 group_1 subgroup_1 FALSE   -0.295   #>  9 patient_003 time_3 group_1 subgroup_1 FALSE   -0.00577 #> 10 patient_004 time_1 group_1 subgroup_1 FALSE    2.40    #> # ℹ 890 more rows count(raw_data, group, subgroup, time) #> # A tibble: 18 × 4 #>    group   subgroup   time       n #>    <chr>   <chr>      <chr>  <int> #>  1 group_1 subgroup_1 time_1    50 #>  2 group_1 subgroup_1 time_2    50 #>  3 group_1 subgroup_1 time_3    50 #>  4 group_1 subgroup_2 time_1    50 #>  5 group_1 subgroup_2 time_2    50 #>  6 group_1 subgroup_2 time_3    50 #>  7 group_2 subgroup_1 time_1    50 #>  8 group_2 subgroup_1 time_2    50 #>  9 group_2 subgroup_1 time_3    50 #> 10 group_2 subgroup_2 time_1    50 #> 11 group_2 subgroup_2 time_2    50 #> 12 group_2 subgroup_2 time_3    50 #> 13 group_3 subgroup_1 time_1    50 #> 14 group_3 subgroup_1 time_2    50 #> 15 group_3 subgroup_1 time_3    50 #> 16 group_3 subgroup_2 time_1    50 #> 17 group_3 subgroup_2 time_2    50 #> 18 group_3 subgroup_2 time_3    50 data <- brm_data(   data = raw_data,   outcome = \"response\",   baseline = NULL,   group = \"group\",   subgroup = \"subgroup\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_subgroup = \"subgroup_1\",   reference_time = \"time_1\" )  str(data) #> brms_mm_ [900 × 6] (S3: brms_mmrm_data/tbl_df/tbl/data.frame) #>  $ patient : chr [1:900] \"patient_001\" \"patient_001\" \"patient_001\" \"patient_002\" ... #>  $ time    : chr [1:900] \"time_1\" \"time_2\" \"time_3\" \"time_1\" ... #>  $ group   : chr [1:900] \"group_1\" \"group_1\" \"group_1\" \"group_1\" ... #>  $ subgroup: chr [1:900] \"subgroup_1\" \"subgroup_1\" \"subgroup_1\" \"subgroup_1\" ... #>  $ missing : logi [1:900] FALSE FALSE FALSE FALSE FALSE FALSE ... #>  $ response: num [1:900] 1.263 -0.326 1.33 1.272 0.415 ... #>  - attr(*, \"brm_outcome\")= chr \"response\" #>  - attr(*, \"brm_group\")= chr \"group\" #>  - attr(*, \"brm_subgroup\")= chr \"subgroup\" #>  - attr(*, \"brm_time\")= chr \"time\" #>  - attr(*, \"brm_patient\")= chr \"patient\" #>  - attr(*, \"brm_covariates\")= chr(0)  #>  - attr(*, \"brm_reference_group\")= chr \"group_1\" #>  - attr(*, \"brm_reference_subgroup\")= chr \"subgroup_1\" #>  - attr(*, \"brm_reference_time\")= chr \"time_1\""},{"path":"/articles/subgroup.html","id":"formula","dir":"Articles","previous_headings":"","what":"Formula","title":"Subgroup analysis","text":"subgroup analysis, formula terms include subgroup variable. plausible interactions optional via arguments brm_formula(). specific example, disable interactions except group-subgroup interaction. create analogous non-subgroup reduced model, disable terms involve subgroup. useful later measuring impact subgroup whole, without needing restrict specific level subgroup.1","code":"formula_subgroup <- brm_formula(   data = data,   group_subgroup_time = FALSE,   subgroup_time = FALSE )  formula_subgroup #> response ~ group + group:subgroup + group:time + subgroup + time + unstr(time = time, gr = patient)  #> sigma ~ 0 + time formula_reduced <- brm_formula(   data = data,   group_subgroup = FALSE,   group_subgroup_time = FALSE,   subgroup = FALSE,   subgroup_time = FALSE )  formula_reduced #> response ~ group + group:time + time + unstr(time = time, gr = patient)  #> sigma ~ 0 + time"},{"path":"/articles/subgroup.html","id":"models","dir":"Articles","previous_headings":"","what":"Models","title":"Subgroup analysis","text":"run full subgroup reduced non-subgroup models, use brm_model() usual. Remember supply appropriate formula case.","code":"model_subgroup <- brm_model(   data = data,   formula = formula_subgroup,   refresh = 0 ) #> Compiling Stan program... #> Start sampling model_reduced <- brm_model(   data = data,   formula = formula_reduced,   refresh = 0 ) #> Compiling Stan program... #> Start sampling"},{"path":"/articles/subgroup.html","id":"marginals","dir":"Articles","previous_headings":"","what":"Marginals","title":"Subgroup analysis","text":"brm_marginal_draws() automatically produces subgroup-specific marginal means brm_formula() declared subgroup-specific fixed effects.2 draws_subgroup, marginals time difference (change baseline) treatment difference now subgroup-specific. addition, new difference_subgroup table. posterior samples difference_subgroup measure differences subgroup level reference subgroup level respect treatment effects difference_group. brm_marginal_summaries() brm_marginal_probabilities() automatically aware subgroup-specific marginals brm_marginal_draws(). Notably, brm_marginal_summaries() summarizes subgroup differences difference_subgroup table brm_marginal_draws(). brm_marginal_probabilities() still focuses treatment effects, differences pairs subgroup levels. brm_marignal_data() can produce either subgroup-specific non-subgroup-specific summary statistics.","code":"draws_subgroup <- brm_marginal_draws(   model = model_subgroup,   average_within_subgroup = FALSE ) draws_reduced <- brm_marginal_draws(   model = model_reduced,   average_within_subgroup = FALSE ) tibble::as_tibble(draws_subgroup$difference_group) #> # A tibble: 4,000 × 11 #>    .chain .draw .iteration `group_2|subgroup_1|time_2` group_2|subgroup_1|time…¹ #>     <int> <int>      <int>                       <dbl>                     <dbl> #>  1      1     1          1                     -0.472                    -0.534  #>  2      1     2          2                     -0.0221                   -0.335  #>  3      1     3          3                     -0.222                    -0.217  #>  4      1     4          4                      0.199                    -0.111  #>  5      1     5          5                      0.0411                   -0.165  #>  6      1     6          6                     -0.215                    -0.571  #>  7      1     7          7                      0.0821                   -0.163  #>  8      1     8          8                     -0.167                    -0.0113 #>  9      1     9          9                      0.282                     0.0544 #> 10      1    10         10                      0.321                    -0.322  #> # ℹ 3,990 more rows #> # ℹ abbreviated name: ¹​`group_2|subgroup_1|time_3` #> # ℹ 6 more variables: `group_2|subgroup_2|time_2` <dbl>, #> #   `group_2|subgroup_2|time_3` <dbl>, `group_3|subgroup_1|time_2` <dbl>, #> #   `group_3|subgroup_1|time_3` <dbl>, `group_3|subgroup_2|time_2` <dbl>, #> #   `group_3|subgroup_2|time_3` <dbl> tibble::as_tibble(draws_subgroup$difference_subgroup) #> # A tibble: 4,000 × 7 #>    .chain .draw .iteration `group_2|subgroup_2|time_2` group_2|subgroup_2|time…¹ #>     <int> <int>      <int>                       <dbl>                     <dbl> #>  1      1     1          1                    5.55e-17                         0 #>  2      1     2          2                    4.16e-17                         0 #>  3      1     3          3                    0                                0 #>  4      1     4          4                   -2.78e-17                         0 #>  5      1     5          5                    2.78e-17                         0 #>  6      1     6          6                    0                                0 #>  7      1     7          7                    5.55e-17                         0 #>  8      1     8          8                    2.78e-17                         0 #>  9      1     9          9                    0                                0 #> 10      1    10         10                    0                                0 #> # ℹ 3,990 more rows #> # ℹ abbreviated name: ¹​`group_2|subgroup_2|time_3` #> # ℹ 2 more variables: `group_3|subgroup_2|time_2` <dbl>, #> #   `group_3|subgroup_2|time_3` <dbl> summaries_subgroup <- brm_marginal_summaries(   draws_subgroup,   level = 0.95 )  summaries_reduced <- brm_marginal_summaries(   draws_reduced,   level = 0.95 )  summaries_subgroup #> # A tibble: 340 × 7 #>    marginal         statistic group   subgroup   time     value    mcse #>    <chr>            <chr>     <chr>   <chr>      <chr>    <dbl>   <dbl> #>  1 difference_group lower     group_2 subgroup_1 time_2 -0.300  0.00952 #>  2 difference_group lower     group_2 subgroup_1 time_3 -0.540  0.0137  #>  3 difference_group lower     group_2 subgroup_2 time_2 -0.300  0.00952 #>  4 difference_group lower     group_2 subgroup_2 time_3 -0.540  0.0137  #>  5 difference_group lower     group_3 subgroup_1 time_2 -0.130  0.00873 #>  6 difference_group lower     group_3 subgroup_1 time_3 -0.286  0.00976 #>  7 difference_group lower     group_3 subgroup_2 time_2 -0.130  0.00873 #>  8 difference_group lower     group_3 subgroup_2 time_3 -0.286  0.00976 #>  9 difference_group mean      group_2 subgroup_1 time_2  0.0913 0.00439 #> 10 difference_group mean      group_2 subgroup_1 time_3 -0.167  0.00403 #> # ℹ 330 more rows brm_marginal_probabilities(   draws = draws_subgroup,   threshold = c(-0.1, 0.1),   direction = c(\"greater\", \"less\") ) #> # A tibble: 16 × 6 #>    direction threshold group   subgroup   time   value #>    <chr>         <dbl> <chr>   <chr>      <chr>  <dbl> #>  1 greater        -0.1 group_2 subgroup_1 time_2 0.826 #>  2 greater        -0.1 group_2 subgroup_1 time_3 0.362 #>  3 greater        -0.1 group_2 subgroup_2 time_2 0.826 #>  4 greater        -0.1 group_2 subgroup_2 time_3 0.362 #>  5 greater        -0.1 group_3 subgroup_1 time_2 0.966 #>  6 greater        -0.1 group_3 subgroup_1 time_3 0.846 #>  7 greater        -0.1 group_3 subgroup_2 time_2 0.966 #>  8 greater        -0.1 group_3 subgroup_2 time_3 0.846 #>  9 less            0.1 group_2 subgroup_1 time_2 0.515 #> 10 less            0.1 group_2 subgroup_1 time_3 0.915 #> 11 less            0.1 group_2 subgroup_2 time_2 0.515 #> 12 less            0.1 group_2 subgroup_2 time_3 0.915 #> 13 less            0.1 group_3 subgroup_1 time_2 0.204 #> 14 less            0.1 group_3 subgroup_1 time_3 0.498 #> 15 less            0.1 group_3 subgroup_2 time_2 0.204 #> 16 less            0.1 group_3 subgroup_2 time_3 0.498 summaries_data_subgroup <- brm_marginal_data(   data = data,   level = 0.95,   use_subgroup = TRUE )  summaries_data_subgroup #> # A tibble: 126 × 5 #>    statistic group   subgroup   time   value #>    <chr>     <chr>   <chr>      <chr>  <dbl> #>  1 lower     group_1 subgroup_1 time_1 0.170 #>  2 lower     group_1 subgroup_1 time_2 0.244 #>  3 lower     group_1 subgroup_1 time_3 0.169 #>  4 lower     group_1 subgroup_2 time_1 0.484 #>  5 lower     group_1 subgroup_2 time_2 0.364 #>  6 lower     group_1 subgroup_2 time_3 0.266 #>  7 lower     group_2 subgroup_1 time_1 0.421 #>  8 lower     group_2 subgroup_1 time_2 0.221 #>  9 lower     group_2 subgroup_1 time_3 0.208 #> 10 lower     group_2 subgroup_2 time_1 0.220 #> # ℹ 116 more rows summaries_data_reduced <- brm_marginal_data(   data = data,   level = 0.95,   use_subgroup = FALSE )  summaries_data_reduced #> # A tibble: 63 × 4 #>    statistic group   time     value #>    <chr>     <chr>   <chr>    <dbl> #>  1 lower     group_1 time_1  0.251  #>  2 lower     group_1 time_2  0.219  #>  3 lower     group_1 time_3  0.143  #>  4 lower     group_2 time_1  0.237  #>  5 lower     group_2 time_2  0.252  #>  6 lower     group_2 time_3 -0.0331 #>  7 lower     group_3 time_1  0.104  #>  8 lower     group_3 time_2  0.332  #>  9 lower     group_3 time_3  0.110  #> 10 mean      group_1 time_1  0.0632 #> # ℹ 53 more rows"},{"path":"/articles/subgroup.html","id":"model-comparison","dir":"Articles","previous_headings":"","what":"Model comparison","title":"Subgroup analysis","text":"Metrics brms can compare full subgroup reduced non-subgroup model assess effect subgroup whole. can easily compute widely applicable information criterion (WAIC) model. Likewise, can compare models terms expected log predictive density (ELPD) based approximate Pareto-smoothed leave-one-cross-validation.","code":"brms::waic(model_subgroup) #>  #> Computed from 4000 by 900 log-likelihood matrix. #>  #>           Estimate   SE #> elpd_waic  -1275.8 19.9 #> p_waic        20.0  1.0 #> waic        2551.6 39.9 brms::waic(model_reduced) #>  #> Computed from 4000 by 900 log-likelihood matrix. #>  #>           Estimate   SE #> elpd_waic  -1273.9 20.0 #> p_waic        17.1  0.9 #> waic        2547.8 40.0 loo_subgroup <- brms::loo(model_subgroup) loo_reduced <- brms::loo(model_reduced) loo_subgroup #>  #> Computed from 4000 by 900 log-likelihood matrix. #>  #>          Estimate   SE #> elpd_loo  -1275.8 19.9 #> p_loo        20.1  1.0 #> looic      2551.6 39.9 #> ------ #> MCSE of elpd_loo is 0.1. #> MCSE and ESS estimates assume MCMC draws (r_eff in [0.4, 1.6]). #>  #> All Pareto k estimates are good (k < 0.7). #> See help('pareto-k-diagnostic') for details. loo_reduced #>  #> Computed from 4000 by 900 log-likelihood matrix. #>  #>          Estimate   SE #> elpd_loo  -1274.0 20.0 #> p_loo        17.2  0.9 #> looic      2547.9 40.0 #> ------ #> MCSE of elpd_loo is 0.1. #> MCSE and ESS estimates assume MCMC draws (r_eff in [0.4, 1.8]). #>  #> All Pareto k estimates are good (k < 0.7). #> See help('pareto-k-diagnostic') for details. loo::loo_compare(loo_subgroup, loo_reduced) #>                elpd_diff se_diff #> model_reduced   0.0       0.0    #> model_subgroup -1.9       1.6"},{"path":"/articles/subgroup.html","id":"visualization","dir":"Articles","previous_headings":"","what":"Visualization","title":"Subgroup analysis","text":"brm_plot_draws() aware subgroup-specific marginal means.  can adjust visual aesthetics compare subgroup levels side side subgroup level primary comparison interest.  following function call compares subgroup model results subgroup data.  can adjust plot aesthetics view subgroup levels side side primary comparison interest.  can also visually compare treatment effects subgroup level marginal treatment effects reduced model.  Please remember filter single subgroup level. Otherwise, brm_plot_compare() throws informative error prevent overplotting.","code":"brm_plot_draws(draws_subgroup$difference_group) brm_plot_draws(   draws_subgroup$difference_group,   axis = \"subgroup\",   facet = c(\"time\", \"group\") ) brm_plot_compare(   data = summaries_data_subgroup,   model = summaries_subgroup,   marginal = \"response\" ) brm_plot_compare(   data = summaries_data_subgroup,   model = summaries_subgroup,   marginal = \"response\",   compare = \"subgroup\",   axis = \"time\",   facet = c(\"group\", \"source\") ) brm_plot_compare(   subgroup = filter(summaries_subgroup, subgroup == \"subgroup_2\"),   reduced = summaries_reduced,   marginal = \"difference_group\" ) brm_plot_compare(   subgroup = summaries_subgroup,   reduced = summaries_reduced,   marginal = \"difference_group\" ) #> Error: #> ! brm_plot_compare() is omitting the subgroup variable because not all marginal summaries have it, but marginal summaries 'subgroup' have more than one subgroup level. Please either filter on a single subgroup level or make sure all supplied marginal summaries are subgroup-specific."},{"path":[]},{"path":"/articles/usage.html","id":"raw-data","dir":"Articles","previous_headings":"","what":"Raw data","title":"Usage","text":"use brms.mmrm package, begin longitudinal dataset one row per patient observation columns response variable, treatment group indicator, discrete time point indicator, patient ID variable, optional baseline covariates age gender. example, consider fev_dat dataset mmrm package. artificial (simulated) dataset clinical trial investigating effect active treatment FEV1 (forced expired volume one second), compared placebo. FEV1 measure quickly lungs can emptied low levels may indicate chronic obstructive pulmonary disease (COPD). dataset tibble 800 rows following notable variables: USUBJID (subject ID) AVISIT (visit number, factor) VISITN (visit number, numeric) ARMCD (treatment, TRT PBO) RACE (3-category race) SEX (female male) FEV1_BL (FEV1 baseline, %) FEV1 (FEV1 study visits) WEIGHT (weighting variable) vignette, derive response variable FEV1_CHG change baseline FEV1.","code":"data(fev_data, package = \"mmrm\") fev_data <- fev_data |>   mutate(FEV1_CHG = FEV1 - FEV1_BL)"},{"path":"/articles/usage.html","id":"preprocessing","dir":"Articles","previous_headings":"","what":"Preprocessing","title":"Usage","text":"use brm_data() function preprocess raw data express special classed data frame brms.mmrm. brm_data() stores arguments outcome, group, time, etc. attributes downstream post-processing functions recognize. addition, convert discrete time variable AVISIT ordered factor whose levels respect chronological order given continuous time variable VISITN. AVISIT special contrasts attribute generated contr.treatment() prevent base R automatically assigning default inappropriate contr.poly() polynomial contrasts.","code":"data <- brm_data(   data = fev_data,   outcome = \"FEV1_CHG\",   group = \"ARMCD\",   time = \"AVISIT\",   patient = \"USUBJID\",   baseline = \"FEV1_BL\",   reference_group = \"PBO\",   reference_time = \"VIS1\",   covariates = c(\"RACE\", \"SEX\") ) data #> # A tibble: 800 × 11 #>    USUBJID AVISIT ARMCD RACE            SEX   FEV1_BL  FEV1 WEIGHT VISITN VISITN2 FEV1_CHG #>    <fct>   <fct>  <fct> <fct>           <fct>   <dbl> <dbl>  <dbl>  <int>   <dbl>    <dbl> #>  1 PT2     VIS1   PBO   Asian           Male     45.0  NA    0.465      1  0.330     NA    #>  2 PT2     VIS2   PBO   Asian           Male     45.0  31.5  0.233      2 -0.820    -13.6  #>  3 PT2     VIS3   PBO   Asian           Male     45.0  36.9  0.360      3  0.487     -8.15 #>  4 PT2     VIS4   PBO   Asian           Male     45.0  48.8  0.507      4  0.738      3.78 #>  5 PT3     VIS1   PBO   Black or Afric… Fema…    43.5  NA    0.682      1  0.576     NA    #>  6 PT3     VIS2   PBO   Black or Afric… Fema…    43.5  36.0  0.892      2 -0.305     -7.51 #>  7 PT3     VIS3   PBO   Black or Afric… Fema…    43.5  NA    0.128      3  1.51      NA    #>  8 PT3     VIS4   PBO   Black or Afric… Fema…    43.5  37.2  0.222      4  0.390     -6.34 #>  9 PT5     VIS1   PBO   Black or Afric… Male     43.6  32.3  0.411      1 -0.0162   -11.3  #> 10 PT5     VIS2   PBO   Black or Afric… Male     43.6  NA    0.422      2  0.944     NA    #> # ℹ 790 more rows str(attributes(data)) #> List of 11 #>  $ row.names          : int [1:800] 1 2 3 4 5 6 7 8 9 10 ... #>  $ names              : chr [1:11] \"USUBJID\" \"AVISIT\" \"ARMCD\" \"RACE\" ... #>  $ class              : chr [1:4] \"brms_mmrm_data\" \"tbl_df\" \"tbl\" \"data.frame\" #>  $ brm_outcome        : chr \"FEV1_CHG\" #>  $ brm_baseline       : chr \"FEV1_BL\" #>  $ brm_group          : chr \"ARMCD\" #>  $ brm_time           : chr \"AVISIT\" #>  $ brm_patient        : chr \"USUBJID\" #>  $ brm_covariates     : chr [1:2] \"RACE\" \"SEX\" #>  $ brm_reference_group: chr \"PBO\" #>  $ brm_reference_time : chr \"VIS1\" data <- data |>   brm_data_chronologize(order = \"VISITN\") str(data$AVISIT) #>  Ord.factor w/ 4 levels \"VIS1\"<\"VIS2\"<..: 1 2 3 4 1 2 3 4 1 2 ... #>  - attr(*, \"contrasts\")= num [1:4, 1:3] 0 1 0 0 0 0 1 0 0 0 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:4] \"VIS1\" \"VIS2\" \"VIS3\" \"VIS4\" #>   .. ..$ : chr [1:3] \"2\" \"3\" \"4\""},{"path":"/articles/usage.html","id":"formula","dir":"Articles","previous_headings":"","what":"Formula","title":"Usage","text":"Next, choose brms model formula fixed effect variance parameters. brm_formula() function brms.mmrm makes process easier. example, formula omits baseline response interaction terms. purposes example, choose fully parameterized analysis raw response.","code":"brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE,   group_time = FALSE ) #> FEV1_CHG ~ ARMCD + AVISIT + RACE + SEX + unstr(time = AVISIT, gr = USUBJID)  #> sigma ~ 0 + AVISIT formula <- brm_formula(data = data)  formula #> FEV1_CHG ~ FEV1_BL + FEV1_BL:AVISIT + ARMCD + ARMCD:AVISIT + AVISIT + RACE + SEX + unstr(time = AVISIT, gr = USUBJID)  #> sigma ~ 0 + AVISIT"},{"path":"/articles/usage.html","id":"priors","dir":"Articles","previous_headings":"","what":"Priors","title":"Usage","text":"analyses require informative priors, others require non-informative ones. Please use brms construct prior suitable analysis. brms package documentation default priors constructed set priors.1 R object represents joint prior distribution model, can pass brm_model() function described . get_prior() function shows default priors given dataset model formula.","code":"brms::get_prior(data = data, formula = formula) |>   as.data.frame() |>   select(-any_of(c(\"group\", \"resp\", \"nlpar\", \"lb\", \"ub\", \"source\"))) #>                      prior     class                       coef  dpar #> 1                                  b                                  #> 2                                  b                   ARMCDTRT       #> 3                                  b           ARMCDTRT:AVISIT2       #> 4                                  b           ARMCDTRT:AVISIT3       #> 5                                  b           ARMCDTRT:AVISIT4       #> 6                                  b                    AVISIT2       #> 7                                  b                    AVISIT3       #> 8                                  b                    AVISIT4       #> 9                                  b                    FEV1_BL       #> 10                                 b            FEV1_BL:AVISIT2       #> 11                                 b            FEV1_BL:AVISIT3       #> 12                                 b            FEV1_BL:AVISIT4       #> 13                                 b RACEBlackorAfricanAmerican       #> 14                                 b                  RACEWhite       #> 15                                 b                  SEXFemale       #> 16                  lkj(1)   cortime                                  #> 17 student_t(3, 1.9, 11.8) Intercept                                  #> 18                                 b                            sigma #> 19                                 b                 AVISITVIS1 sigma #> 20                                 b                 AVISITVIS2 sigma #> 21                                 b                 AVISITVIS3 sigma #> 22                                 b                 AVISITVIS4 sigma"},{"path":"/articles/usage.html","id":"model","dir":"Articles","previous_headings":"","what":"Model","title":"Usage","text":"run MMRM, use brm_model() function. function calls brms::brm() behind scenes, using formula prior set formula prior arguments. result brms model object extra list elements brms.mmrm_data brms.mmrm_formula keep track data formula used fit model.","code":"model <- brm_model(data = data, formula = formula, refresh = 0) #> Compiling Stan program... #> Start sampling model #>  Family: gaussian  #>   Links: mu = identity; sigma = log  #> Formula: FEV1_CHG ~ FEV1_BL + FEV1_BL:AVISIT + ARMCD + ARMCD:AVISIT + AVISIT + RACE + SEX + unstr(time = AVISIT, gr = USUBJID)  #>          sigma ~ 0 + AVISIT #>    Data: modeled_data (Number of observations: 537)  #>   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1; #>          total post-warmup draws = 4000 #>  #> Correlation Structures: #>                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS #> cortime(VIS1,VIS2)     0.36      0.08     0.19     0.51 1.00     5330     3117 #> cortime(VIS1,VIS3)     0.14      0.10    -0.06     0.32 1.00     5545     2626 #> cortime(VIS2,VIS3)     0.04      0.10    -0.15     0.24 1.00     5103     3078 #> cortime(VIS1,VIS4)     0.16      0.12    -0.08     0.38 1.00     5353     2866 #> cortime(VIS2,VIS4)     0.11      0.09    -0.06     0.28 1.00     6012     3087 #> cortime(VIS3,VIS4)     0.01      0.10    -0.19     0.21 1.00     4506     2771 #>  #> Regression Coefficients: #>                            Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS #> Intercept                     23.32      2.57    18.30    28.46 1.00     1595     2142 #> FEV1_BL                       -0.82      0.06    -0.93    -0.70 1.00     1720     2210 #> ARMCDTRT                       4.04      1.07     1.97     6.20 1.00     2694     3113 #> AVISIT2                        4.43      2.75    -1.15     9.82 1.00     2037     2470 #> AVISIT3                       12.55      2.93     6.74    18.27 1.00     1852     2195 #> AVISIT4                       15.59      4.23     7.38    23.91 1.00     2489     2521 #> RACEBlackorAfricanAmerican     1.45      0.59     0.28     2.65 1.00     5262     3112 #> RACEWhite                      5.46      0.61     4.26     6.68 1.00     5172     3218 #> SEXFemale                      0.38      0.51    -0.62     1.40 1.00     5881     3056 #> FEV1_BL:AVISIT2                0.01      0.06    -0.12     0.14 1.00     2069     2704 #> FEV1_BL:AVISIT3               -0.05      0.07    -0.19     0.08 1.00     1898     2215 #> FEV1_BL:AVISIT4               -0.01      0.10    -0.21     0.19 1.00     2596     2762 #> ARMCDTRT:AVISIT2              -0.06      1.15    -2.31     2.17 1.00     2894     3132 #> ARMCDTRT:AVISIT3              -1.02      1.20    -3.37     1.38 1.00     3078     3105 #> ARMCDTRT:AVISIT4               0.35      1.88    -3.30     3.93 1.00     3810     3176 #> sigma_AVISITVIS1               1.83      0.06     1.71     1.95 1.00     5127     3300 #> sigma_AVISITVIS2               1.59      0.06     1.47     1.71 1.00     5574     3239 #> sigma_AVISITVIS3               1.33      0.06     1.21     1.45 1.00     5217     3072 #> sigma_AVISITVIS4               2.28      0.06     2.16     2.41 1.00     6592     3198 #>  #> Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS #> and Tail_ESS are effective sample size measures, and Rhat is the potential #> scale reduction factor on split chains (at convergence, Rhat = 1). model$brms.mmrm_data #> # A tibble: 800 × 11 #>    USUBJID AVISIT ARMCD RACE            SEX   FEV1_BL  FEV1 WEIGHT VISITN VISITN2 FEV1_CHG #>    <fct>   <ord>  <fct> <fct>           <fct>   <dbl> <dbl>  <dbl>  <int>   <dbl>    <dbl> #>  1 PT2     VIS1   PBO   Asian           Male     45.0  NA    0.465      1  0.330     NA    #>  2 PT2     VIS2   PBO   Asian           Male     45.0  31.5  0.233      2 -0.820    -13.6  #>  3 PT2     VIS3   PBO   Asian           Male     45.0  36.9  0.360      3  0.487     -8.15 #>  4 PT2     VIS4   PBO   Asian           Male     45.0  48.8  0.507      4  0.738      3.78 #>  5 PT3     VIS1   PBO   Black or Afric… Fema…    43.5  NA    0.682      1  0.576     NA    #>  6 PT3     VIS2   PBO   Black or Afric… Fema…    43.5  36.0  0.892      2 -0.305     -7.51 #>  7 PT3     VIS3   PBO   Black or Afric… Fema…    43.5  NA    0.128      3  1.51      NA    #>  8 PT3     VIS4   PBO   Black or Afric… Fema…    43.5  37.2  0.222      4  0.390     -6.34 #>  9 PT5     VIS1   PBO   Black or Afric… Male     43.6  32.3  0.411      1 -0.0162   -11.3  #> 10 PT5     VIS2   PBO   Black or Afric… Male     43.6  NA    0.422      2  0.944     NA    #> # ℹ 790 more rows model$brms.mmrm_formula #> FEV1_CHG ~ FEV1_BL + FEV1_BL:AVISIT + ARMCD + ARMCD:AVISIT + AVISIT + RACE + SEX + unstr(time = AVISIT, gr = USUBJID)  #> sigma ~ 0 + AVISIT"},{"path":"/articles/usage.html","id":"marginals","dir":"Articles","previous_headings":"","what":"Marginals","title":"Usage","text":"Regardless choice fixed effects formula, brms.mmrm performs inference marginal distributions treatment group time point mean following quantities: Response. Change baseline. reported originally declared baseline time point reference_time argument brm_data(). Treatment difference. declared baseline (2), treatment difference calculated terms change baseline. Otherwise, calculated terms raw response. Effect size: treatment difference divided residual standard deviation. derive posterior draws marginals, use brm_marginal_draws() function. need samples marginals averaged across time points, e.g. “overall effect size”, brm_marginal_draws_average() can average draws across discrete time points (either user-defined subset). brm_marginal_summaries() function produces posterior summaries marginals, includes Monte Carlo standard error (MCSE) estimate. brm_marginal_probabilities() function shows posterior probabilities form, Prob(treatment effect>threshold) \\begin{aligned} \\text{Prob}(\\text{treatment effect} > \\text{threshold}) \\end{aligned} Prob(treatment effect<threshold) \\begin{aligned} \\text{Prob}(\\text{treatment effect} < \\text{threshold}) \\end{aligned} Finally, brm_marignal_data() computes marginal means confidence intervals response variable data, along summary statistics.","code":"draws <- brm_marginal_draws(model = model)  names(draws) #> [1] \"response\"         \"difference_time\"  \"difference_group\" \"effect\"           #> [5] \"sigma\"  draws$difference_group #> # A draws_df: 1000 iterations, 4 chains, and 3 variables #>    TRT|VIS2 TRT|VIS3 TRT|VIS4 #> 1     0.251    -2.24    1.149 #> 2    -0.662    -1.33   -0.804 #> 3    -0.129    -1.57    2.736 #> 4    -0.370    -2.00    1.231 #> 5    -0.964    -1.91   -1.026 #> 6    -0.939    -1.15    0.258 #> 7    -0.026    -1.15   -0.047 #> 8     0.052    -1.48    1.239 #> 9    -0.929    -0.81   -0.791 #> 10   -0.437    -1.16    2.233 #> # ... with 3990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'} draws_average <- brm_marginal_draws_average(draws = draws, data = data)  names(draws_average) #> [1] \"response\"         \"difference_time\"  \"difference_group\" \"effect\"           #> [5] \"sigma\"  draws_average$difference_group #> # A draws_df: 1000 iterations, 4 chains, and 1 variables #>    TRT|average #> 1       -0.281 #> 2       -0.932 #> 3        0.347 #> 4       -0.380 #> 5       -1.300 #> 6       -0.610 #> 7       -0.407 #> 8       -0.064 #> 9       -0.845 #> 10       0.212 #> # ... with 3990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'} summaries <- brm_marginal_summaries(draws, level = 0.95)  summaries #> # A tibble: 140 × 6 #>    marginal         statistic group time    value   mcse #>    <chr>            <chr>     <chr> <chr>   <dbl>  <dbl> #>  1 difference_group lower     TRT   VIS2  -2.31   0.0465 #>  2 difference_group lower     TRT   VIS3  -3.37   0.0668 #>  3 difference_group lower     TRT   VIS4  -3.30   0.0688 #>  4 difference_group mean      TRT   VIS2  -0.0638 0.0216 #>  5 difference_group mean      TRT   VIS3  -1.02   0.0219 #>  6 difference_group mean      TRT   VIS4   0.348  0.0311 #>  7 difference_group median    TRT   VIS2  -0.0714 0.0249 #>  8 difference_group median    TRT   VIS3  -1.02   0.0252 #>  9 difference_group median    TRT   VIS4   0.381  0.0320 #> 10 difference_group sd        TRT   VIS2   1.15   0.0161 #> # ℹ 130 more rows brm_marginal_probabilities(   draws = draws,   threshold = c(-0.1, 0.1),   direction = c(\"greater\", \"less\") ) #> # A tibble: 6 × 5 #>   direction threshold group time  value #>   <chr>         <dbl> <chr> <chr> <dbl> #> 1 greater        -0.1 TRT   VIS2  0.511 #> 2 greater        -0.1 TRT   VIS3  0.220 #> 3 greater        -0.1 TRT   VIS4  0.594 #> 4 less            0.1 TRT   VIS2  0.56  #> 5 less            0.1 TRT   VIS3  0.827 #> 6 less            0.1 TRT   VIS4  0.443 summaries_data <- brm_marginal_data(data = data, level = 0.95)  summaries_data #> # A tibble: 56 × 4 #>    statistic group time   value #>    <chr>     <fct> <ord>  <dbl> #>  1 lower     PBO   VIS1  -5.86  #>  2 lower     PBO   VIS2  -1.44  #>  3 lower     PBO   VIS3   4.33  #>  4 lower     PBO   VIS4  11.1   #>  5 lower     TRT   VIS1   0.423 #>  6 lower     TRT   VIS2   3.96  #>  7 lower     TRT   VIS3   7.67  #>  8 lower     TRT   VIS4  16.0   #>  9 mean      PBO   VIS1  -8.09  #> 10 mean      PBO   VIS2  -3.38  #> # ℹ 46 more rows"},{"path":[]},{"path":"/articles/usage.html","id":"comparing-models-and-data","dir":"Articles","previous_headings":"Visualization","what":"Comparing models and data","title":"Usage","text":"Suppose fit second model omits baseline. brm_plot_compare() function compares means intervals different models data sources plot.  omit marginals data, can show inference change baseline treatment effect.  Additional arguments let control primary comparison interest (color aesthetic), horizontal axis, faceting variable.","code":"summaries_no_baseline <- data |>   brm_formula(baseline = FALSE, baseline_time = FALSE) |>   brm_model(data = data, refresh = 0) |>   brm_marginal_draws() |>   brm_marginal_summaries() #> Compiling Stan program... #> Start sampling brm_plot_compare(   data = summaries_data,   no_baseline = summaries_no_baseline,   with_baseline = summaries ) brm_plot_compare(   no_baseline = summaries_no_baseline,   with_baseline = summaries,   marginal = \"difference_group\" # treatment effect ) brm_plot_compare(   no_baseline = summaries_no_baseline,   with_baseline = summaries,   marginal = \"difference_group\",   compare = \"group\",   axis = \"time\",   facet = \"source\" # model1 vs model2 )"},{"path":"/articles/usage.html","id":"plotting-draws","dir":"Articles","previous_headings":"Visualization","what":"Plotting draws","title":"Usage","text":"brm_plot_draws() can plot posterior draws response, change baseline, treatment difference.  axis facet arguments customize horizontal axis faceting variable, respectively.","code":"brm_plot_draws(draws = draws$difference_group) brm_plot_draws(   draws = draws$difference_group,   axis = \"group\",   facet = \"time\" )"},{"path":"/articles/usage.html","id":"comparing-priors-and-posteriors","dir":"Articles","previous_headings":"Visualization","what":"Comparing priors and posteriors","title":"Usage","text":"model intercept term automatic centering brms turned , brms default assigns mildly informative Student t prior help MCMC converge.2 Suppose want compare prior Intercept marginal posterior. begin, express prior using distributional package, extract posterior samples brms model, visualize together ggdist package. , shaded gray region posterior density, blue line prior density.","code":"brms::prior_summary(model) |>   filter(class == \"Intercept\") #> Intercept ~ student_t(3, 1.9, 11.8) library(distributional) library(ggdist) library(ggplot2) library(posterior)  prior <- dist_student_t(3, 1.9, 11.8) posterior <- as_draws_df(model)  ggplot() +   stat_halfeye(aes(x = Intercept), data = posterior) +   stat_slab(aes(xdist = prior), color = \"blue\", fill = NA) +   scale_thickness_shared()"},{"path":"/articles/usage.html","id":"appendix-a-contrasts","dir":"Articles","previous_headings":"","what":"Appendix A: Contrasts","title":"Usage","text":"formula factor ultimately determines fixed effect parameterization. ordering categorical variables data, well contrast option R, affect construction model matrix. see model matrix ultimately used brm_model(), run brms::make_standata() examine X element returned list. contrast option accepts named vector two character vectors govern model.matrix() contrasts unordered ordered variables, respectively. make_standata() function lets see data brms generate Stan. includes fixed effects model matrix X. Note differences groupgroup_* additive terms matrix one . choose different contrast method, different model matrix may result. Recall earlier brm_data_chronologize() protects discrete time variable (case, AVISIT) contrasts option assigning contrasts attribute .","code":"options(contrasts = c(unordered = \"contr.SAS\", ordered = \"contr.poly\")) head(brms::make_standata(formula = formula, data = data)$X) #>     Intercept  FEV1_BL ARMCDPBO AVISIT2 AVISIT3 AVISIT4 RACEAsian #> 422         1 25.27144        0       1       0       0         0 #> 424         1 25.27144        0       0       0       1         0 #> 2           1 45.02477        1       1       0       0         1 #> 3           1 45.02477        1       0       1       0         1 #> 4           1 45.02477        1       0       0       1         1 #> 6           1 43.50070        1       1       0       0         0 #>     RACEBlackorAfricanAmerican SEXMale FEV1_BL:AVISIT2 FEV1_BL:AVISIT3 FEV1_BL:AVISIT4 #> 422                          1       0        25.27144         0.00000         0.00000 #> 424                          1       0         0.00000         0.00000        25.27144 #> 2                            0       1        45.02477         0.00000         0.00000 #> 3                            0       1         0.00000        45.02477         0.00000 #> 4                            0       1         0.00000         0.00000        45.02477 #> 6                            1       0        43.50070         0.00000         0.00000 #>     ARMCDPBO:AVISIT2 ARMCDPBO:AVISIT3 ARMCDPBO:AVISIT4 #> 422                0                0                0 #> 424                0                0                0 #> 2                  1                0                0 #> 3                  0                1                0 #> 4                  0                0                1 #> 6                  1                0                0 options(   contrasts = c(unordered = \"contr.treatment\", ordered = \"contr.poly\") ) # different model matrix than before: head(brms::make_standata(formula = formula, data = data)$X) #>     Intercept  FEV1_BL ARMCDTRT AVISIT2 AVISIT3 AVISIT4 RACEBlackorAfricanAmerican #> 422         1 25.27144        1       1       0       0                          1 #> 424         1 25.27144        1       0       0       1                          1 #> 2           1 45.02477        0       1       0       0                          0 #> 3           1 45.02477        0       0       1       0                          0 #> 4           1 45.02477        0       0       0       1                          0 #> 6           1 43.50070        0       1       0       0                          1 #>     RACEWhite SEXFemale FEV1_BL:AVISIT2 FEV1_BL:AVISIT3 FEV1_BL:AVISIT4 ARMCDTRT:AVISIT2 #> 422         0         1        25.27144         0.00000         0.00000                1 #> 424         0         1         0.00000         0.00000        25.27144                0 #> 2           0         0        45.02477         0.00000         0.00000                0 #> 3           0         0         0.00000        45.02477         0.00000                0 #> 4           0         0         0.00000         0.00000        45.02477                0 #> 6           0         1        43.50070         0.00000         0.00000                0 #>     ARMCDTRT:AVISIT3 ARMCDTRT:AVISIT4 #> 422                0                0 #> 424                0                1 #> 2                  0                0 #> 3                  0                0 #> 4                  0                0 #> 6                  0                0 str(data$AVISIT) #>  Ord.factor w/ 4 levels \"VIS1\"<\"VIS2\"<..: 1 2 3 4 1 2 3 4 1 2 ... #>  - attr(*, \"contrasts\")= num [1:4, 1:3] 0 1 0 0 0 0 1 0 0 0 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:4] \"VIS1\" \"VIS2\" \"VIS3\" \"VIS4\" #>   .. ..$ : chr [1:3] \"2\" \"3\" \"4\""},{"path":"/articles/usage.html","id":"appendix-b-imputation-of-missing-outcomes","dir":"Articles","previous_headings":"","what":"Appendix B: Imputation of missing outcomes","title":"Usage","text":"missing random (MAR) assumptions, MMRMs require imputation (Holzhauer Weber (2024)). However, outcomes data missing random, targeting alternative estimand, may need impute missing outcomes. brms.mmrm can leverage either two alternative solutions described https://paulbuerkner.com/brms/articles/brms_missings.html.","code":""},{"path":"/articles/usage.html","id":"imputation-before-model-fitting","dir":"Articles","previous_headings":"Appendix B: Imputation of missing outcomes","what":"Imputation before model fitting","title":"Usage","text":"impute missing outcomes model fitting, first use create list imputed datasets using multiple imputation method choice. rbmi package uniquely suited multiple imputation continuous longitudinal clinical trial data. point, imputed_datasets list data frames response variable imputed multiple imputation. Simply supply list imputed argument brm_model(). Internally, brm_model() calls brms::brm_multiple(data = imputed, formula = formula) instead brms::brm(data = data, formula = formula) fit MMRM individual imputed datasets imputed object. computation take several hours requires many fitted MMRM. Unless set combine = FALSE brm_model(), brms automatically combines posterior samples across imputed datasets. means downstream post-processing workflow exactly non-imputation case.","code":"variables <- rbmi::set_vars(   outcome = \"FEV1_CHG\",   visit = \"AVISIT\",   subjid = \"USUBJID\",   group = \"ARMCD\",   covariates = c(\"RACE\", \"SEX\") ) imputation_draws <- rbmi::draws(   data = data |>     mutate(       USUBJID = as.factor(USUBJID),       AVISIT = as.factor(AVISIT)     ),   vars = variables,   method = rbmi::method_condmean(type = \"jackknife\"),   quiet = TRUE ) imputation_run <- rbmi::impute(   draws = imputation_draws,   references = c(     placebo = \"PBO\",     treatment = \"TRT\"   ) ) imputed_datasets <- rbmi::extract_imputed_dfs(imputation_run) model <- brm_model(   data = data, # Yes, please supply the original non-imputed dataset too.   formula = formula,   imputed = imputed_datasets,   refresh = 0 )"},{"path":"/articles/usage.html","id":"imputation-during-model-fitting","dir":"Articles","previous_headings":"Appendix B: Imputation of missing outcomes","what":"Imputation during model fitting","title":"Usage","text":"Alternatively, conduct imputation fitting model, set model_missing_outcomes TRUE brm_formula(). formula uses response | mi() instead just response left-hand side tell brms model missing outcome model parameter. use type imputation, simply supply returned formula object formula argument brm_model(). Unlike imputation model fitting, approach requires one fit model. However, model sample posterior draws missing outcome model parameter, MCMC may run slower produce larger output object.","code":"brm_formula(data, model_missing_outcomes = TRUE) #> FEV1_CHG | mi() ~ FEV1_BL + FEV1_BL:AVISIT + ARMCD + ARMCD:AVISIT + AVISIT + RACE + SEX + unstr(time = AVISIT, gr = USUBJID)  #> sigma ~ 0 + AVISIT"},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"William Michael Landau. Author, maintainer. Kevin Kunzmann. Author. Yoni Sidi. Author. Christian Stock. Author. Eli Lilly Company. Copyright holder, funder. Boehringer Ingelheim Pharma GmbH & Co. KG. Copyright holder, funder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Landau WM, Kunzmann K, Sidi Y, Stock C (2025). brms.mmrm: Bayesian MMRMs using 'brms'. R package version 1.1.1.9000, https://openpharma.github.io/brms.mmrm/.","code":"@Manual{,   title = {brms.mmrm: Bayesian MMRMs using 'brms'},   author = {William Michael Landau and Kevin Kunzmann and Yoni Sidi and Christian Stock},   year = {2025},   note = {R package version 1.1.1.9000},   url = {https://openpharma.github.io/brms.mmrm/}, }"},{"path":"/index.html","id":"brmsmmrm-","dir":"","previous_headings":"","what":"Bayesian MMRMs using brms","title":"Bayesian MMRMs using brms","text":"mixed model repeated measures (MMRM) popular model longitudinal clinical trial data continuous endpoints, brms powerful versatile package fitting Bayesian regression models. brms.mmrm R package leverages brms run MMRMs, supports simplified interface reduce difficulty align best practices life sciences.","code":""},{"path":[]},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian MMRMs using brms","text":"documentation website https://openpharma.github.io/brms.mmrm/ complete function reference tutorial vignettes.","code":""},{"path":"/index.html","id":"validation","dir":"","previous_headings":"","what":"Validation","title":"Bayesian MMRMs using brms","text":"ensure correctness model implementation, package validated using simulation-based calibration comparisons frequentist mmrm package two example datasets. analyses results described package vignettes linked : Simulation-based calibration FEV1 data comparison Bayesian frequentist MMRMs. BCVA data comparison Bayesian frequentist MMRMs. Notably, FEV1 BCVA datasets mmrm uses compare SAS vignette. additional validation functional area domain expertise, may choose run similar analyses datasets compare brms.mmrm mmrm /SAS.","code":""},{"path":"/index.html","id":"help","dir":"","previous_headings":"","what":"Help","title":"Bayesian MMRMs using brms","text":"Please report questions problems GitHub discussions GitHub issues, respectively.","code":""},{"path":"/index.html","id":"thanks","dir":"","previous_headings":"","what":"Thanks","title":"Bayesian MMRMs using brms","text":"Thanks openstatsware R Consortium providing professional networks recruit skilled statisticians developers.","code":""},{"path":"/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of conduct","title":"Bayesian MMRMs using brms","text":"Please note brms.mmrm project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Bayesian MMRMs using brms","text":"","code":"To cite package 'brms.mmrm' in publications use:    Landau WM, Kunzmann K, Sidi Y, Stock C (????). _brms.mmrm: Bayesian   MMRMs using 'brms'_. R package version 1.1.0.9002,   <https://github.com/openpharma/brms.mmrm>.  A BibTeX entry for LaTeX users is    @Manual{,     title = {brms.mmrm: Bayesian MMRMs using 'brms'},     author = {William Michael Landau and Kevin Kunzmann and Yoni Sidi and Christian Stock},     note = {R package version 1.1.0.9002},     url = {https://github.com/openpharma/brms.mmrm},   }"},{"path":"/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Bayesian MMRMs using brms","text":"Paul-Christian Bürkner (2017). brms: R Package Bayesian Multilevel Models Using Stan. Journal Statistical Software, 80(1), 1-28. Mallinckrodt, C.H., Lane, P.W., Schnell, D. et al. Recommendations Primary Analysis Continuous Endpoints Longitudinal Clinical Trials. Ther Innov Regul Sci 42, 303–319 (2008). Holzhauer, B., Weber, S. (2024), “Bayesian mixed effects model repeated measures,” Applied Modeling Drug Development, Novartis AG. https://opensource.nibr.com/bamdd/src/02h_mmrm.html.","code":""},{"path":"/reference/brm_archetype_average_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"Create cell-means-like informative prior archetype special fixed effect represent average across time.","code":""},{"path":"/reference/brm_archetype_average_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"","code":"brm_archetype_average_cells(   data,   intercept = FALSE,   baseline = !is.null(attr(data, \"brm_baseline\")),   baseline_subgroup = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_subgroup_time = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_time = !is.null(attr(data, \"brm_baseline\")),   covariates = TRUE,   prefix_interest = \"x_\",   prefix_nuisance = \"nuisance_\" )"},{"path":"/reference/brm_archetype_average_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). intercept Logical length 1. TRUE (default) include intercept, FALSE omit. baseline Logical length 1. TRUE include additive effect baseline response, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_subgroup Logical length 1. baseline_subgroup_time Logical length 1. TRUE include baseline--subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline subgroup variables dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_time Logical length 1. TRUE include baseline--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. covariates Logical length 1. TRUE (default) include additive covariates declared covariates argument brm_data(), FALSE omit. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. prefix_interest Character string prepend new columns generated fixed effects interest (relating group, subgroup, /time). rare cases, may need set non-default prefix prevent name conflicts existing columns data, rename columns data. prefix_interest must value prefix_nuisance. prefix_nuisance prefix_interest, relating generated fixed effects interest (relating group, subgroup, time). Must value prefix_interest.","code":""},{"path":"/reference/brm_archetype_average_cells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"special classed tibble data tailored cell-means-like time-averaged archetype. dataset augmented extra columns \"archetype_\" prefix, well special attributes tell downstream functions like brm_formula() object.","code":""},{"path":"/reference/brm_archetype_average_cells.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"archetype special fixed effect treatment group represent mean response averaged across time points. illustrate, suppose dataset two treatment groups B, time points 1, 2, 3, covariates. Let mu_gt marginal mean response group g time t given data hyperparameters. model fixed effect parameters beta_1, beta_2, ..., beta_6 express marginal means mu_gt follows:   group , beta_1 average response group averaged across time points. can confirm expressing average across time (mu_A1 + mu_A2 + mu_A3) / 3 terms beta_* parameters confirming expression simplifies just beta_1. beta_2 represents mean response group time 2, beta_3 represents mean response group time 3. beta_4, beta_5, beta_6 analogous group B.","code":"`mu_A1 = 3 * beta_1 - beta_2 - beta_3`   `mu_A2 = beta_2`   `mu_A3 = beta_3`    `mu_B1 = 3 * beta_4 - beta_5 - beta_6`   `mu_B2 = beta_5`   `mu_B3 = beta_6`"},{"path":"/reference/brm_archetype_average_cells.html","id":"prior-labeling-for-brm-archetype-average-cells-","dir":"Reference","previous_headings":"","what":"Prior labeling for brm_archetype_average_cells()","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"Within treatment group, initial time point represents average, successive time point represents response within actual time. illustrate, consider example Details section. labeling scheme brm_archetype_average_cells(), can label prior beta_1 using brm_prior_label(code = \"normal(1.2, 5)\", group = \"\", time = \"1\"). Similarly, cal label prior beta_5 brm_prior_label(code = \"normal(1.3, 7)\", group = \"B\", time = \"2\"). confirm set prior correctly, compare brms prior output summary(your_archetype). See examples details.","code":""},{"path":"/reference/brm_archetype_average_cells.html","id":"nuisance-variables","dir":"Reference","previous_headings":"","what":"Nuisance variables","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"presence covariate adjustment, functions like brm_archetype_successive_cells() convert nuisance factors binary dummy variables, center dummy variables continuous nuisance variables means data. ensures main model coefficients interest implicitly conditional subset data. words, preprocessing nuisance variables way preserves interpretations fixed effects interest, ensures informative priors can specified correctly.","code":""},{"path":"/reference/brm_archetype_average_cells.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_archetype_average_cells.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell-means-like time-averaged archetype — brm_archetype_average_cells","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) dplyr::select(   data,   group,   time,   patient,   starts_with(\"biomarker\"),   starts_with(\"status\") ) #> # A tibble: 600 × 7 #>    group   time   patient     biomarker1 biomarker2 status1 status2 #>    <chr>   <chr>  <chr>            <dbl>      <dbl> <chr>   <chr>   #>  1 group_1 time_2 patient_001     -1.42      -0.287 absent  present #>  2 group_1 time_3 patient_001     -1.42      -0.287 absent  present #>  3 group_1 time_4 patient_001     -1.42      -0.287 absent  present #>  4 group_1 time_2 patient_002     -1.67       1.84  absent  present #>  5 group_1 time_3 patient_002     -1.67       1.84  absent  present #>  6 group_1 time_4 patient_002     -1.67       1.84  absent  present #>  7 group_1 time_2 patient_003      1.38      -0.157 absent  absent  #>  8 group_1 time_3 patient_003      1.38      -0.157 absent  absent  #>  9 group_1 time_4 patient_003      1.38      -0.157 absent  absent  #> 10 group_1 time_2 patient_004     -0.920     -1.39  present present #> # ℹ 590 more rows archetype <- brm_archetype_average_cells(data) archetype #> # A tibble: 600 × 23 #>    x_group_1_time_2 x_group_1_time_3 x_group_1_time_4 x_group_2_time_2 #>  *            <int>            <int>            <int>            <int> #>  1                3               -1               -1                0 #>  2                0                1                0                0 #>  3                0                0                1                0 #>  4                3               -1               -1                0 #>  5                0                1                0                0 #>  6                0                0                1                0 #>  7                3               -1               -1                0 #>  8                0                1                0                0 #>  9                0                0                1                0 #> 10                3               -1               -1                0 #> # ℹ 590 more rows #> # ℹ 19 more variables: x_group_2_time_3 <int>, x_group_2_time_4 <int>, #> #   nuisance_biomarker1 <dbl>, nuisance_biomarker2 <dbl>, #> #   nuisance_status1_absent <dbl>, nuisance_status2_present <dbl>, #> #   nuisance_baseline <dbl>, nuisance_baseline.timetime_2 <dbl>, #> #   nuisance_baseline.timetime_3 <dbl>, patient <chr>, time <chr>, group <chr>, #> #   missing <lgl>, change <dbl>, baseline <dbl>, biomarker1 <dbl>, … summary(archetype) #> # This is the \"average cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and important fixed effect parameters #> # (right-hand side). Nuisance parameters are omitted. #> #  #> #   group_1:time_2 = 3*x_group_1_time_2 - x_group_1_time_3 - x_group_1_time_4 #> #   group_1:time_3 = x_group_1_time_3 #> #   group_1:time_4 = x_group_1_time_4 #> #   group_2:time_2 = 3*x_group_2_time_2 - x_group_2_time_3 - x_group_2_time_4 #> #   group_2:time_3 = x_group_2_time_3 #> #   group_2:time_4 = x_group_2_time_4 formula <- brm_formula(archetype) formula #> change ~ 0 + x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 + x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 + nuisance_biomarker1 + nuisance_biomarker2 + nuisance_status1_absent + nuisance_status2_present + nuisance_baseline + nuisance_baseline.timetime_2 + nuisance_baseline.timetime_3 + unstr(time = time, gr = patient)  #> sigma ~ 0 + time prior <- brm_prior_label(   code = \"normal(1, 2.2)\",   group = \"group_1\",   time = \"time_2\" ) |>   brm_prior_label(\"normal(1, 3.3)\", group = \"group_1\", time = \"time_3\") |>   brm_prior_label(\"normal(1, 4.4)\", group = \"group_1\", time = \"time_4\") |>   brm_prior_label(\"normal(2, 2.2)\", group = \"group_2\", time = \"time_2\") |>   brm_prior_label(\"normal(2, 3.3)\", group = \"group_2\", time = \"time_3\") |>   brm_prior_label(\"normal(2, 4.4)\", group = \"group_2\", time = \"time_4\") |>   brm_prior_archetype(archetype) prior #>           prior class             coef group resp dpar nlpar   lb   ub source #>  normal(1, 2.2)     b x_group_1_time_2                       <NA> <NA>   user #>  normal(1, 3.3)     b x_group_1_time_3                       <NA> <NA>   user #>  normal(1, 4.4)     b x_group_1_time_4                       <NA> <NA>   user #>  normal(2, 2.2)     b x_group_2_time_2                       <NA> <NA>   user #>  normal(2, 3.3)     b x_group_2_time_3                       <NA> <NA>   user #>  normal(2, 4.4)     b x_group_2_time_4                       <NA> <NA>   user class(prior) #> [1] \"brmsprior\"  \"data.frame\" if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = archetype,         formula = formula,         prior = prior,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) suppressWarnings(print(model)) brms::prior_summary(model) draws <- brm_marginal_draws(   data = archetype,   formula = formula,   model = model ) summaries_model <- brm_marginal_summaries(draws) summaries_data <- brm_marginal_data(data) brm_plot_compare(model = summaries_model, data = summaries_data) }"},{"path":"/reference/brm_archetype_average_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Treatment effect time-averaged archetype — brm_archetype_average_effects","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"Create treatment effect informative prior archetype special fixed effect represent average across time.","code":""},{"path":"/reference/brm_archetype_average_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"","code":"brm_archetype_average_effects(   data,   intercept = FALSE,   baseline = !is.null(attr(data, \"brm_baseline\")),   baseline_subgroup = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_subgroup_time = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_time = !is.null(attr(data, \"brm_baseline\")),   covariates = TRUE,   prefix_interest = \"x_\",   prefix_nuisance = \"nuisance_\" )"},{"path":"/reference/brm_archetype_average_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). intercept Logical length 1. TRUE (default) include intercept, FALSE omit. baseline Logical length 1. TRUE include additive effect baseline response, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_subgroup Logical length 1. baseline_subgroup_time Logical length 1. TRUE include baseline--subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline subgroup variables dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_time Logical length 1. TRUE include baseline--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. covariates Logical length 1. TRUE (default) include additive covariates declared covariates argument brm_data(), FALSE omit. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. prefix_interest Character string prepend new columns generated fixed effects interest (relating group, subgroup, /time). rare cases, may need set non-default prefix prevent name conflicts existing columns data, rename columns data. prefix_interest must value prefix_nuisance. prefix_nuisance prefix_interest, relating generated fixed effects interest (relating group, subgroup, time). Must value prefix_interest.","code":""},{"path":"/reference/brm_archetype_average_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"special classed tibble data tailored treatment effect time-averaged archetype. dataset augmented extra columns \"archetype_\" prefix, well special attributes tell downstream functions like brm_formula() object.","code":""},{"path":"/reference/brm_archetype_average_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"archetype special fixed effect treatment group represent mean response averaged across time points, treatment effects explicitly parameterized. illustrate, suppose dataset two treatment groups (placebo/reference group) B (active/non-reference group), time points 1, 2, 3, covariates. Let mu_gt marginal mean response group g time t given data hyperparameters. model fixed effect parameters beta_1, beta_2, ..., beta_6 express marginal means mu_gt follows:   group , beta_1 average response group averaged across time points. can confirm expressing average across time (mu_A1 + mu_A2 + mu_A3) / 3 terms beta_* parameters confirming expression simplifies just beta_1. beta_2 represents mean response group time 2, beta_3 represents mean response group time 3. beta_4 treatment effect group B relative group , averaged across time points. beta_5 treatment effect B vs time 2, beta_6 analogous time 3.","code":"`mu_A1 = 3 * beta_1 - beta_2 - beta_3` `mu_A2 = beta_2` `mu_A3 = beta_3`  `mu_B1 = 3 * beta_1 - beta_2 - beta_3 + 3 * beta_4 - beta_5 - beta_6` `mu_B2 = beta_2 + beta_5` `mu_B3 = beta_3 + beta_6`"},{"path":"/reference/brm_archetype_average_effects.html","id":"prior-labeling-for-brm-archetype-average-effects-","dir":"Reference","previous_headings":"","what":"Prior labeling for brm_archetype_average_effects()","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"Within treatment group, initial time point represents average, successive time point represents response within actual time. illustrate, consider example Details section. labeling scheme brm_archetype_average_effects(), can label prior beta_1 using brm_prior_label(code = \"normal(1.2, 5)\", group = \"\", time = \"1\"). Similarly, cal label prior beta_5 brm_prior_label(code = \"normal(1.3, 7)\", group = \"B\", time = \"2\"). confirm set prior correctly, compare brms prior output summary(your_archetype). See examples details.","code":""},{"path":"/reference/brm_archetype_average_effects.html","id":"nuisance-variables","dir":"Reference","previous_headings":"","what":"Nuisance variables","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"presence covariate adjustment, functions like brm_archetype_successive_cells() convert nuisance factors binary dummy variables, center dummy variables continuous nuisance variables means data. ensures main model coefficients interest implicitly conditional subset data. words, preprocessing nuisance variables way preserves interpretations fixed effects interest, ensures informative priors can specified correctly.","code":""},{"path":"/reference/brm_archetype_average_effects.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_archetype_average_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Treatment effect time-averaged archetype — brm_archetype_average_effects","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) dplyr::select(   data,   group,   time,   patient,   starts_with(\"biomarker\"),   starts_with(\"status\") ) #> # A tibble: 600 × 7 #>    group   time   patient     biomarker1 biomarker2 status1 status2 #>    <chr>   <chr>  <chr>            <dbl>      <dbl> <chr>   <chr>   #>  1 group_1 time_2 patient_001     -1.42      -0.287 absent  present #>  2 group_1 time_3 patient_001     -1.42      -0.287 absent  present #>  3 group_1 time_4 patient_001     -1.42      -0.287 absent  present #>  4 group_1 time_2 patient_002     -1.67       1.84  absent  present #>  5 group_1 time_3 patient_002     -1.67       1.84  absent  present #>  6 group_1 time_4 patient_002     -1.67       1.84  absent  present #>  7 group_1 time_2 patient_003      1.38      -0.157 absent  absent  #>  8 group_1 time_3 patient_003      1.38      -0.157 absent  absent  #>  9 group_1 time_4 patient_003      1.38      -0.157 absent  absent  #> 10 group_1 time_2 patient_004     -0.920     -1.39  present present #> # ℹ 590 more rows archetype <- brm_archetype_average_effects(data) archetype #> # A tibble: 600 × 23 #>    x_group_1_time_2 x_group_1_time_3 x_group_1_time_4 x_group_2_time_2 #>  *            <int>            <int>            <int>            <int> #>  1                3               -1               -1                0 #>  2                0                1                0                0 #>  3                0                0                1                0 #>  4                3               -1               -1                0 #>  5                0                1                0                0 #>  6                0                0                1                0 #>  7                3               -1               -1                0 #>  8                0                1                0                0 #>  9                0                0                1                0 #> 10                3               -1               -1                0 #> # ℹ 590 more rows #> # ℹ 19 more variables: x_group_2_time_3 <int>, x_group_2_time_4 <int>, #> #   nuisance_biomarker1 <dbl>, nuisance_biomarker2 <dbl>, #> #   nuisance_status1_absent <dbl>, nuisance_status2_present <dbl>, #> #   nuisance_baseline <dbl>, nuisance_baseline.timetime_2 <dbl>, #> #   nuisance_baseline.timetime_3 <dbl>, patient <chr>, time <chr>, group <chr>, #> #   missing <lgl>, change <dbl>, baseline <dbl>, biomarker1 <dbl>, … summary(archetype) #> # This is the \"average effects\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and important fixed effect parameters #> # (right-hand side). Nuisance parameters are omitted. #> #  #> #   group_1:time_2 = 3*x_group_1_time_2 - x_group_1_time_3 - x_group_1_time_4 #> #   group_1:time_3 = x_group_1_time_3 #> #   group_1:time_4 = x_group_1_time_4 #> #   group_2:time_2 = 3*x_group_1_time_2 - x_group_1_time_3 - x_group_1_time_4 + 3*x_group_2_time_2 - x_group_2_time_3 - x_group_2_time_4 #> #   group_2:time_3 = x_group_1_time_3 + x_group_2_time_3 #> #   group_2:time_4 = x_group_1_time_4 + x_group_2_time_4 formula <- brm_formula(archetype) formula #> change ~ 0 + x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 + x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 + nuisance_biomarker1 + nuisance_biomarker2 + nuisance_status1_absent + nuisance_status2_present + nuisance_baseline + nuisance_baseline.timetime_2 + nuisance_baseline.timetime_3 + unstr(time = time, gr = patient)  #> sigma ~ 0 + time prior <- brm_prior_label(   code = \"normal(1, 2.2)\",   group = \"group_1\",   time = \"time_2\" ) |>   brm_prior_label(\"normal(1, 3.3)\", group = \"group_1\", time = \"time_3\") |>   brm_prior_label(\"normal(1, 4.4)\", group = \"group_1\", time = \"time_4\") |>   brm_prior_label(\"normal(2, 2.2)\", group = \"group_2\", time = \"time_2\") |>   brm_prior_label(\"normal(2, 3.3)\", group = \"group_2\", time = \"time_3\") |>   brm_prior_label(\"normal(2, 4.4)\", group = \"group_2\", time = \"time_4\") |>   brm_prior_archetype(archetype) prior #>           prior class             coef group resp dpar nlpar   lb   ub source #>  normal(1, 2.2)     b x_group_1_time_2                       <NA> <NA>   user #>  normal(1, 3.3)     b x_group_1_time_3                       <NA> <NA>   user #>  normal(1, 4.4)     b x_group_1_time_4                       <NA> <NA>   user #>  normal(2, 2.2)     b x_group_2_time_2                       <NA> <NA>   user #>  normal(2, 3.3)     b x_group_2_time_3                       <NA> <NA>   user #>  normal(2, 4.4)     b x_group_2_time_4                       <NA> <NA>   user class(prior) #> [1] \"brmsprior\"  \"data.frame\" if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = archetype,         formula = formula,         prior = prior,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) suppressWarnings(print(model)) brms::prior_summary(model) draws <- brm_marginal_draws(   data = archetype,   formula = formula,   model = model ) summaries_model <- brm_marginal_summaries(draws) summaries_data <- brm_marginal_data(data) brm_plot_compare(model = summaries_model, data = summaries_data) }"},{"path":"/reference/brm_archetype_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell means archetype — brm_archetype_cells","title":"Cell means archetype — brm_archetype_cells","text":"Create informative prior archetype cell means.","code":""},{"path":"/reference/brm_archetype_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell means archetype — brm_archetype_cells","text":"","code":"brm_archetype_cells(   data,   intercept = FALSE,   baseline = !is.null(attr(data, \"brm_baseline\")),   baseline_subgroup = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_subgroup_time = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_time = !is.null(attr(data, \"brm_baseline\")),   covariates = TRUE,   clda = FALSE,   prefix_interest = \"x_\",   prefix_nuisance = \"nuisance_\" )"},{"path":"/reference/brm_archetype_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell means archetype — brm_archetype_cells","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). intercept TRUE make one parameters intercept, FALSE otherwise. TRUE, interpretation parameters \"Details\" section change, responsible manually calling summary() archetype interpreting parameters according output. addition, responsible setting appropriate prior intercept. normal usage, brms looks model parameter called \"Intercept\" uses data set prior help MCMC runs smoothly. intercept = TRUE informative prior archetypes, intercept called something else, brms auto-generate sensible default prior. baseline Logical length 1. TRUE include additive effect baseline response, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_subgroup Logical length 1. baseline_subgroup_time Logical length 1. TRUE include baseline--subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline subgroup variables dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_time Logical length 1. TRUE include baseline--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. covariates Logical length 1. TRUE (default) include additive covariates declared covariates argument brm_data(), FALSE omit. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. clda TRUE opt constrained longitudinal data analysis (cLDA), FALSE otherwise. use cLDA, reference_time must non-NULL call brm_data() used construct data. archetypes support cLDA (e.g. brm_archetype_average_cells() brm_archetype_average_effects()). cLDA, fixed effects parameterization restricted treatment groups pooled baseline. (supplied subgroup variable brm_data(), constraint applied separately within subgroup variable.) cLDA may result precise estimates time variable baseline level baseline outcomes recorded randomization clinical trial. prefix_interest Character string prepend new columns generated fixed effects interest (relating group, subgroup, /time). rare cases, may need set non-default prefix prevent name conflicts existing columns data, rename columns data. prefix_interest must value prefix_nuisance. prefix_nuisance prefix_interest, relating generated fixed effects interest (relating group, subgroup, time). Must value prefix_interest.","code":""},{"path":"/reference/brm_archetype_cells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell means archetype — brm_archetype_cells","text":"special classed tibble data tailored successive differences archetype. dataset augmented extra columns \"archetype_\" prefix, well special attributes tell downstream functions like brm_formula() object.","code":""},{"path":"/reference/brm_archetype_cells.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cell means archetype — brm_archetype_cells","text":"archetype, fixed effect cell mean: group mean given value treatment group discrete time (subgroup level, applicable).","code":""},{"path":"/reference/brm_archetype_cells.html","id":"prior-labeling-for-brm-archetype-cells-","dir":"Reference","previous_headings":"","what":"Prior labeling for brm_archetype_cells()","title":"Cell means archetype — brm_archetype_cells","text":"Within treatment group, model parameter cell mean, labeling scheme brm_prior_label() brm_prior_archetype() translate easily. example, brm_prior_label(code = \"normal(1.2, 5)\", group = \"B\", time = \"VISIT2\") declares normal(1.2, 5) prior cell mean treatment group B discrete time point VISIT2. confirm set prior correctly, compare brms prior output summary(your_archetype). See examples details.","code":""},{"path":"/reference/brm_archetype_cells.html","id":"nuisance-variables","dir":"Reference","previous_headings":"","what":"Nuisance variables","title":"Cell means archetype — brm_archetype_cells","text":"presence covariate adjustment, functions like brm_archetype_successive_cells() convert nuisance factors binary dummy variables, center dummy variables continuous nuisance variables means data. ensures main model coefficients interest implicitly conditional subset data. words, preprocessing nuisance variables way preserves interpretations fixed effects interest, ensures informative priors can specified correctly.","code":""},{"path":"/reference/brm_archetype_cells.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Cell means archetype — brm_archetype_cells","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_archetype_cells.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell means archetype — brm_archetype_cells","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) dplyr::select(   data,   group,   time,   patient,   starts_with(\"biomarker\"),   starts_with(\"status\") ) #> # A tibble: 600 × 7 #>    group   time   patient     biomarker1 biomarker2 status1 status2 #>    <chr>   <chr>  <chr>            <dbl>      <dbl> <chr>   <chr>   #>  1 group_1 time_2 patient_001     -1.42      -0.287 absent  present #>  2 group_1 time_3 patient_001     -1.42      -0.287 absent  present #>  3 group_1 time_4 patient_001     -1.42      -0.287 absent  present #>  4 group_1 time_2 patient_002     -1.67       1.84  absent  present #>  5 group_1 time_3 patient_002     -1.67       1.84  absent  present #>  6 group_1 time_4 patient_002     -1.67       1.84  absent  present #>  7 group_1 time_2 patient_003      1.38      -0.157 absent  absent  #>  8 group_1 time_3 patient_003      1.38      -0.157 absent  absent  #>  9 group_1 time_4 patient_003      1.38      -0.157 absent  absent  #> 10 group_1 time_2 patient_004     -0.920     -1.39  present present #> # ℹ 590 more rows archetype <- brm_archetype_cells(data) archetype #> # A tibble: 600 × 23 #>    x_group_1_time_2 x_group_1_time_3 x_group_1_time_4 x_group_2_time_2 #>  *            <int>            <int>            <int>            <int> #>  1                1                0                0                0 #>  2                0                1                0                0 #>  3                0                0                1                0 #>  4                1                0                0                0 #>  5                0                1                0                0 #>  6                0                0                1                0 #>  7                1                0                0                0 #>  8                0                1                0                0 #>  9                0                0                1                0 #> 10                1                0                0                0 #> # ℹ 590 more rows #> # ℹ 19 more variables: x_group_2_time_3 <int>, x_group_2_time_4 <int>, #> #   nuisance_biomarker1 <dbl>, nuisance_biomarker2 <dbl>, #> #   nuisance_status1_absent <dbl>, nuisance_status2_present <dbl>, #> #   nuisance_baseline <dbl>, nuisance_baseline.timetime_2 <dbl>, #> #   nuisance_baseline.timetime_3 <dbl>, patient <chr>, time <chr>, group <chr>, #> #   missing <lgl>, change <dbl>, baseline <dbl>, biomarker1 <dbl>, … summary(archetype) #> # This is the \"cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and important fixed effect parameters #> # (right-hand side). Nuisance parameters are omitted. #> #  #> #   group_1:time_2 = x_group_1_time_2 #> #   group_1:time_3 = x_group_1_time_3 #> #   group_1:time_4 = x_group_1_time_4 #> #   group_2:time_2 = x_group_2_time_2 #> #   group_2:time_3 = x_group_2_time_3 #> #   group_2:time_4 = x_group_2_time_4 formula <- brm_formula(archetype) formula #> change ~ 0 + x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 + x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 + nuisance_biomarker1 + nuisance_biomarker2 + nuisance_status1_absent + nuisance_status2_present + nuisance_baseline + nuisance_baseline.timetime_2 + nuisance_baseline.timetime_3 + unstr(time = time, gr = patient)  #> sigma ~ 0 + time prior <- brm_prior_label(   code = \"normal(1, 2.2)\",   group = \"group_1\",   time = \"time_2\" ) |>   brm_prior_label(\"normal(1, 3.3)\", group = \"group_1\", time = \"time_3\") |>   brm_prior_label(\"normal(1, 4.4)\", group = \"group_1\", time = \"time_4\") |>   brm_prior_label(\"normal(2, 2.2)\", group = \"group_2\", time = \"time_2\") |>   brm_prior_label(\"normal(2, 3.3)\", group = \"group_2\", time = \"time_3\") |>   brm_prior_label(\"normal(2, 4.4)\", group = \"group_2\", time = \"time_4\") |>   brm_prior_archetype(archetype) prior #>           prior class             coef group resp dpar nlpar   lb   ub source #>  normal(1, 2.2)     b x_group_1_time_2                       <NA> <NA>   user #>  normal(1, 3.3)     b x_group_1_time_3                       <NA> <NA>   user #>  normal(1, 4.4)     b x_group_1_time_4                       <NA> <NA>   user #>  normal(2, 2.2)     b x_group_2_time_2                       <NA> <NA>   user #>  normal(2, 3.3)     b x_group_2_time_3                       <NA> <NA>   user #>  normal(2, 4.4)     b x_group_2_time_4                       <NA> <NA>   user class(prior) #> [1] \"brmsprior\"  \"data.frame\" if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = archetype,         formula = formula,         prior = prior,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) suppressWarnings(print(model)) brms::prior_summary(model) draws <- brm_marginal_draws(   data = archetype,   formula = formula,   model = model ) summaries_model <- brm_marginal_summaries(draws) summaries_data <- brm_marginal_data(data) brm_plot_compare(model = summaries_model, data = summaries_data) }"},{"path":"/reference/brm_archetype_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Treatment effect archetype — brm_archetype_effects","title":"Treatment effect archetype — brm_archetype_effects","text":"Create informative prior archetype simple treatment effect parameterization.","code":""},{"path":"/reference/brm_archetype_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Treatment effect archetype — brm_archetype_effects","text":"","code":"brm_archetype_effects(   data,   intercept = FALSE,   baseline = !is.null(attr(data, \"brm_baseline\")),   baseline_subgroup = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_subgroup_time = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_time = !is.null(attr(data, \"brm_baseline\")),   covariates = TRUE,   clda = FALSE,   prefix_interest = \"x_\",   prefix_nuisance = \"nuisance_\" )"},{"path":"/reference/brm_archetype_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Treatment effect archetype — brm_archetype_effects","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). intercept TRUE make one parameters intercept, FALSE otherwise. TRUE, interpretation parameters \"Details\" section change, responsible manually calling summary() archetype interpreting parameters according output. addition, responsible setting appropriate prior intercept. normal usage, brms looks model parameter called \"Intercept\" uses data set prior help MCMC runs smoothly. intercept = TRUE informative prior archetypes, intercept called something else, brms auto-generate sensible default prior. baseline Logical length 1. TRUE include additive effect baseline response, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_subgroup Logical length 1. baseline_subgroup_time Logical length 1. TRUE include baseline--subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline subgroup variables dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_time Logical length 1. TRUE include baseline--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. covariates Logical length 1. TRUE (default) include additive covariates declared covariates argument brm_data(), FALSE omit. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. clda TRUE opt constrained longitudinal data analysis (cLDA), FALSE otherwise. use cLDA, reference_time must non-NULL call brm_data() used construct data. archetypes support cLDA (e.g. brm_archetype_average_cells() brm_archetype_average_effects()). cLDA, fixed effects parameterization restricted treatment groups pooled baseline. (supplied subgroup variable brm_data(), constraint applied separately within subgroup variable.) cLDA may result precise estimates time variable baseline level baseline outcomes recorded randomization clinical trial. prefix_interest Character string prepend new columns generated fixed effects interest (relating group, subgroup, /time). rare cases, may need set non-default prefix prevent name conflicts existing columns data, rename columns data. prefix_interest must value prefix_nuisance. prefix_nuisance prefix_interest, relating generated fixed effects interest (relating group, subgroup, time). Must value prefix_interest.","code":""},{"path":"/reference/brm_archetype_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Treatment effect archetype — brm_archetype_effects","text":"special classed tibble data tailored successive differences archetype. dataset augmented extra columns \"archetype_\" prefix, well special attributes tell downstream functions like brm_formula() object.","code":""},{"path":"/reference/brm_archetype_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Treatment effect archetype — brm_archetype_effects","text":"archetype, fixed effect either placebo response treatment effect. illustrate, suppose dataset two treatment groups B, time points 1, 2, 3, covariates. Assume group reference group (e.g. placebo). Let mu_gt marginal mean response group g time t given data hyperparameters. model fixed effect parameters beta_1, beta_2, ..., beta_6 express marginal means mu_gt follows:   , beta_2 group mean treatment group time 2, beta_5 treatment effect B relative time 2.","code":"`mu_A1 = beta_1`   `mu_A2 = beta_2`   `mu_A3 = beta_3`    `mu_B1 = beta_1 + beta_4`   `mu_B2 = beta_2 + beta_5`   `mu_B3 = beta_3 + beta_6`"},{"path":"/reference/brm_archetype_effects.html","id":"prior-labeling-for-brm-archetype-effects-","dir":"Reference","previous_headings":"","what":"Prior labeling for brm_archetype_effects()","title":"Treatment effect archetype — brm_archetype_effects","text":"reference group (e.g. placebo) fixed effect cell mean time point. non-reference group, fixed effect treatment effect relative reference (time point). labeling scheme brm_prior_label() brm_prior_archetype() translate straightforwardly. example, brm_prior_label(code = \"normal(1.2, 5)\", group = \"\", time = \"2\") declares normal(1.2, 5) beta_2 (cell mean reference group time 2). Similarly, brm_prior_label(code = \"normal(1.3, 6)\", group = \"B\", time = \"2\") declares normal(1.3, 6) prior treatment effect group B relative group discrete time point 2. confirm set prior correctly, compare brms prior output summary(your_archetype). See examples details.","code":""},{"path":"/reference/brm_archetype_effects.html","id":"nuisance-variables","dir":"Reference","previous_headings":"","what":"Nuisance variables","title":"Treatment effect archetype — brm_archetype_effects","text":"presence covariate adjustment, functions like brm_archetype_successive_cells() convert nuisance factors binary dummy variables, center dummy variables continuous nuisance variables means data. ensures main model coefficients interest implicitly conditional subset data. words, preprocessing nuisance variables way preserves interpretations fixed effects interest, ensures informative priors can specified correctly.","code":""},{"path":"/reference/brm_archetype_effects.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Treatment effect archetype — brm_archetype_effects","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_archetype_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Treatment effect archetype — brm_archetype_effects","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) dplyr::select(   data,   group,   time,   patient,   starts_with(\"biomarker\"),   starts_with(\"status\") ) #> # A tibble: 600 × 7 #>    group   time   patient     biomarker1 biomarker2 status1 status2 #>    <chr>   <chr>  <chr>            <dbl>      <dbl> <chr>   <chr>   #>  1 group_1 time_2 patient_001     -1.42      -0.287 absent  present #>  2 group_1 time_3 patient_001     -1.42      -0.287 absent  present #>  3 group_1 time_4 patient_001     -1.42      -0.287 absent  present #>  4 group_1 time_2 patient_002     -1.67       1.84  absent  present #>  5 group_1 time_3 patient_002     -1.67       1.84  absent  present #>  6 group_1 time_4 patient_002     -1.67       1.84  absent  present #>  7 group_1 time_2 patient_003      1.38      -0.157 absent  absent  #>  8 group_1 time_3 patient_003      1.38      -0.157 absent  absent  #>  9 group_1 time_4 patient_003      1.38      -0.157 absent  absent  #> 10 group_1 time_2 patient_004     -0.920     -1.39  present present #> # ℹ 590 more rows archetype <- brm_archetype_effects(data) archetype #> # A tibble: 600 × 23 #>    x_group_1_time_2 x_group_1_time_3 x_group_1_time_4 x_group_2_time_2 #>  *            <int>            <int>            <int>            <int> #>  1                1                0                0                0 #>  2                0                1                0                0 #>  3                0                0                1                0 #>  4                1                0                0                0 #>  5                0                1                0                0 #>  6                0                0                1                0 #>  7                1                0                0                0 #>  8                0                1                0                0 #>  9                0                0                1                0 #> 10                1                0                0                0 #> # ℹ 590 more rows #> # ℹ 19 more variables: x_group_2_time_3 <int>, x_group_2_time_4 <int>, #> #   nuisance_biomarker1 <dbl>, nuisance_biomarker2 <dbl>, #> #   nuisance_status1_absent <dbl>, nuisance_status2_present <dbl>, #> #   nuisance_baseline <dbl>, nuisance_baseline.timetime_2 <dbl>, #> #   nuisance_baseline.timetime_3 <dbl>, patient <chr>, time <chr>, group <chr>, #> #   missing <lgl>, change <dbl>, baseline <dbl>, biomarker1 <dbl>, … summary(archetype) #> # This is the \"effects\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and important fixed effect parameters #> # (right-hand side). Nuisance parameters are omitted. #> #  #> #   group_1:time_2 = x_group_1_time_2 #> #   group_1:time_3 = x_group_1_time_3 #> #   group_1:time_4 = x_group_1_time_4 #> #   group_2:time_2 = x_group_1_time_2 + x_group_2_time_2 #> #   group_2:time_3 = x_group_1_time_3 + x_group_2_time_3 #> #   group_2:time_4 = x_group_1_time_4 + x_group_2_time_4 formula <- brm_formula(archetype) formula #> change ~ 0 + x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 + x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 + nuisance_biomarker1 + nuisance_biomarker2 + nuisance_status1_absent + nuisance_status2_present + nuisance_baseline + nuisance_baseline.timetime_2 + nuisance_baseline.timetime_3 + unstr(time = time, gr = patient)  #> sigma ~ 0 + time prior <- brm_prior_label(   code = \"normal(1, 2.2)\",   group = \"group_1\",   time = \"time_2\" ) |>   brm_prior_label(\"normal(1, 3.3)\", group = \"group_1\", time = \"time_3\") |>   brm_prior_label(\"normal(1, 4.4)\", group = \"group_1\", time = \"time_4\") |>   brm_prior_label(\"normal(2, 2.2)\", group = \"group_2\", time = \"time_2\") |>   brm_prior_label(\"normal(2, 3.3)\", group = \"group_2\", time = \"time_3\") |>   brm_prior_label(\"normal(2, 4.4)\", group = \"group_2\", time = \"time_4\") |>   brm_prior_archetype(archetype) prior #>           prior class             coef group resp dpar nlpar   lb   ub source #>  normal(1, 2.2)     b x_group_1_time_2                       <NA> <NA>   user #>  normal(1, 3.3)     b x_group_1_time_3                       <NA> <NA>   user #>  normal(1, 4.4)     b x_group_1_time_4                       <NA> <NA>   user #>  normal(2, 2.2)     b x_group_2_time_2                       <NA> <NA>   user #>  normal(2, 3.3)     b x_group_2_time_3                       <NA> <NA>   user #>  normal(2, 4.4)     b x_group_2_time_4                       <NA> <NA>   user class(prior) #> [1] \"brmsprior\"  \"data.frame\" if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = archetype,         formula = formula,         prior = prior,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) suppressWarnings(print(model)) brms::prior_summary(model) draws <- brm_marginal_draws(   data = archetype,   formula = formula,   model = model ) summaries_model <- brm_marginal_summaries(draws) summaries_data <- brm_marginal_data(data) brm_plot_compare(model = summaries_model, data = summaries_data) }"},{"path":"/reference/brm_archetype_successive_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"Create informative prior archetype fixed effects successive differences adjacent time points.","code":""},{"path":"/reference/brm_archetype_successive_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"","code":"brm_archetype_successive_cells(   data,   intercept = FALSE,   baseline = !is.null(attr(data, \"brm_baseline\")),   baseline_subgroup = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_subgroup_time = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_time = !is.null(attr(data, \"brm_baseline\")),   covariates = TRUE,   clda = FALSE,   prefix_interest = \"x_\",   prefix_nuisance = \"nuisance_\" )"},{"path":"/reference/brm_archetype_successive_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). intercept TRUE make one parameters intercept, FALSE otherwise. TRUE, interpretation parameters \"Details\" section change, responsible manually calling summary() archetype interpreting parameters according output. addition, responsible setting appropriate prior intercept. normal usage, brms looks model parameter called \"Intercept\" uses data set prior help MCMC runs smoothly. intercept = TRUE informative prior archetypes, intercept called something else, brms auto-generate sensible default prior. baseline Logical length 1. TRUE include additive effect baseline response, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_subgroup Logical length 1. baseline_subgroup_time Logical length 1. TRUE include baseline--subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline subgroup variables dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_time Logical length 1. TRUE include baseline--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. covariates Logical length 1. TRUE (default) include additive covariates declared covariates argument brm_data(), FALSE omit. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. clda TRUE opt constrained longitudinal data analysis (cLDA), FALSE otherwise. use cLDA, reference_time must non-NULL call brm_data() used construct data. archetypes support cLDA (e.g. brm_archetype_average_cells() brm_archetype_average_effects()). cLDA, fixed effects parameterization restricted treatment groups pooled baseline. (supplied subgroup variable brm_data(), constraint applied separately within subgroup variable.) cLDA may result precise estimates time variable baseline level baseline outcomes recorded randomization clinical trial. prefix_interest Character string prepend new columns generated fixed effects interest (relating group, subgroup, /time). rare cases, may need set non-default prefix prevent name conflicts existing columns data, rename columns data. prefix_interest must value prefix_nuisance. prefix_nuisance prefix_interest, relating generated fixed effects interest (relating group, subgroup, time). Must value prefix_interest.","code":""},{"path":"/reference/brm_archetype_successive_cells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"special classed tibble data tailored successive differences archetype. dataset augmented extra columns \"archetype_\" prefix, well special attributes tell downstream functions like brm_formula() object.","code":""},{"path":"/reference/brm_archetype_successive_cells.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"archetype, fixed effect either intercept first time point difference two adjacent time points, treatment group set fixed effects independent treatment groups. illustrate, suppose dataset two treatment groups B, time points 1, 2, 3, covariates. Let mu_gt marginal mean response group g time t given data hyperparameters. model fixed effect parameters beta_1, beta_2, ..., beta_6 express marginal means mu_gt follows:   group , beta_1 time 1 intercept, beta_2 represents time 2 minus time 1, beta_3 represents time 3 minus time 2. beta_4, beta_5, beta_6 behave analogously group B.","code":"`mu_A1 = beta_1`   `mu_A2 = beta_1 + beta_2`   `mu_A3 = beta_1 + beta_2 + beta_3`    `mu_B1 = beta_4`   `mu_B2 = beta_4 + beta_5`   `mu_B3 = beta_4 + beta_5 + beta_6`"},{"path":"/reference/brm_archetype_successive_cells.html","id":"nuisance-variables","dir":"Reference","previous_headings":"","what":"Nuisance variables","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"presence covariate adjustment, functions like brm_archetype_successive_cells() convert nuisance factors binary dummy variables, center dummy variables continuous nuisance variables means data. ensures main model coefficients interest implicitly conditional subset data. words, preprocessing nuisance variables way preserves interpretations fixed effects interest, ensures informative priors can specified correctly.","code":""},{"path":"/reference/brm_archetype_successive_cells.html","id":"prior-labeling-for-brm-archetype-successive-cells-","dir":"Reference","previous_headings":"","what":"Prior labeling for brm_archetype_successive_cells()","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"Within treatment group, intercept labeled earliest time point, successive difference term gets successive time point label. illustrate, consider example Details section. labeling scheme brm_archetype_successive_cells(), can label prior beta_1 using brm_prior_label(code = \"normal(1.2, 5)\", group = \"\", time = \"1\"). Similarly, cal label prior beta_5 brm_prior_label(code = \"normal(1.3, 7)\", group = \"B\", time = \"2\"). confirm set prior correctly, compare brms prior output summary(your_archetype). See examples details.","code":""},{"path":"/reference/brm_archetype_successive_cells.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_archetype_successive_cells.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell-means-like successive differences archetype — brm_archetype_successive_cells","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) dplyr::select(   data,   group,   time,   patient,   starts_with(\"biomarker\"),   starts_with(\"status\") ) #> # A tibble: 600 × 7 #>    group   time   patient     biomarker1 biomarker2 status1 status2 #>    <chr>   <chr>  <chr>            <dbl>      <dbl> <chr>   <chr>   #>  1 group_1 time_2 patient_001     -1.42      -0.287 absent  present #>  2 group_1 time_3 patient_001     -1.42      -0.287 absent  present #>  3 group_1 time_4 patient_001     -1.42      -0.287 absent  present #>  4 group_1 time_2 patient_002     -1.67       1.84  absent  present #>  5 group_1 time_3 patient_002     -1.67       1.84  absent  present #>  6 group_1 time_4 patient_002     -1.67       1.84  absent  present #>  7 group_1 time_2 patient_003      1.38      -0.157 absent  absent  #>  8 group_1 time_3 patient_003      1.38      -0.157 absent  absent  #>  9 group_1 time_4 patient_003      1.38      -0.157 absent  absent  #> 10 group_1 time_2 patient_004     -0.920     -1.39  present present #> # ℹ 590 more rows archetype <- brm_archetype_successive_cells(data) archetype #> # A tibble: 600 × 23 #>    x_group_1_time_2 x_group_1_time_3 x_group_1_time_4 x_group_2_time_2 #>  *            <dbl>            <dbl>            <dbl>            <dbl> #>  1                1                0                0                0 #>  2                1                1                0                0 #>  3                1                1                1                0 #>  4                1                0                0                0 #>  5                1                1                0                0 #>  6                1                1                1                0 #>  7                1                0                0                0 #>  8                1                1                0                0 #>  9                1                1                1                0 #> 10                1                0                0                0 #> # ℹ 590 more rows #> # ℹ 19 more variables: x_group_2_time_3 <dbl>, x_group_2_time_4 <dbl>, #> #   nuisance_biomarker1 <dbl>, nuisance_biomarker2 <dbl>, #> #   nuisance_status1_absent <dbl>, nuisance_status2_present <dbl>, #> #   nuisance_baseline <dbl>, nuisance_baseline.timetime_2 <dbl>, #> #   nuisance_baseline.timetime_3 <dbl>, patient <chr>, time <chr>, group <chr>, #> #   missing <lgl>, change <dbl>, baseline <dbl>, biomarker1 <dbl>, … summary(archetype) #> # This is the \"successive cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and important fixed effect parameters #> # (right-hand side). Nuisance parameters are omitted. #> #  #> #   group_1:time_2 = x_group_1_time_2 #> #   group_1:time_3 = x_group_1_time_2 + x_group_1_time_3 #> #   group_1:time_4 = x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 #> #   group_2:time_2 = x_group_2_time_2 #> #   group_2:time_3 = x_group_2_time_2 + x_group_2_time_3 #> #   group_2:time_4 = x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 formula <- brm_formula(archetype) formula #> change ~ 0 + x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 + x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 + nuisance_biomarker1 + nuisance_biomarker2 + nuisance_status1_absent + nuisance_status2_present + nuisance_baseline + nuisance_baseline.timetime_2 + nuisance_baseline.timetime_3 + unstr(time = time, gr = patient)  #> sigma ~ 0 + time prior <- brm_prior_label(   code = \"normal(1, 2.2)\",   group = \"group_1\",   time = \"time_2\" ) |>   brm_prior_label(\"normal(1, 3.3)\", group = \"group_1\", time = \"time_3\") |>   brm_prior_label(\"normal(1, 4.4)\", group = \"group_1\", time = \"time_4\") |>   brm_prior_label(\"normal(2, 2.2)\", group = \"group_2\", time = \"time_2\") |>   brm_prior_label(\"normal(2, 3.3)\", group = \"group_2\", time = \"time_3\") |>   brm_prior_label(\"normal(2, 4.4)\", group = \"group_2\", time = \"time_4\") |>   brm_prior_archetype(archetype) prior #>           prior class             coef group resp dpar nlpar   lb   ub source #>  normal(1, 2.2)     b x_group_1_time_2                       <NA> <NA>   user #>  normal(1, 3.3)     b x_group_1_time_3                       <NA> <NA>   user #>  normal(1, 4.4)     b x_group_1_time_4                       <NA> <NA>   user #>  normal(2, 2.2)     b x_group_2_time_2                       <NA> <NA>   user #>  normal(2, 3.3)     b x_group_2_time_3                       <NA> <NA>   user #>  normal(2, 4.4)     b x_group_2_time_4                       <NA> <NA>   user class(prior) #> [1] \"brmsprior\"  \"data.frame\" if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = archetype,         formula = formula,         prior = prior,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) suppressWarnings(print(model)) brms::prior_summary(model) draws <- brm_marginal_draws(   data = archetype,   formula = formula,   model = model ) summaries_model <- brm_marginal_summaries(draws) summaries_data <- brm_marginal_data(data) brm_plot_compare(model = summaries_model, data = summaries_data) }"},{"path":"/reference/brm_archetype_successive_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"Create informative prior archetype fixed effects successive differences adjacent time points terms non-reference groups treatment effects.","code":""},{"path":"/reference/brm_archetype_successive_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"","code":"brm_archetype_successive_effects(   data,   intercept = FALSE,   baseline = !is.null(attr(data, \"brm_baseline\")),   baseline_subgroup = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_subgroup_time = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_time = !is.null(attr(data, \"brm_baseline\")),   covariates = TRUE,   clda = FALSE,   prefix_interest = \"x_\",   prefix_nuisance = \"nuisance_\" )"},{"path":"/reference/brm_archetype_successive_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). intercept Logical length 1. TRUE (default) include intercept, FALSE omit. baseline Logical length 1. TRUE include additive effect baseline response, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_subgroup Logical length 1. baseline_subgroup_time Logical length 1. TRUE include baseline--subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline subgroup variables dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_time Logical length 1. TRUE include baseline--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. covariates Logical length 1. TRUE (default) include additive covariates declared covariates argument brm_data(), FALSE omit. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. clda TRUE opt constrained longitudinal data analysis (cLDA), FALSE otherwise. use cLDA, reference_time must non-NULL call brm_data() used construct data. archetypes support cLDA (e.g. brm_archetype_average_cells() brm_archetype_average_effects()). cLDA, fixed effects parameterization restricted treatment groups pooled baseline. (supplied subgroup variable brm_data(), constraint applied separately within subgroup variable.) cLDA may result precise estimates time variable baseline level baseline outcomes recorded randomization clinical trial. prefix_interest Character string prepend new columns generated fixed effects interest (relating group, subgroup, /time). rare cases, may need set non-default prefix prevent name conflicts existing columns data, rename columns data. prefix_interest must value prefix_nuisance. prefix_nuisance prefix_interest, relating generated fixed effects interest (relating group, subgroup, time). Must value prefix_interest.","code":""},{"path":"/reference/brm_archetype_successive_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"special classed tibble data tailored successive differences archetype. dataset augmented extra columns \"archetype_\" prefix, well special attributes tell downstream functions like brm_formula() object.","code":""},{"path":"/reference/brm_archetype_successive_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"Within reference treatment group (e.g. placebo), fixed effect either intercept first time point difference two adjacent time points. non-reference treatment group, model parameter defined effect relative reference group. illustrate, suppose dataset two treatment groups B, time points 1, 2, 3, covariates. Say group reference group (e.g. placebo). Let mu_gt marginal mean response group g time t given data hyperparameters. model fixed effect parameters beta_1, beta_2, ..., beta_6 express marginal means mu_gt follows:   group , beta_1 time 1 intercept, beta_2 represents time 2 minus time 1, beta_3 represents time 3 minus time 2. beta_4 treatment effect group B relative group time 1. beta_5 treatment effect difference times 2 1, relative treatment group . Similarly, beta_6 treatment effect difference times 3 2, relative treatment group .","code":"`mu_A1 = beta_1`   `mu_A2 = beta_1 + beta_2`   `mu_A3 = beta_1 + beta_2 + beta_3`    `mu_B1 = beta_1 + beta_4`   `mu_B2 = beta_1 + beta_2 + beta_4 + beta_5`   `mu_B3 = beta_1 + beta_2 + beta_3 + beta_4 + beta_5 + beta_6`"},{"path":"/reference/brm_archetype_successive_effects.html","id":"prior-labeling-for-brm-archetype-successive-effects-","dir":"Reference","previous_headings":"","what":"Prior labeling for brm_archetype_successive_effects()","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"Within treatment group, intercept labeled earliest time point, successive difference term gets successive time point label. illustrate, consider example Details section. labeling scheme brm_archetype_successive_effects(), can label prior beta_1 using brm_prior_label(code = \"normal(1.2, 5)\", group = \"\", time = \"1\"). Similarly, cal label prior beta_5 brm_prior_label(code = \"normal(1.3, 7)\", group = \"B\", time = \"2\"). confirm set prior correctly, compare brms prior output summary(your_archetype). See examples details.","code":""},{"path":"/reference/brm_archetype_successive_effects.html","id":"nuisance-variables","dir":"Reference","previous_headings":"","what":"Nuisance variables","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"presence covariate adjustment, functions like brm_archetype_successive_cells() convert nuisance factors binary dummy variables, center dummy variables continuous nuisance variables means data. ensures main model coefficients interest implicitly conditional subset data. words, preprocessing nuisance variables way preserves interpretations fixed effects interest, ensures informative priors can specified correctly.","code":""},{"path":"/reference/brm_archetype_successive_effects.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_archetype_successive_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Treatment-effect-like successive differences archetype — brm_archetype_successive_effects","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) dplyr::select(   data,   group,   time,   patient,   starts_with(\"biomarker\"),   starts_with(\"status\") ) #> # A tibble: 600 × 7 #>    group   time   patient     biomarker1 biomarker2 status1 status2 #>    <chr>   <chr>  <chr>            <dbl>      <dbl> <chr>   <chr>   #>  1 group_1 time_2 patient_001     -1.42      -0.287 absent  present #>  2 group_1 time_3 patient_001     -1.42      -0.287 absent  present #>  3 group_1 time_4 patient_001     -1.42      -0.287 absent  present #>  4 group_1 time_2 patient_002     -1.67       1.84  absent  present #>  5 group_1 time_3 patient_002     -1.67       1.84  absent  present #>  6 group_1 time_4 patient_002     -1.67       1.84  absent  present #>  7 group_1 time_2 patient_003      1.38      -0.157 absent  absent  #>  8 group_1 time_3 patient_003      1.38      -0.157 absent  absent  #>  9 group_1 time_4 patient_003      1.38      -0.157 absent  absent  #> 10 group_1 time_2 patient_004     -0.920     -1.39  present present #> # ℹ 590 more rows archetype <- brm_archetype_successive_effects(data) archetype #> # A tibble: 600 × 23 #>    x_group_1_time_2 x_group_1_time_3 x_group_1_time_4 x_group_2_time_2 #>  *            <dbl>            <dbl>            <dbl>            <dbl> #>  1                1                0                0                0 #>  2                1                1                0                0 #>  3                1                1                1                0 #>  4                1                0                0                0 #>  5                1                1                0                0 #>  6                1                1                1                0 #>  7                1                0                0                0 #>  8                1                1                0                0 #>  9                1                1                1                0 #> 10                1                0                0                0 #> # ℹ 590 more rows #> # ℹ 19 more variables: x_group_2_time_3 <dbl>, x_group_2_time_4 <dbl>, #> #   nuisance_biomarker1 <dbl>, nuisance_biomarker2 <dbl>, #> #   nuisance_status1_absent <dbl>, nuisance_status2_present <dbl>, #> #   nuisance_baseline <dbl>, nuisance_baseline.timetime_2 <dbl>, #> #   nuisance_baseline.timetime_3 <dbl>, patient <chr>, time <chr>, group <chr>, #> #   missing <lgl>, change <dbl>, baseline <dbl>, biomarker1 <dbl>, … summary(archetype) #> # This is the \"successive effects\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and important fixed effect parameters #> # (right-hand side). Nuisance parameters are omitted. #> #  #> #   group_1:time_2 = x_group_1_time_2 #> #   group_1:time_3 = x_group_1_time_2 + x_group_1_time_3 #> #   group_1:time_4 = x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 #> #   group_2:time_2 = x_group_1_time_2 + x_group_2_time_2 #> #   group_2:time_3 = x_group_1_time_2 + x_group_1_time_3 + x_group_2_time_2 + x_group_2_time_3 #> #   group_2:time_4 = x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 + x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 formula <- brm_formula(archetype) formula #> change ~ 0 + x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 + x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 + nuisance_biomarker1 + nuisance_biomarker2 + nuisance_status1_absent + nuisance_status2_present + nuisance_baseline + nuisance_baseline.timetime_2 + nuisance_baseline.timetime_3 + unstr(time = time, gr = patient)  #> sigma ~ 0 + time prior <- brm_prior_label(   code = \"normal(1, 2.2)\",   group = \"group_1\",   time = \"time_2\" ) |>   brm_prior_label(\"normal(1, 3.3)\", group = \"group_1\", time = \"time_3\") |>   brm_prior_label(\"normal(1, 4.4)\", group = \"group_1\", time = \"time_4\") |>   brm_prior_label(\"normal(2, 2.2)\", group = \"group_2\", time = \"time_2\") |>   brm_prior_label(\"normal(2, 3.3)\", group = \"group_2\", time = \"time_3\") |>   brm_prior_label(\"normal(2, 4.4)\", group = \"group_2\", time = \"time_4\") |>   brm_prior_archetype(archetype) prior #>           prior class             coef group resp dpar nlpar   lb   ub source #>  normal(1, 2.2)     b x_group_1_time_2                       <NA> <NA>   user #>  normal(1, 3.3)     b x_group_1_time_3                       <NA> <NA>   user #>  normal(1, 4.4)     b x_group_1_time_4                       <NA> <NA>   user #>  normal(2, 2.2)     b x_group_2_time_2                       <NA> <NA>   user #>  normal(2, 3.3)     b x_group_2_time_3                       <NA> <NA>   user #>  normal(2, 4.4)     b x_group_2_time_4                       <NA> <NA>   user class(prior) #> [1] \"brmsprior\"  \"data.frame\" if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = archetype,         formula = formula,         prior = prior,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) suppressWarnings(print(model)) brms::prior_summary(model) draws <- brm_marginal_draws(   data = archetype,   formula = formula,   model = model ) summaries_model <- brm_marginal_summaries(draws) summaries_data <- brm_marginal_data(data) brm_plot_compare(model = summaries_model, data = summaries_data) }"},{"path":"/reference/brm_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create and preprocess an MMRM dataset. — brm_data","title":"Create and preprocess an MMRM dataset. — brm_data","text":"Create dataset analyze MMRM.","code":""},{"path":"/reference/brm_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create and preprocess an MMRM dataset. — brm_data","text":"","code":"brm_data(   data,   outcome,   baseline = NULL,   group,   subgroup = NULL,   time,   patient,   covariates = character(0L),   missing = NULL,   reference_group,   reference_subgroup = NULL,   reference_time = NULL,   role = NULL,   level_baseline = NULL,   level_control = NULL )"},{"path":"/reference/brm_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create and preprocess an MMRM dataset. — brm_data","text":"data Data frame tibble longitudinal data. outcome Character length 1, name continuous outcome variable. Example possibilities clinical trial datasets include \"CHG\" \"AVAL\". outcome column data numeric vector. baseline Character length 1, name baseline response variable (example, \"BASE\" many clinical trial datasets). relevant response variable change baseline. Supply NULL ignore omit. group Character length 1, name treatment group variable. Example possibilities clinical trial datasets include \"TRT01P\", \"TREATMENT\", \"TRT\", \"GROUP\". group column data character vector unordered factor. subgroup Character length 1, optional name discrete subgroup variable. Set NULL omit subgroup (default). present, subgroup column data character vector unordered factor. time Character length 1, name discrete time variable. Example possibilities clinical trial datasets include \"AVISIT\" \"VISIT\". analyses, please ensure time column data ordered factor. can easily turn time variable ordered factor using brm_data_chronologize(), either immediately brm_data() (brm_archetype_*() functions). ensures time points sort chronological order, ensures correctness informative prior archetypes autoregressive / moving average correlation structures. Ordinarily, ordered factors automatically use polynomial contrasts contr.poly(). undesirable MMRMs, time variable ordered factor, brm_data() manually sets contrasts(data[[time]]) set treatment contrasts using contr.treatment(). prefer different contrasts, please manually set contrasts(data[[time]]) something else calling brm_data(). patient Character length 1, name patient ID variable. Example possibilities clinical trial datasets include \"USUBJID\", \"SUBJID\", \"PATIENT\", \"PATIENTID\", \"SUBJECT\", \"SUBJIDID\", \"SBJID\", \"STYSID1A\", \"SBJ1N\", \"ID\". patient column data factor character vector. covariates Character vector names covariates. covariates assumed non-time-varying. time-varying covariates, please manually expand data full grid patients time points call brm_data(). See \"Preprocessing\" section details. missing Character length 1, name optional variable simulated dataset indicate outcome values missing. Set NULL omit. reference_group Atomic value length 1, Level group column indicate control group. Example possibilities clinical trial datasets include \"Placebo\", \"PLACEBO\", \"PBO\", \"PLB\", \"CONTROL\", \"CTRL\", \"REFERENCE\", \"REF\". reference_group applies post-processing happens functions like brm_marginal_draws() downstream model. control fixed effect mapping model matrix brms derives formula brm_formula(). reference_subgroup Atomic value length 1, level subgroup column use reference pairwise differences computing marginal means downstream model. control fixed effect mapping model matrix brms derives formula brm_formula(). reference_time Atomic value length 1 NULL, level time column indicate baseline time point. Leave NULL baseline baseline included data[[time]]. reference_time NULL, brm_marginal_draws() calculate change baseline, calculate treatment differences differences change--baseline values. reference_time NULL, brm_marginal_draws() calculate change baseline, calculate treatment differences differences response values. Note: reference_time applies post-processing happens functions like brm_marginal_draws() downstream model. control fixed effect mapping model matrix brms derives formula brm_formula(). role Deprecated unnecessary 2024-07-11 (version 1.0.1.9007). Use reference_time supply baseline time point value exists. level_baseline Deprecated 2024-01-11 (version 0.2.0.9002). Use reference_time instead. level_control Deprecated 2024-01-11 (version 0.2.0.9002). Use reference_group instead.","code":""},{"path":"/reference/brm_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create and preprocess an MMRM dataset. — brm_data","text":"classed tibble attributes denote features data treatment group discrete time variables.","code":""},{"path":"/reference/brm_data.html","id":"preprocessing","dir":"Reference","previous_headings":"","what":"Preprocessing","title":"Create and preprocess an MMRM dataset. — brm_data","text":"preprocessing steps brm_data() follows: Perform basic assertions make sure data arguments properly formatted. Convert group time columns character vectors. Sanitize levels group time columns using make.names(unique = FALSE, allow_ = TRUE) ensure agreement data output brms. implicitly missing outcome observation, add explicit row outcome variable equal NA_real_. Missing values predictors implicitly filled using zoo::na.locf() within patient, valid time-varying covariates. covariates time-varying, please manually perform step calling brm_data(). Arrange rows data group, patient, discrete time. Select columns data relevant MMRM analysis.","code":""},{"path":"/reference/brm_data.html","id":"separation-string","dir":"Reference","previous_headings":"","what":"Separation string","title":"Create and preprocess an MMRM dataset. — brm_data","text":"Post-processing brm_marginal_draws() names group--time marginal means delimiting character string Sys.getenv(\"BRM_SEP\", unset = \"|\"). Neither column names element names group time variables can contain string. set custom string , use Sys.setenv(BRM_SEP = \"YOUR_CUSTOM_STRING\").","code":""},{"path":[]},{"path":"/reference/brm_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create and preprocess an MMRM dataset. — brm_data","text":"","code":"set.seed(0) data <- brm_simulate_simple()$data colnames(data) <- paste0(\"col_\", colnames(data)) data #> # A tibble: 800 × 4 #>    col_patient col_time col_response col_group #>    <chr>       <chr>           <dbl> <chr>     #>  1 patient_001 time_1          1.47  group_1   #>  2 patient_001 time_2          3.10  group_1   #>  3 patient_001 time_3          2.22  group_1   #>  4 patient_001 time_4          0.215 group_1   #>  5 patient_002 time_1          1.03  group_1   #>  6 patient_002 time_2          2.28  group_1   #>  7 patient_002 time_3          2.36  group_1   #>  8 patient_002 time_4          2.33  group_1   #>  9 patient_003 time_1          0.128 group_1   #> 10 patient_003 time_2          1.89  group_1   #> # ℹ 790 more rows brm_data(   data = data,   outcome = \"col_response\",   group = \"col_group\",   time = \"col_time\",   patient = \"col_patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) #> # A tibble: 800 × 4 #>    col_patient col_time col_response col_group #>    <chr>       <chr>           <dbl> <chr>     #>  1 patient_001 time_1          1.47  group_1   #>  2 patient_001 time_2          3.10  group_1   #>  3 patient_001 time_3          2.22  group_1   #>  4 patient_001 time_4          0.215 group_1   #>  5 patient_002 time_1          1.03  group_1   #>  6 patient_002 time_2          2.28  group_1   #>  7 patient_002 time_3          2.36  group_1   #>  8 patient_002 time_4          2.33  group_1   #>  9 patient_003 time_1          0.128 group_1   #> 10 patient_003 time_2          1.89  group_1   #> # ℹ 790 more rows"},{"path":"/reference/brm_data_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to change from baseline. — brm_data_change","title":"Convert to change from baseline. — brm_data_change","text":"Convert dataset raw response change baseline.","code":""},{"path":"/reference/brm_data_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to change from baseline. — brm_data_change","text":"","code":"brm_data_change(data, name_change = \"change\", name_baseline = \"baseline\")"},{"path":"/reference/brm_data_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to change from baseline. — brm_data_change","text":"data classed tibble (e.g. brm_data()) raw response outcome variable baseline time point stored attributes. name_change Character length 1, name new outcome column change baseline. name_baseline Character length 1, name new column original baseline response.","code":""},{"path":"/reference/brm_data_change.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to change from baseline. — brm_data_change","text":"classed tibble change baseline outcome variable internal attributes modified accordingly. special baseline column also created, original raw response column removed. new baseline column comprised elements response variable corresponding reference_time argument brm_data(). column denote missing values simulation purposes, e.g. \"missing\" column generated brm_simulate_outline(), missing baseline values propagated accordingly change baseline missing either post-baseline response missing baseline response missing.","code":""},{"path":[]},{"path":"/reference/brm_data_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to change from baseline. — brm_data_change","text":"","code":"set.seed(0) data <- brm_data(   data = dplyr::rename(brm_simulate_simple()$data, y_values = response),   outcome = \"y_values\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) data #> # A tibble: 800 × 4 #>    patient     time   y_values group   #>    <chr>       <chr>     <dbl> <chr>   #>  1 patient_001 time_1    1.47  group_1 #>  2 patient_001 time_2    3.10  group_1 #>  3 patient_001 time_3    2.22  group_1 #>  4 patient_001 time_4    0.215 group_1 #>  5 patient_002 time_1    1.03  group_1 #>  6 patient_002 time_2    2.28  group_1 #>  7 patient_002 time_3    2.36  group_1 #>  8 patient_002 time_4    2.33  group_1 #>  9 patient_003 time_1    0.128 group_1 #> 10 patient_003 time_2    1.89  group_1 #> # ℹ 790 more rows attr(data, \"brm_outcome\") #> [1] \"y_values\" attr(data, \"brm_baseline\") #> NULL attr(data, \"brm_reference_time\") #> [1] \"time_1\" changed <- brm_data_change(data = data, name_change = \"delta\") changed #> # A tibble: 600 × 5 #>    patient     time   group    delta baseline #>    <chr>       <chr>  <chr>    <dbl>    <dbl> #>  1 patient_001 time_2 group_1  1.63     1.47  #>  2 patient_001 time_3 group_1  0.750    1.47  #>  3 patient_001 time_4 group_1 -1.25     1.47  #>  4 patient_002 time_2 group_1  1.25     1.03  #>  5 patient_002 time_3 group_1  1.33     1.03  #>  6 patient_002 time_4 group_1  1.29     1.03  #>  7 patient_003 time_2 group_1  1.76     0.128 #>  8 patient_003 time_3 group_1  2.37     0.128 #>  9 patient_003 time_4 group_1  1.27     0.128 #> 10 patient_004 time_2 group_1  1.46     1.22  #> # ℹ 590 more rows attr(changed, \"brm_outcome\") #> [1] \"delta\" attr(changed, \"brm_baseline\") #> [1] \"baseline\" attr(data, \"brm_reference_time\") #> [1] \"time_1\""},{"path":"/reference/brm_data_chronologize.html","id":null,"dir":"Reference","previous_headings":"","what":"Chronologize a dataset — brm_data_chronologize","title":"Chronologize a dataset — brm_data_chronologize","text":"Convert discrete time variable ordered factor.","code":""},{"path":"/reference/brm_data_chronologize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chronologize a dataset — brm_data_chronologize","text":"","code":"brm_data_chronologize(   data,   order = NULL,   levels = NULL,   time = attr(data, \"brm_time\") )"},{"path":"/reference/brm_data_chronologize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chronologize a dataset — brm_data_chronologize","text":"data Data frame tibble longitudinal data. order Optional character string name variable data ordering time variable. Either order levels must supplied, together. order supplied, levels data[[order]] must 1:1 correspondence data[[time]], sort(unique(data[[order]])) must reflect desired order levels data[[time]]. example, suppose CDISC dataset categorical time variable AVISIT integer variable AVISITN. , brm_data_chronologize(time = \"AVISIT\", order = \"AVISITN\") turn AVISIT ordered factor levels respect ordering AVISITN. levels Optional character vector levels data[[time]] chronological order. Used turn data[[time]] ordered factor. Either order levels must supplied, together. time Character string name discrete time variable data. variable brm_data_chronologize() turns ordered factor. needs specified explicitly data argument produced call brm_data().","code":""},{"path":"/reference/brm_data_chronologize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chronologize a dataset — brm_data_chronologize","text":"data frame time column ordered factor.","code":""},{"path":"/reference/brm_data_chronologize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chronologize a dataset — brm_data_chronologize","text":"MMRMs use ordered factor time column data. way, individual time points treated distinct factor levels purposes fixed effect parameterizations (see \"Contrasts\" section), explicit ordering ensures informative prior archetypes ARMA-like correlation structures expressed correctly. Without ordering, problems can arise character vectors sorted: e.g. AVISIT levels \"VISIT1\", \"VISIT2\", ..., \"VISIT10\", brms mistake order scheduled study visits \"VISIT1\", \"VISIT10\", \"VISIT2\", ..., chronological. can easily turn time variable ordered factor using brm_data_chronologize(). Either supply explicit character vector chronologically-ordered factor levels levels argument, supply name time-ordered variable order argument. brm_data_chronologize() can called either just brm_data(), former case, discrete time variable needs specified explicitly time argument. latter, brm_data_chronologize() must called informative prior archetype functions brm_archetype_successive_cells().","code":""},{"path":"/reference/brm_data_chronologize.html","id":"contrasts","dir":"Reference","previous_headings":"","what":"Contrasts","title":"Chronologize a dataset — brm_data_chronologize","text":"Ordinarily, ordered factors automatically use polynomial contrasts contr.poly(). undesirable MMRMs, time variable ordered factor, brm_data() manually sets contrasts(data[[time]]) set treatment contrasts using contr.treatment(). prefer different contrasts, please manually set contrasts(data[[time]]) something else calling brm_data().","code":""},{"path":[]},{"path":"/reference/brm_data_chronologize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chronologize a dataset — brm_data_chronologize","text":"","code":"data <- brm_simulate_outline(n_time = 12, n_patient = 4) data$AVISIT <- gsub(\"_0\", \"_\", data$time) data$AVISITN <- as.integer(gsub(\"time_\", \"\", data$time)) data[, c(\"AVISIT\", \"AVISITN\")] #> # A tibble: 96 × 2 #>    AVISIT  AVISITN #>    <chr>     <int> #>  1 time_1        1 #>  2 time_2        2 #>  3 time_3        3 #>  4 time_4        4 #>  5 time_5        5 #>  6 time_6        6 #>  7 time_7        7 #>  8 time_8        8 #>  9 time_9        9 #> 10 time_10      10 #> # ℹ 86 more rows sort(unique(data$AVISIT)) # wrong order #>  [1] \"time_1\"  \"time_10\" \"time_11\" \"time_12\" \"time_2\"  \"time_3\"  \"time_4\"  #>  [8] \"time_5\"  \"time_6\"  \"time_7\"  \"time_8\"  \"time_9\"  data1 <- brm_data_chronologize(data, time = \"AVISIT\", order = \"AVISITN\") sort(unique(data1$AVISIT)) # correct order #>  [1] time_1  time_2  time_3  time_4  time_5  time_6  time_7  time_8  time_9  #> [10] time_10 time_11 time_12 #> 12 Levels: time_1 < time_2 < time_3 < time_4 < time_5 < time_6 < ... < time_12 levels <- paste0(\"time_\", seq_len(12)) data2 <- brm_data_chronologize(data, time = \"AVISIT\", levels = levels) sort(unique(data2$AVISIT)) # correct order #>  [1] time_1  time_2  time_3  time_4  time_5  time_6  time_7  time_8  time_9  #> [10] time_10 time_11 time_12 #> 12 Levels: time_1 < time_2 < time_3 < time_4 < time_5 < time_6 < ... < time_12"},{"path":"/reference/brm_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Model formula — brm_formula","title":"Model formula — brm_formula","text":"Build model formula MMRM, either generic brm_data() dataset informative prior archetype.","code":""},{"path":"/reference/brm_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model formula — brm_formula","text":"","code":"brm_formula(   data,   model_missing_outcomes = FALSE,   check_rank = TRUE,   sigma = brms.mmrm::brm_formula_sigma(data = data, check_rank = check_rank),   correlation = \"unstructured\",   autoregressive_order = 1L,   moving_average_order = 1L,   residual_covariance_arma_estimation = FALSE,   ... )  # Default S3 method brm_formula(   data,   model_missing_outcomes = FALSE,   check_rank = TRUE,   sigma = brms.mmrm::brm_formula_sigma(data = data, check_rank = check_rank),   correlation = \"unstructured\",   autoregressive_order = 1L,   moving_average_order = 1L,   residual_covariance_arma_estimation = FALSE,   intercept = TRUE,   baseline = !is.null(attr(data, \"brm_baseline\")),   baseline_subgroup = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_subgroup_time = !is.null(attr(data, \"brm_baseline\")) && !is.null(attr(data,     \"brm_subgroup\")),   baseline_time = !is.null(attr(data, \"brm_baseline\")),   covariates = TRUE,   group = TRUE,   group_subgroup = !is.null(attr(data, \"brm_subgroup\")),   group_subgroup_time = !is.null(attr(data, \"brm_subgroup\")),   group_time = TRUE,   subgroup = !is.null(attr(data, \"brm_subgroup\")),   subgroup_time = !is.null(attr(data, \"brm_subgroup\")),   time = TRUE,   center = TRUE,   ...,   effect_baseline = NULL,   effect_group = NULL,   effect_time = NULL,   interaction_baseline = NULL,   interaction_group = NULL )  # S3 method for class 'brms_mmrm_archetype' brm_formula(   data,   model_missing_outcomes = FALSE,   check_rank = TRUE,   sigma = brms.mmrm::brm_formula_sigma(data = data, check_rank = check_rank),   correlation = \"unstructured\",   autoregressive_order = 1L,   moving_average_order = 1L,   residual_covariance_arma_estimation = FALSE,   ...,   warn_ignored = TRUE )"},{"path":"/reference/brm_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model formula — brm_formula","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). model_missing_outcomes Logical length 1, TRUE impute missing outcomes model fitting described \"Imputation model fitting\" section https://paulbuerkner.com/brms/articles/brms_missings.html. Specifically, outcome variable y, formula begin y | mi() ~ ... instead simply y ~ .... Set FALSE (default) forgo kind imputation discard missing observations data just prior fitting model inside brm_model(). See https://opensource.nibr.com/bamdd/src/02h_mmrm.html#-estimand--mmrm-address #nolint understand standard assumptions decisions regarding MMRMs missing outcomes. check_rank TRUE check rank model matrix throw error rank deficiency detected. FALSE skip check. Rank-deficient models may non-identifiable parameters recommended choose full-rank mapping. sigma formula produced brm_formula_sigma(). formula base R formula S3 class \"brms_mmrm_formula_sigma\", controls parameterization residual standard deviations sigma. correlation Character length 1, name correlation structure. correlation matrix square T x T matrix, T number discrete time points data. matrix describes correlations time points patient, modeled residuals. Different patients modeled independent. correlation argument controls matrix parameterized, choices given brms listed https://paulbuerkner.com/brms/reference/autocor-terms.html, choice ultimately encoded main body output formula terms like unstru() arma(), configurable arguments autoregressive_order, moving_average_order, residual_covariance_arma_estimation brm_formula(). Choices brms.mmrm: \"unstructured\": default/recommended option, fully parameterized covariance matrix unique scalar parameter unique pair discrete time points. C.f. https://paulbuerkner.com/brms/reference/unstr.html. \"autoregressive_moving_average\": autoregressive moving average (ARMA), c.f. https://paulbuerkner.com/brms/reference/arma.html. \"autoregressive\": autoregressive (AR), c.f. https://paulbuerkner.com/brms/reference/ar.html. \"moving_average\": moving average (MA), c.f. https://paulbuerkner.com/brms/reference/ma.html. \"compound_symmetry: compound symmetry, c.f. https://paulbuerkner.com/brms/reference/cosy.html. \"diagonal\": declare independent time points within patients. autoregressive_order Nonnegative integer, autoregressive order \"autoregressive_moving_average\" \"autoregressive\" correlation structures. moving_average_order Nonnegative integer, moving average order \"autoregressive_moving_average\" \"moving_average\" correlation structures. residual_covariance_arma_estimation TRUE FALSE, whether estimate ARMA effects using residual covariance matrices. Directly supplied cov argument brms \"autoregressive_moving_average\", \"autoregressive\", \"moving_average\" correlation structures. C.f. https://paulbuerkner.com/brms/reference/arma.html. ... Named arguments specific brm_formula() methods. intercept Logical length 1. TRUE (default) include intercept, FALSE omit. baseline Logical length 1. TRUE include additive effect baseline response, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_subgroup Logical length 1. baseline_subgroup_time Logical length 1. TRUE include baseline--subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline subgroup variables dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. baseline_time Logical length 1. TRUE include baseline--time interaction, FALSE omit. Default TRUE brm_data() previously declared baseline variable dataset. Ignored informative prior archetypes. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. covariates Logical length 1. TRUE (default) include additive covariates declared covariates argument brm_data(), FALSE omit. informative prior archetypes, option set functions like brm_archetype_successive_cells() rather brm_formula() order make sure columns appropriately centered underlying model matrix full rank. group Logical length 1. TRUE (default) include additive effects treatment groups, FALSE omit. group_subgroup Logical length 1. TRUE include group--subgroup interaction, FALSE omit. Default TRUE brm_data() previously declared subgroup variable dataset. group_subgroup_time Logical length 1. TRUE include group--subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared subgroup variable dataset. group_time Logical length 1. TRUE (default) include group--time interaction, FALSE omit. subgroup Logical length 1. TRUE include additive fixed effects subgroup levels, FALSE omit. Default TRUE brm_data() previously declared subgroup variable dataset. subgroup_time Logical length 1. TRUE include subgroup--time interaction, FALSE omit. Default TRUE brm_data() previously declared subgroup variable dataset. time Logical length 1. TRUE (default) include additive effect discrete time, FALSE omit. center TRUE center columns model matrix fitting model model formula includes intercept term controlled brms. FALSE skip centering. Centering usually leads computationally efficient sampling presence intercept, changes interpretation intercept parameter included model (explained help file brms::brmsformula()). Informative prior archetypes always use center = FALSE use intercept controlled brms.mmrm ensure intercept parameter interpretable compatible user-defined priors. effect_baseline Deprecated 2024-01-16 (version 0.0.2.9002). Use baseline instead. effect_group Deprecated 2024-01-16 (version 0.0.2.9002). Use group instead. effect_time Deprecated 2024-01-16 (version 0.0.2.9002). Use time instead. interaction_baseline Deprecated 2024-01-16 (version 0.0.2.9002). Use baseline_time instead. interaction_group Deprecated 2024-01-16 (version 0.0.2.9002). Use group_time instead. warn_ignored Set TRUE throw warning ignored arguments specified, FALSE otherwise.","code":""},{"path":"/reference/brm_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model formula — brm_formula","text":"object class \"brmsformula\" returned brms::brmsformula(). contains fixed effect mapping, correlation structure, residual variance structure.","code":""},{"path":"/reference/brm_formula.html","id":"brm-data-formulas","dir":"Reference","previous_headings":"","what":"brm_data() formulas","title":"Model formula — brm_formula","text":"brm_data() dataset, brm_formula() builds R formula MMRM based details data choice mapping. Customize mapping toggling various TRUE/FALSE arguments brm_formula(), intercept, baseline, group_time. plausible additive effects, two-way interactions, three-way interactions can specified. following interactions supported: interactions concomitant covariates specified covariates argument brm_data(). interactions include baseline response treatment group together. Rationale: randomized controlled experiment, baseline treatment group assignment uncorrelated.","code":""},{"path":"/reference/brm_formula.html","id":"formulas-for-informative-prior-archetypes","dir":"Reference","previous_headings":"","what":"Formulas for informative prior archetypes","title":"Model formula — brm_formula","text":"Functions like brm_archetype_successive_cells() tailor datasets informative prior archetypes. specialized tailored datasets, brm_formula() works differently. still applies variance correlation structure choosing, still lets choose whether adjust nuisance covariates, longer lets toggle /individual terms model, intercept, baseline, group. Instead, ensure correct interpretation parameters, brm_formula() uses x_* nuisance_* columns generated brm_archetype_successive_cells( prefix_interest = \"x_\", prefix_nuisance = \"nuisance_\").","code":""},{"path":"/reference/brm_formula.html","id":"parameterization","dir":"Reference","previous_headings":"","what":"Parameterization","title":"Model formula — brm_formula","text":"formula brm_data() dataset, formula factor determines fixed effect mapping. ordering categorical variables data, well contrast option R, affect construction model matrix. see model matrix ultimately used brm_model(), run brms::make_standata() examine X element returned list. See examples demonstration.","code":""},{"path":[]},{"path":"/reference/brm_formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model formula — brm_formula","text":"","code":"set.seed(0) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) brm_formula(data) #> response ~ group + group:time + time + unstr(time = time, gr = patient)  #> sigma ~ 0 + time brm_formula(data = data, intercept = FALSE, baseline = FALSE) #> response ~ 0 + group + group:time + time + unstr(time = time, gr = patient)  #> sigma ~ 0 + time formula <- brm_formula(   data = data,   intercept = FALSE,   baseline = FALSE,   group = FALSE ) formula #> response ~ 0 + group:time + time + unstr(time = time, gr = patient)  #> sigma ~ 0 + time # Standard deviations of residuals are distributional parameters that can # regress on variables in the data. homogeneous <- brm_formula_sigma(data, time = FALSE) by_group <- brm_formula_sigma(data, group = TRUE, intercept = TRUE) homogeneous #> sigma ~ 0 #> attr(,\"brm_allow_effect_size\") #> [1] TRUE #> <environment: 0x5617387de100> by_group #> sigma ~ group + time #> attr(,\"brm_allow_effect_size\") #> [1] TRUE #> <environment: 0x561738573cf0> brm_formula(data, sigma = homogeneous) #> response ~ group + group:time + time + unstr(time = time, gr = patient)  #> sigma ~ 0 brm_formula(data, sigma = by_group) #> response ~ group + group:time + time + unstr(time = time, gr = patient)  #> sigma ~ group + time # Optional: set the contrast option, which determines the model matrix. options(contrasts = c(unordered = \"contr.SAS\", ordered = \"contr.poly\")) # See the fixed effect mapping you get from the data: head(brms::make_standata(formula = formula, data = data)$X) #>   timetime_1 timetime_2 timetime_3 timetime_4 timetime_1:groupgroup_1 #> 1          1          0          0          0                       1 #> 2          0          1          0          0                       0 #> 3          0          0          1          0                       0 #> 4          0          0          0          1                       0 #> 5          1          0          0          0                       1 #> 6          0          1          0          0                       0 #>   timetime_2:groupgroup_1 timetime_3:groupgroup_1 timetime_4:groupgroup_1 #> 1                       0                       0                       0 #> 2                       1                       0                       0 #> 3                       0                       1                       0 #> 4                       0                       0                       1 #> 5                       0                       0                       0 #> 6                       1                       0                       0 # Specify a different contrast method to use an alternative # mapping when fitting the model with brm_model(): options(   contrasts = c(unordered = \"contr.treatment\", ordered = \"contr.poly\") ) # different model matrix than before: head(brms::make_standata(formula = formula, data = data)$X) #>   timetime_1 timetime_2 timetime_3 timetime_4 timetime_1:groupgroup_2 #> 1          1          0          0          0                       0 #> 2          0          1          0          0                       0 #> 3          0          0          1          0                       0 #> 4          0          0          0          1                       0 #> 5          1          0          0          0                       0 #> 6          0          1          0          0                       0 #>   timetime_2:groupgroup_2 timetime_3:groupgroup_2 timetime_4:groupgroup_2 #> 1                       0                       0                       0 #> 2                       0                       0                       0 #> 3                       0                       0                       0 #> 4                       0                       0                       0 #> 5                       0                       0                       0 #> 6                       0                       0                       0 # Formula on an informative prior archetype: data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = \"biomarker3\",     levels = c(\"present\", \"absent\")   ) archetype <- brm_archetype_successive_cells(data) formula <- brm_formula(data = archetype) formula #> change ~ 0 + x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 + x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 + nuisance_biomarker1 + nuisance_biomarker2 + nuisance_biomarker3_absent + nuisance_baseline + nuisance_baseline.timetime_2 + nuisance_baseline.timetime_3 + unstr(time = time, gr = patient)  #> sigma ~ 0 + time"},{"path":"/reference/brm_formula_sigma.html","id":null,"dir":"Reference","previous_headings":"","what":"Formula for standard deviation parameters — brm_formula_sigma","title":"Formula for standard deviation parameters — brm_formula_sigma","text":"Parameterize standard deviations using formula sigma argument brm_formula().","code":""},{"path":"/reference/brm_formula_sigma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formula for standard deviation parameters — brm_formula_sigma","text":"","code":"brm_formula_sigma(   data,   check_rank = TRUE,   intercept = FALSE,   baseline = FALSE,   baseline_subgroup = FALSE,   baseline_subgroup_time = FALSE,   baseline_time = FALSE,   covariates = FALSE,   group = FALSE,   group_subgroup = FALSE,   group_subgroup_time = FALSE,   group_time = FALSE,   subgroup = FALSE,   subgroup_time = FALSE,   time = TRUE )"},{"path":"/reference/brm_formula_sigma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formula for standard deviation parameters — brm_formula_sigma","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). check_rank TRUE check rank model matrix sigma throw error rank deficiency detected. FALSE skip check. Rank-deficiency may cause sigma non-identifiable, may prevent MCMC converging. intercept Logical length 1. TRUE (default) include intercept, FALSE omit. baseline Logical length 1. TRUE include additive effect baseline response, FALSE omit. TRUE, effect size omitted output brm_marginal_draws(). baseline_subgroup Logical length 1. baseline_subgroup_time Logical length 1. TRUE include baseline--subgroup--time interaction, FALSE omit. TRUE, effect size omitted output brm_marginal_draws(). baseline_time Logical length 1. TRUE include baseline--time interaction, FALSE omit. TRUE, effect size omitted output brm_marginal_draws(). covariates Logical length 1. TRUE (default) include additive covariates declared covariates argument brm_data(), FALSE omit. TRUE, effect size omitted output brm_marginal_draws(). group Logical length 1. TRUE (default) include additive effects treatment groups, FALSE omit. group_subgroup Logical length 1. TRUE include group--subgroup interaction, FALSE omit. group_subgroup_time Logical length 1. TRUE include group--subgroup--time interaction, FALSE omit. group_time Logical length 1. subgroup Logical length 1. TRUE include additive fixed effects subgroup levels, FALSE omit. subgroup_time Logical length 1. TRUE include subgroup--time interaction, FALSE omit. time Logical length 1.","code":""},{"path":"/reference/brm_formula_sigma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formula for standard deviation parameters — brm_formula_sigma","text":"base R formula S3 class \"brms_mmrm_formula_sigma\". formula controls parameterization sigma, linear-scale brms distributional parameters represent standard deviations.","code":""},{"path":"/reference/brm_formula_sigma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Formula for standard deviation parameters — brm_formula_sigma","text":"brms, standard deviations residuals modeled parameter vector called sigma. brms.mmrm always treats sigma distributional parameter (https://paulbuerkner.com/brms/articles/brms_distreg.html). brm_formula_sigma() lets control parameterization sigma. output brm_formula_sigma() serves input sigma argument brm_formula(). default sigma formula sigma ~ 0 + time, time discrete time variable data. usual heterogeneous variance structure declares one standard deviation parameter time point data. Alternatively, write brm_formula_sigma(data, intercept = TRUE, time = FALSE). produce sigma ~ 1, yields single scalar variance (structure termed \"homogeneous variance\"). arguments like baseline covariates, can specify extremely complicated variance structures. However, baseline covariates used, output brm_marginal_draws() omit effect size due statistical challenges calculating marginal means draws sigma uncommon scenario.","code":""},{"path":[]},{"path":"/reference/brm_formula_sigma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Formula for standard deviation parameters — brm_formula_sigma","text":"","code":"set.seed(0) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) homogeneous <- brm_formula_sigma(data, time = FALSE, intercept = TRUE) by_group <- brm_formula_sigma(data, group = TRUE, intercept = TRUE) homogeneous #> sigma ~ 1 #> attr(,\"brm_allow_effect_size\") #> [1] TRUE #> <environment: 0x5617343cea28> by_group #> sigma ~ group + time #> attr(,\"brm_allow_effect_size\") #> [1] TRUE #> <environment: 0x561735b9fbe0> brm_formula(data, sigma = homogeneous) #> response ~ group + group:time + time + unstr(time = time, gr = patient)  #> sigma ~ 1 brm_formula(data, sigma = by_group) #> response ~ group + group:time + time + unstr(time = time, gr = patient)  #> sigma ~ group + time"},{"path":"/reference/brm_marginal_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal summaries of the data. — brm_marginal_data","title":"Marginal summaries of the data. — brm_marginal_data","text":"Marginal summaries data.","code":""},{"path":"/reference/brm_marginal_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal summaries of the data. — brm_marginal_data","text":"","code":"brm_marginal_data(   data,   level = 0.95,   use_subgroup = !is.null(attr(data, \"brm_subgroup\")) )"},{"path":"/reference/brm_marginal_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal summaries of the data. — brm_marginal_data","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). level Numeric length 1 0 1, level confidence intervals. use_subgroup Logical length 1, whether summarize data subgroup level.","code":""},{"path":"/reference/brm_marginal_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marginal summaries of the data. — brm_marginal_data","text":"tibble one row per summary statistic following columns: group: treatment group. subgroup: subgroup level. included subgroup argument brm_marginal_data() TRUE. time: discrete time point. statistic: type summary statistic. value: numeric value estimate. statistic column following possible values: mean: observed mean response removing missing values. median: observed median response removing missing values. sd: observed standard deviation response removing missing values. lower: lower bound normal equal-tailed confidence interval confidence level determined level argument. upper: upper bound normal equal-tailed confidence interval confidence level determined level argument. n_observe: number non-missing values response. n_total: number total records data given group/time combination, including observed missing values.","code":""},{"path":[]},{"path":"/reference/brm_marginal_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Marginal summaries of the data. — brm_marginal_data","text":"","code":"set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) brm_marginal_data(data = data) #> # A tibble: 56 × 4 #>    statistic group   time    value #>    <chr>     <chr>   <chr>   <dbl> #>  1 lower     group_1 time_1  1.39  #>  2 lower     group_1 time_2  2.73  #>  3 lower     group_1 time_3  2.70  #>  4 lower     group_1 time_4  1.88  #>  5 lower     group_2 time_1 -0.118 #>  6 lower     group_2 time_2  1.23  #>  7 lower     group_2 time_3  1.12  #>  8 lower     group_2 time_4  0.300 #>  9 mean      group_1 time_1  1.23  #> 10 mean      group_1 time_2  2.57  #> # ℹ 46 more rows"},{"path":"/reference/brm_marginal_draws.html","id":null,"dir":"Reference","previous_headings":"","what":"MCMC draws from the marginal posterior of an MMRM — brm_marginal_draws","title":"MCMC draws from the marginal posterior of an MMRM — brm_marginal_draws","text":"Get marginal posterior draws fitted MMRM.","code":""},{"path":"/reference/brm_marginal_draws.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MCMC draws from the marginal posterior of an MMRM — brm_marginal_draws","text":"","code":"brm_marginal_draws(   model,   data = model$brms.mmrm_data,   formula = model$brms.mmrm_formula,   transform = brms.mmrm::brm_transform_marginal(data = data, formula = formula,     average_within_subgroup = average_within_subgroup),   effect_size = attr(formula, \"brm_allow_effect_size\"),   average_within_subgroup = NULL,   use_subgroup = NULL,   control = NULL,   baseline = NULL )"},{"path":"/reference/brm_marginal_draws.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MCMC draws from the marginal posterior of an MMRM — brm_marginal_draws","text":"model fitted model object brm_model(). data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). formula object class \"brmsformula\" brm_formula() brms::brmsformula(). include full mapping model, including fixed effects, residual correlation, heterogeneity discrete-time-specific residual variance components. transform Matrix one row per marginal mean one column per model parameter. brm_marginal_draws() uses matrix map posterior draws model parameters posterior draws marginal means using matrix multiplication. Please use brm_transform_marginal() compute matrix modify necessary. See methods vignettes details matrix, well brms.mmrm computes marginal means generally. effect_size Logical, TRUE derive posterior samples effect size (treatment effect divided residual standard deviation). FALSE omit. brms.mmrm support effect size baseline covariates included brm_formula_sigma() formula. effect_size TRUE case, brm_marginal_draws() automatically omit effect size throw informative warning. average_within_subgroup TRUE, FALSE, NULL control whether nuisance parameters averaged within subgroup levels brm_transform_marginal(). Ignored transform argument manually supplied user. See help page brm_transform_marginal() details average_within_subgroup argument. use_subgroup Deprecated. longer used. brm_marginal_draws() longer marginalizes subgroup declared brm_data(). marginalize subgroup, declare variable covariates instead. control Deprecated. Set control group level brm_data(). baseline Deprecated. Set control group level brm_data().","code":""},{"path":"/reference/brm_marginal_draws.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MCMC draws from the marginal posterior of an MMRM — brm_marginal_draws","text":"named list tibbles MCMC draws marginal posterior distribution treatment group time point. marginals also subgroup-specific brm_formula() included fixed effects use subgroup variable originally declared brm_data(). tibble, 1 row per posterior sample one column type marginal distribution (.e. combination treatment group discrete time point. specific tibbles returned list described : response: scale response variable. difference_time: change baseline: response particular time minus response baseline (reference_time). returned reference_time argument brm_data() NULL (.e. baseline value time variable identified). difference_group: treatment effect: samples depend values reference_group reference_time originally declared brm_data(). reference_group control group, reference_time baseline. baseline originally given (via reference_time brm_data()), difference_time change--baseline value active group minus control group. Otherwise, baseline omitted (.e. reference_time = NULL (default) brm_data()), difference_time raw response active group minus control group. difference_subgroup: subgroup differences: difference_group subgroup level minus difference_group subgroup reference level (reference_subgroup). reported subgroup analysis specified appropriate arguments brm_data() brm_formula(). effect: effect size, defined treatment difference divided residual standard deviation. Omitted effect_size argument FALSE brm_formula_sigma() includes baseline covariates. sigma: posterior draws linear-scale marginal standard deviations residuals. Omitted effect_size argument FALSE brm_formula_sigma() includes baseline covariates.","code":""},{"path":"/reference/brm_marginal_draws.html","id":"baseline","dir":"Reference","previous_headings":"","what":"Baseline","title":"MCMC draws from the marginal posterior of an MMRM — brm_marginal_draws","text":"returned values brm_marginal_draws() depend whether baseline time point declared reference_time argument brm_data(). reference_time NULL, brm_marginal_draws() calculate change baseline, calculate treatment differences differences change--baseline values. reference_time NULL, brm_marginal_draws() calculate change baseline, calculate treatment differences differences response values.","code":""},{"path":"/reference/brm_marginal_draws.html","id":"separation-string","dir":"Reference","previous_headings":"","what":"Separation string","title":"MCMC draws from the marginal posterior of an MMRM — brm_marginal_draws","text":"Post-processing brm_marginal_draws() names group--time marginal means delimiting character string Sys.getenv(\"BRM_SEP\", unset = \"|\"). Neither column names element names group time variables can contain string. set custom string , use Sys.setenv(BRM_SEP = \"YOUR_CUSTOM_STRING\").","code":""},{"path":[]},{"path":"/reference/brm_marginal_draws.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MCMC draws from the marginal posterior of an MMRM — brm_marginal_draws","text":"","code":"if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = data,         formula = formula,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) brm_marginal_draws(data = data, formula = formula, model = model) }"},{"path":"/reference/brm_marginal_draws_average.html","id":null,"dir":"Reference","previous_headings":"","what":"Average marginal MCMC draws across time points. — brm_marginal_draws_average","title":"Average marginal MCMC draws across time points. — brm_marginal_draws_average","text":"Simple un-weighted arithmetic mean marginal MCMC draws across time points.","code":""},{"path":"/reference/brm_marginal_draws_average.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Average marginal MCMC draws across time points. — brm_marginal_draws_average","text":"","code":"brm_marginal_draws_average(draws, data, times = NULL, label = \"average\")"},{"path":"/reference/brm_marginal_draws_average.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Average marginal MCMC draws across time points. — brm_marginal_draws_average","text":"draws List posterior draws brm_marginal_draws(). data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). times Character vector discrete time point levels average MCMC samples within treatment group levels. Set NULL average across time points. Levels automatically sanitized make.names(unique = FALSE, allow_ = TRUE) ensure agreement brms variable names downstream computations. label Character length 1, time point label averages. Automatically sanitized make.names(unique = FALSE, allow_ = TRUE). Must conflict existing time point labels data label time points sanitized.","code":""},{"path":"/reference/brm_marginal_draws_average.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Average marginal MCMC draws across time points. — brm_marginal_draws_average","text":"named list tibbles MCMC draws marginal posterior distribution treatment group time point (group--subgroup--time, applicable). See brm_marginal_draws() full details return value. difference brm_marginal_draws_average() returns single pseudo-time-point represent average across multiple real time points.","code":""},{"path":"/reference/brm_marginal_draws_average.html","id":"separation-string","dir":"Reference","previous_headings":"","what":"Separation string","title":"Average marginal MCMC draws across time points. — brm_marginal_draws_average","text":"Post-processing brm_marginal_draws() names group--time marginal means delimiting character string Sys.getenv(\"BRM_SEP\", unset = \"|\"). Neither column names element names group time variables can contain string. set custom string , use Sys.setenv(BRM_SEP = \"YOUR_CUSTOM_STRING\").","code":""},{"path":[]},{"path":"/reference/brm_marginal_draws_average.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Average marginal MCMC draws across time points. — brm_marginal_draws_average","text":"","code":"if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = data,         formula = formula,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) draws <- brm_marginal_draws(data = data, formula = formula, model = model) brm_marginal_draws_average(draws = draws, data = data) brm_marginal_draws_average(   draws = draws,   data = data,   times = c(\"time_1\", \"time_2\"),   label = \"mean\" ) }"},{"path":"/reference/brm_marginal_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal names grid. — brm_marginal_grid","title":"Marginal names grid. — brm_marginal_grid","text":"Describe column names data frames output brm_marginal_draws().","code":""},{"path":"/reference/brm_marginal_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal names grid. — brm_marginal_grid","text":"","code":"brm_marginal_grid(data, formula)"},{"path":"/reference/brm_marginal_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal names grid. — brm_marginal_grid","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). formula object class \"brmsformula\" brm_formula() brms::brmsformula(). include full mapping model, including fixed effects, residual correlation, heterogeneity discrete-time-specific residual variance components.","code":""},{"path":"/reference/brm_marginal_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marginal names grid. — brm_marginal_grid","text":"data frame name column names columns data frames brm_marginal_draws(), along metadata describe groups, subgroups, time points columns correspond .","code":""},{"path":"/reference/brm_marginal_grid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Marginal names grid. — brm_marginal_grid","text":"Useful creating custom posterior summaries draws.","code":""},{"path":[]},{"path":"/reference/brm_marginal_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Marginal names grid. — brm_marginal_grid","text":"","code":"data <- brm_simulate_outline() brm_marginal_grid(data, brm_formula(data)) #> # A tibble: 8 × 3 #>   name           group   time   #>   <chr>          <chr>   <chr>  #> 1 group_1|time_1 group_1 time_1 #> 2 group_1|time_2 group_1 time_2 #> 3 group_1|time_3 group_1 time_3 #> 4 group_1|time_4 group_1 time_4 #> 5 group_2|time_1 group_2 time_1 #> 6 group_2|time_2 group_2 time_2 #> 7 group_2|time_3 group_2 time_3 #> 8 group_2|time_4 group_2 time_4 data <- brm_simulate_outline(n_subgroup = 2L) brm_marginal_grid(data, brm_formula(data)) #> # A tibble: 16 × 4 #>    name                      group   subgroup   time   #>    <chr>                     <chr>   <chr>      <chr>  #>  1 group_1|subgroup_1|time_1 group_1 subgroup_1 time_1 #>  2 group_1|subgroup_1|time_2 group_1 subgroup_1 time_2 #>  3 group_1|subgroup_1|time_3 group_1 subgroup_1 time_3 #>  4 group_1|subgroup_1|time_4 group_1 subgroup_1 time_4 #>  5 group_1|subgroup_2|time_1 group_1 subgroup_2 time_1 #>  6 group_1|subgroup_2|time_2 group_1 subgroup_2 time_2 #>  7 group_1|subgroup_2|time_3 group_1 subgroup_2 time_3 #>  8 group_1|subgroup_2|time_4 group_1 subgroup_2 time_4 #>  9 group_2|subgroup_1|time_1 group_2 subgroup_1 time_1 #> 10 group_2|subgroup_1|time_2 group_2 subgroup_1 time_2 #> 11 group_2|subgroup_1|time_3 group_2 subgroup_1 time_3 #> 12 group_2|subgroup_1|time_4 group_2 subgroup_1 time_4 #> 13 group_2|subgroup_2|time_1 group_2 subgroup_2 time_1 #> 14 group_2|subgroup_2|time_2 group_2 subgroup_2 time_2 #> 15 group_2|subgroup_2|time_3 group_2 subgroup_2 time_3 #> 16 group_2|subgroup_2|time_4 group_2 subgroup_2 time_4"},{"path":"/reference/brm_marginal_probabilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal probabilities on the treatment effect for an MMRM. — brm_marginal_probabilities","title":"Marginal probabilities on the treatment effect for an MMRM. — brm_marginal_probabilities","text":"Marginal probabilities treatment effect MMRM.","code":""},{"path":"/reference/brm_marginal_probabilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal probabilities on the treatment effect for an MMRM. — brm_marginal_probabilities","text":"","code":"brm_marginal_probabilities(draws, direction = \"greater\", threshold = 0)"},{"path":"/reference/brm_marginal_probabilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal probabilities on the treatment effect for an MMRM. — brm_marginal_probabilities","text":"draws Posterior draws marginal posterior obtained brm_marginal_draws(). direction Character vector length threshold. \"greater\" compute marginal posterior probability treatment effect greater threshold, \"less\" compute marginal posterior probability treatment effect less threshold. element direction[] corresponds threshold[] 1 length(direction). threshold Numeric vector length direction, treatment effect threshold computing posterior probabilities. element direction[] corresponds threshold[] 1 length(direction).","code":""},{"path":"/reference/brm_marginal_probabilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marginal probabilities on the treatment effect for an MMRM. — brm_marginal_probabilities","text":"tibble probabilities form Prob(treatment effect > threshold | data) /Prob(treatment effect < threshold | data). one row per probability following columns: * group: treatment group. * subgroup: subgroup level, applicable. * time: discrete time point, * direction: direction comparison marginal probability: \"greater\" >, \"less\" < * threshold: treatment effect threshold probability statement. * value: numeric value estimate probability.","code":""},{"path":[]},{"path":"/reference/brm_marginal_probabilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Marginal probabilities on the treatment effect for an MMRM. — brm_marginal_probabilities","text":"","code":"if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = data,         formula = formula,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) draws <- brm_marginal_draws(data = data, formula = formula, model = model) brm_marginal_probabilities(draws, direction = \"greater\", threshold = 0) }"},{"path":"/reference/brm_marginal_summaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary statistics of the marginal posterior of an MMRM. — brm_marginal_summaries","title":"Summary statistics of the marginal posterior of an MMRM. — brm_marginal_summaries","text":"Summary statistics marginal posterior MMRM.","code":""},{"path":"/reference/brm_marginal_summaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary statistics of the marginal posterior of an MMRM. — brm_marginal_summaries","text":"","code":"brm_marginal_summaries(draws, level = 0.95)"},{"path":"/reference/brm_marginal_summaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary statistics of the marginal posterior of an MMRM. — brm_marginal_summaries","text":"draws Posterior draws marginal posterior obtained brm_marginal_draws(). level Numeric length 1 0 1, credible level credible intervals.","code":""},{"path":"/reference/brm_marginal_summaries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary statistics of the marginal posterior of an MMRM. — brm_marginal_summaries","text":"tibble one row per summary statistic following columns: marginal: type marginal distribution. outcome \"response\" brm_marginal_draws(), possible values include \"response\" response raw scale, \"change\" change baseline, \"difference\" treatment difference terms change baseline. outcome \"change\", possible values include \"response\" response one change baseline scale \"difference\" treatment difference. statistic: type summary statistic. \"lower\" \"upper\" bounds equal-tailed quantile-based credible interval. group: treatment group. subgroup: subgroup level, applicable. time: discrete time point. value: numeric value estimate. mcse: Monte Carlo standard error estimate. statistic column following possible values: mean: posterior mean. median: posterior median. sd: posterior standard deviation mean. lower: lower bound equal-tailed credible interval mean, credible level determined level argument. upper: upper bound equal-tailed credible interval credible level determined level argument.","code":""},{"path":[]},{"path":"/reference/brm_marginal_summaries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary statistics of the marginal posterior of an MMRM. — brm_marginal_summaries","text":"","code":"if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = data,         formula = formula,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) draws <- brm_marginal_draws(data = data, formula = formula, model = model) suppressWarnings(brm_marginal_summaries(draws)) }"},{"path":"/reference/brm_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an MMRM. — brm_model","title":"Fit an MMRM. — brm_model","text":"Fit MMRM model using brms.","code":""},{"path":"/reference/brm_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an MMRM. — brm_model","text":"","code":"brm_model(   data,   formula,   ...,   prior = NULL,   family = brms::brmsfamily(family = \"gaussian\"),   imputed = NULL )"},{"path":"/reference/brm_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an MMRM. — brm_model","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). Unless supplied model_missing_outcomes = TRUE brm_formula(), brm_model() automatically rows missing outcomes just prior fitting model brms::brm(). brms.mmrm_data attribute output object always version data prior removing rows. See data element returned brms object final data actually supplied model. supply non-NULL value imputed argument, data argument ignored MMRM fit successively dataset imputed using brms::brm_multiple(). Posterior draws combined automatically downstream post-processing unless set combine = FALSE brm_model(). formula object class \"brmsformula\" brm_formula() brms::brmsformula(). include full mapping model, including fixed effects, residual correlation, heterogeneity discrete-time-specific residual variance components. ... Arguments brms::brm() brms::brm_multiple() data, formula, prior, family. prior Either NULL default priors \"brmsprior\" object brms::prior(). family brms family object generated brms::brmsfamily(). Must fit continuous outcome variable identity link. imputed Either NULL (default), list datasets generated multiple imputation, \"mids\" object mice package. rbmi package may offer appropriate method imputation MMRMs mice. responsibility choose imputation method appropriate data model. NULL, MMRM fit successively dataset imputed using brms::brm_multiple(). Posterior draws combined automatically downstream post-processing unless set combine = FALSE brm_model(), everything level brm_marginal_draws() exactly non-imputation workflow. Even supply imputed, please also supply original non-imputed dataset data argument help downstream post-processing.","code":""},{"path":"/reference/brm_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an MMRM. — brm_model","text":"fitted model object brms, new list elements brms.mmrm_data brms.mmrm_formula capture data formula supplied brm_model(). See explanation data argument data handled relates data returned brms.mmrm_data attribute.","code":""},{"path":"/reference/brm_model.html","id":"parameterization","dir":"Reference","previous_headings":"","what":"Parameterization","title":"Fit an MMRM. — brm_model","text":"formula brm_data() dataset, formula factor determines fixed effect mapping. ordering categorical variables data, well contrast option R, affect construction model matrix. see model matrix ultimately used brm_model(), run brms::make_standata() examine X element returned list. See examples demonstration.","code":""},{"path":[]},{"path":"/reference/brm_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an MMRM. — brm_model","text":"","code":"if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) # Optional: set the contrast option, which determines the model matrix. options(contrasts = c(unordered = \"contr.SAS\", ordered = \"contr.poly\")) # See the fixed effect mapping you get from the data: head(brms::make_standata(formula = formula, data = data)$X) # Specify a different contrast method to use an alternative # mapping when fitting the model with brm_model(): options(   contrasts = c(unordered = \"contr.treatment\", ordered = \"contr.poly\") ) # different model matrix than before: head(brms::make_standata(formula = formula, data = data)$X) tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = data,         formula = formula,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) # The output is a brms model fit object with added list # elements \"brms.mmrm_data\" and \"brms.mmrm_formula\" to track the dataset # and formula used to fit the model. model$brms.mmrm_data model$brms.mmrm_formula # Otherwise, the fitted model object acts exactly like a brms fitted model. suppressWarnings(print(model)) brms::prior_summary(model) }"},{"path":"/reference/brm_plot_compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Visually compare the marginals of multiple models and/or datasets. — brm_plot_compare","title":"Visually compare the marginals of multiple models and/or datasets. — brm_plot_compare","text":"Visually compare marginals multiple models /datasets.","code":""},{"path":"/reference/brm_plot_compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visually compare the marginals of multiple models and/or datasets. — brm_plot_compare","text":"","code":"brm_plot_compare(   ...,   marginal = \"response\",   compare = \"source\",   axis = \"time\",   facet = c(\"group\", \"subgroup\") )"},{"path":"/reference/brm_plot_compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visually compare the marginals of multiple models and/or datasets. — brm_plot_compare","text":"... Named tibbles marginals posterior summaries brm_marginal_summaries() /brm_marginal_data(). marginal Character length 1, kind marginal visualize. Must value marginal column supplied tibbles ... argument. applies MCMC output, data always scale response variable. compare Character length 1 identifying variable display using back--back interval plots different colors. primary comparison interest. Must one \"source\" (source marginal summaries, e.g. model dataset), \"time\" \"group\" (non-subgroup case). Can also \"subgroup\" marginal summaries subgroup-specific. value must axis facet. axis Character length 1 identifying quantity put horizontal axis. Must one \"source\" (source marginal summaries, e.g. model dataset), \"time\", \"group\" (non-subgroup case). marginals subgroup-specific, axis can also \"subgroup\". value must compare facet. facet Character vector length 1 2 quantities generate facets. element must \"source\" (source marginal summaries, e.g. model dataset), \"time\", \"group\", \"subgroup\", c(axis, facet) must unique elements. \"subgroup\" automatically removed marginal summaries subgroup column. facet length 1, faceting wrapped. facet length 2, faceting grid, first element horizontal facet.","code":""},{"path":"/reference/brm_plot_compare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visually compare the marginals of multiple models and/or datasets. — brm_plot_compare","text":"ggplot object.","code":""},{"path":"/reference/brm_plot_compare.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visually compare the marginals of multiple models and/or datasets. — brm_plot_compare","text":"default, brm_plot_compare() compares multiple models /datasets side--side. compare argument selects primary comparison interest, arguments axis facet control arrangement various components plot. subgroup variable automatically included supplied marginal summaries subgroup column.","code":""},{"path":[]},{"path":"/reference/brm_plot_compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visually compare the marginals of multiple models and/or datasets. — brm_plot_compare","text":"","code":"if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = data,         formula = formula,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) draws <- brm_marginal_draws(data = data, formula = formula, model = model) suppressWarnings(summaries_draws <- brm_marginal_summaries(draws)) summaries_data <- brm_marginal_data(data) brm_plot_compare(   model1 = summaries_draws,   model2 = summaries_draws,   data = summaries_data ) brm_plot_compare(   model1 = summaries_draws,   model2 = summaries_draws,   marginal = \"difference\" ) }"},{"path":"/reference/brm_plot_draws.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize posterior draws of marginals. — brm_plot_draws","title":"Visualize posterior draws of marginals. — brm_plot_draws","text":"Visualize posterior draws marginals.","code":""},{"path":"/reference/brm_plot_draws.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize posterior draws of marginals. — brm_plot_draws","text":"","code":"brm_plot_draws(draws, axis = \"time\", facet = c(\"group\", \"subgroup\"))"},{"path":"/reference/brm_plot_draws.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize posterior draws of marginals. — brm_plot_draws","text":"draws data frame draws element output list brm_marginal_summaries(). axis Character length 1 identifying quantity put horizontal axis. Must one \"time\" \"group\" marginal summaries subgroup-specific. marginals subgroup-specific, axis must one \"time\", \"group\", \"subgroup\". facet Character vector length 1 2 quantities generate facets. element must \"time\", \"group\", \"subgroup\", c(axis, facet) must unique elements. \"subgroup\" automatically removed marginals subgroup. facet length 1, faceting wrapped. facet length 2, faceting grid, first element horizontal facet.","code":""},{"path":"/reference/brm_plot_draws.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize posterior draws of marginals. — brm_plot_draws","text":"ggplot object.","code":""},{"path":[]},{"path":"/reference/brm_plot_draws.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize posterior draws of marginals. — brm_plot_draws","text":"","code":"if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       model <- brm_model(         data = data,         formula = formula,         chains = 1,         iter = 100,         refresh = 0       )     )   ) ) draws <- brm_marginal_draws(data = data, formula = formula, model = model) brm_plot_draws(draws = draws$difference_time) }"},{"path":"/reference/brm_prior_archetype.html","id":null,"dir":"Reference","previous_headings":"","what":"Informative priors for fixed effects in archetypes — brm_prior_archetype","title":"Informative priors for fixed effects in archetypes — brm_prior_archetype","text":"Create brms prior fixed effects archetype.","code":""},{"path":"/reference/brm_prior_archetype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Informative priors for fixed effects in archetypes — brm_prior_archetype","text":"","code":"brm_prior_archetype(label, archetype)"},{"path":"/reference/brm_prior_archetype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Informative priors for fixed effects in archetypes — brm_prior_archetype","text":"label data frame one row per model parameter archetype columns indicate mapping priors labels. Generate using brm_prior_label() manually. See examples informative prior archetypes vignette details. archetype informative prior archetype generated function like brm_archetype_successive_cells().","code":""},{"path":"/reference/brm_prior_archetype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Informative priors for fixed effects in archetypes — brm_prior_archetype","text":"brms prior object can supply prior argument brm_model().","code":""},{"path":"/reference/brm_prior_archetype.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Informative priors for fixed effects in archetypes — brm_prior_archetype","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_prior_archetype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Informative priors for fixed effects in archetypes — brm_prior_archetype","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 3,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) archetype <- brm_archetype_successive_cells(data) dplyr::distinct(data, group, time) #> # A tibble: 6 × 2 #>   group   time   #>   <chr>   <chr>  #> 1 group_1 time_1 #> 2 group_1 time_2 #> 3 group_1 time_3 #> 4 group_2 time_1 #> 5 group_2 time_2 #> 6 group_2 time_3 prior <- NULL |>   brm_prior_label(\"normal(1, 1)\", group = \"group_1\", time = \"time_1\") |>   brm_prior_label(\"normal(1, 2)\", group = \"group_1\", time = \"time_2\") |>   brm_prior_label(\"normal(1, 3)\", group = \"group_1\", time = \"time_3\") |>   brm_prior_label(\"normal(2, 1)\", group = \"group_2\", time = \"time_1\") |>   brm_prior_label(\"normal(2, 2)\", group = \"group_2\", time = \"time_2\") |>   brm_prior_label(\"normal(2, 3)\", group = \"group_2\", time = \"time_3\") |>   brm_prior_archetype(archetype = archetype) prior #>         prior class             coef group resp dpar nlpar   lb   ub source #>  normal(1, 1)     b x_group_1_time_1                       <NA> <NA>   user #>  normal(1, 2)     b x_group_1_time_2                       <NA> <NA>   user #>  normal(1, 3)     b x_group_1_time_3                       <NA> <NA>   user #>  normal(2, 1)     b x_group_2_time_1                       <NA> <NA>   user #>  normal(2, 2)     b x_group_2_time_2                       <NA> <NA>   user #>  normal(2, 3)     b x_group_2_time_3                       <NA> <NA>   user class(prior) #> [1] \"brmsprior\"  \"data.frame\""},{"path":"/reference/brm_prior_label.html","id":null,"dir":"Reference","previous_headings":"","what":"Label a prior with levels in the data. — brm_prior_label","title":"Label a prior with levels in the data. — brm_prior_label","text":"Label informative prior parameter using collection levels data.","code":""},{"path":"/reference/brm_prior_label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label a prior with levels in the data. — brm_prior_label","text":"","code":"brm_prior_label(label = NULL, code, group, subgroup = NULL, time)"},{"path":"/reference/brm_prior_label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label a prior with levels in the data. — brm_prior_label","text":"label tibble prior labeling scheme far, one row per model parameter columns Stan code, treatment group, subgroup, discrete time point parameter. code Character length 1, Stan code prior. string like \"normal(1, 2.2)\". full set priors given Stan Function Reference https://mc-stan.org/docs/functions-reference/ \"Unbounded Continuous Distributions\" section. See documentation brms::set_prior() details. group Value length 1, level treatment group column data label prior. treatment group column one identified group argument brm_data(). subgroup Value length 1, level subgroup column data label prior. subgroup column one identified subgroup argument brm_data(), applicable. every dataset subgroup variable. , please either ignore argument set NULL. time Value length 1, level discrete time column data label prior. discrete time column one identified time argument brm_data().","code":""},{"path":"/reference/brm_prior_label.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label a prior with levels in the data. — brm_prior_label","text":"tibble one row per model parameter columns Stan code, treatment group, subgroup, discrete time point parameter. can supply tibble label argument brm_prior_archetype().","code":""},{"path":"/reference/brm_prior_label.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Label a prior with levels in the data. — brm_prior_label","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_prior_label.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label a prior with levels in the data. — brm_prior_label","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 3,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) archetype <- brm_archetype_successive_cells(data) dplyr::distinct(data, group, time) #> # A tibble: 6 × 2 #>   group   time   #>   <chr>   <chr>  #> 1 group_1 time_1 #> 2 group_1 time_2 #> 3 group_1 time_3 #> 4 group_2 time_1 #> 5 group_2 time_2 #> 6 group_2 time_3 label <- NULL |>   brm_prior_label(\"normal(1, 1)\", group = \"group_1\", time = \"time_1\") |>   brm_prior_label(\"normal(1, 2)\", group = \"group_1\", time = \"time_2\") |>   brm_prior_label(\"normal(1, 3)\", group = \"group_1\", time = \"time_3\") |>   brm_prior_label(\"normal(2, 1)\", group = \"group_2\", time = \"time_1\") |>   brm_prior_label(\"normal(2, 2)\", group = \"group_2\", time = \"time_2\") |>   brm_prior_label(\"normal(2, 3)\", group = \"group_2\", time = \"time_3\") label #> # A tibble: 6 × 3 #>   code         group   time   #>   <chr>        <chr>   <chr>  #> 1 normal(1, 1) group_1 time_1 #> 2 normal(1, 2) group_1 time_2 #> 3 normal(1, 3) group_1 time_3 #> 4 normal(2, 1) group_2 time_1 #> 5 normal(2, 2) group_2 time_2 #> 6 normal(2, 3) group_2 time_3"},{"path":"/reference/brm_prior_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple prior for a brms MMRM — brm_prior_simple","title":"Simple prior for a brms MMRM — brm_prior_simple","text":"Generate simple prior brms MMRM.","code":""},{"path":"/reference/brm_prior_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple prior for a brms MMRM — brm_prior_simple","text":"","code":"brm_prior_simple(   data,   formula,   intercept = \"student_t(3, 0, 2.5)\",   coefficients = \"student_t(3, 0, 2.5)\",   sigma = \"student_t(3, 0, 2.5)\",   unstructured = \"lkj(1)\",   autoregressive = \"\",   moving_average = \"\",   compound_symmetry = \"\",   correlation = NULL )"},{"path":"/reference/brm_prior_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple prior for a brms MMRM — brm_prior_simple","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). formula object class \"brmsformula\" brm_formula() brms::brmsformula(). include full mapping model, including fixed effects, residual correlation, heterogeneity discrete-time-specific residual variance components. intercept Character length 1, Stan code prior set intercept parameter. coefficients Character length 1, Stan code prior set independently non-intercept model coefficients. sigma Character length 1, Stan code prior set independently log-scale standard deviation parameters. symmetric prior situations. unstructured Character length 1, Stan code unstructured correlation prior. Supply empty string \"\" set flat prior (default). Applies \"cortime parameter class brms priors. Used formulas created brm_formula(correlation = \"unstructured\"). LKJ recommended. See also brms::unstr(). autoregressive Character length 1, Stan code prior autoregressive correlation parameters. Supply empty string \"\" set flat prior (default). Applies \"ar parameter class brms priors. Used formulas created brm_formula(correlation = \"autoregressive\") brm_formula(correlation = \"autoregressive_moving_average\"). See also brms::ar() brms::arma(). moving_average Character length 1, Stan code prior moving average correlation parameters. Supply empty string \"\" set flat prior (default). Applies \"ma parameter class brms priors. Used formulas created brm_formula(correlation = \"moving_average\") brm_formula(correlation = \"autoregressive_moving_average\"). See also brms::ma() brms::arma(). compound_symmetry Character length 1, Stan code prior compound symmetry correlation parameters. Supply empty string \"\" set flat prior (default). Applies \"cosy parameter class brms priors. Used formulas created brm_formula(correlation = \"compound_symmetry\"). See also brms::cosy(). correlation Deprecated 2024-04-22 (version 0.1.0.9004). Please use arguments like \"unstructured\", /\"autoregressive\" supply correlation-specific priors.","code":""},{"path":"/reference/brm_prior_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple prior for a brms MMRM — brm_prior_simple","text":"classed data frame brms prior.","code":""},{"path":"/reference/brm_prior_simple.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simple prior for a brms MMRM — brm_prior_simple","text":"brm_prior_simple(), can separately choose priors intercept, model coefficients, log-scale standard deviations, pairwise correlations time points within patients. However, class parameters set whole. words, brm_prior_simple() assign different priors different fixed effect parameters.","code":""},{"path":[]},{"path":"/reference/brm_prior_simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple prior for a brms MMRM — brm_prior_simple","text":"","code":"set.seed(0L) data <- brm_simulate_outline() data <- brm_simulate_continuous(data, names = c(\"age\", \"biomarker\")) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE,   check_rank = FALSE ) brm_prior_simple(   data = data,   formula = formula,   intercept = \"student_t(3, 0, 2.5)\",   coefficients = \"normal(0, 10)\",   sigma = \"student_t(2, 0, 4)\",   unstructured = \"lkj(2.5)\" ) #>                 prior     class coef group resp  dpar nlpar lb ub  source #>  student_t(3, 0, 2.5) Intercept                                   default #>         normal(0, 10)         b                                   default #>              lkj(2.5)   cortime                                   default #>    student_t(2, 0, 4)         b                 sigma             default"},{"path":"/reference/brm_prior_template.html","id":null,"dir":"Reference","previous_headings":"","what":"Label template for informative prior archetypes — brm_prior_template","title":"Label template for informative prior archetypes — brm_prior_template","text":"Template label argument brm_prior_archetype().","code":""},{"path":"/reference/brm_prior_template.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label template for informative prior archetypes — brm_prior_template","text":"","code":"brm_prior_template(archetype)"},{"path":"/reference/brm_prior_template.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label template for informative prior archetypes — brm_prior_template","text":"archetype informative prior archetype generated function like brm_archetype_successive_cells().","code":""},{"path":"/reference/brm_prior_template.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label template for informative prior archetypes — brm_prior_template","text":"tibble one row per fixed effect parameter columns map Stan code parameter. manually writing Stan code code column template, can supply result label argument brm_prior_archetype() build brms prior model.","code":""},{"path":"/reference/brm_prior_template.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label template for informative prior archetypes — brm_prior_template","text":"label argument brm_prior_archetype() tibble maps Stan code univariate priors fixed effect parameters model. Usually tibble built gradually using multiple calls brm_prior_label(), occasionally convenient begin full template manually write Stan code code column. brm_prior_template() creates template.","code":""},{"path":"/reference/brm_prior_template.html","id":"prior-labeling","dir":"Reference","previous_headings":"","what":"Prior labeling","title":"Label template for informative prior archetypes — brm_prior_template","text":"Informative prior archetypes use labeling scheme assign priors fixed effects. works:   informative prior archetypes, process much convenient robust manually calling brms::set_prior(). However, requires understanding labels priors map parameters model. mapping varies archetype archetype, documented help pages archetype-specific functions brm_archetype_successive_cells().","code":"1. First, assign the prior of each parameter a collection   of labels from the data. This can be done manually or with   successive calls to [brm_prior_label()]. 2. Supply the labeling scheme to [brm_prior_archetype()].   [brm_prior_archetype()] uses attributes of the archetype   to map labeled priors to their rightful parameters in the model."},{"path":[]},{"path":"/reference/brm_prior_template.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label template for informative prior archetypes — brm_prior_template","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 3,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) archetype <- brm_archetype_successive_cells(data) label <- brm_prior_template(archetype) label$code <- c(   \"normal(1, 1)\",   \"normal(1, 2)\",   \"normal(1, 3)\",   \"normal(2, 1)\",   \"normal(2, 2)\",   \"normal(2, 3)\" ) brm_prior_archetype(label = label, archetype = archetype) #>         prior class             coef group resp dpar nlpar   lb   ub source #>  normal(1, 1)     b x_group_1_time_1                       <NA> <NA>   user #>  normal(1, 2)     b x_group_1_time_2                       <NA> <NA>   user #>  normal(1, 3)     b x_group_1_time_3                       <NA> <NA>   user #>  normal(2, 1)     b x_group_2_time_1                       <NA> <NA>   user #>  normal(2, 2)     b x_group_2_time_2                       <NA> <NA>   user #>  normal(2, 3)     b x_group_2_time_3                       <NA> <NA>   user"},{"path":"/reference/brm_recenter_nuisance.html","id":null,"dir":"Reference","previous_headings":"","what":"Recenter nuisance variables — brm_recenter_nuisance","title":"Recenter nuisance variables — brm_recenter_nuisance","text":"Change center nuisance variable informative prior archetype.","code":""},{"path":"/reference/brm_recenter_nuisance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recenter nuisance variables — brm_recenter_nuisance","text":"","code":"brm_recenter_nuisance(data, nuisance, center)"},{"path":"/reference/brm_recenter_nuisance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recenter nuisance variables — brm_recenter_nuisance","text":"data informative prior archetype data frame output brm_archetype_cells() similar. nuisance Character length 1, name nuisance column data shift center. center Numeric length 1, value center shift column nuisance. affected column returned archetype data frame look centered value begin .","code":""},{"path":"/reference/brm_recenter_nuisance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recenter nuisance variables — brm_recenter_nuisance","text":"informative prior archetype data frame one variables re-centered.","code":""},{"path":"/reference/brm_recenter_nuisance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recenter nuisance variables — brm_recenter_nuisance","text":"\"centering vector y scalar x\", mean taking difference z = y - x. x mean, mean(z) 0. Informative prior archetypes center nuisance variables means parameters can interpreted correctly setting informative priors. appropriate time, sometimes better center column pre-specified scientifically meaningful fixed number. want nuisance column centered fixed value mean, use brm_recenter_nuisance() shift center. function can handle nuisance variable","code":""},{"path":"/reference/brm_recenter_nuisance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recenter nuisance variables — brm_recenter_nuisance","text":"","code":"set.seed(0L) data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) archetype <- brm_archetype_cells(data) mean(archetype$nuisance_biomarker1) # after original centering #> [1] -2.088553e-17 center <- mean(data$biomarker1) center # original center, before the centering from brm_archetype_cells() #> [1] -0.05507499 attr(archetype$nuisance_biomarker1, \"brm_center\") # original center #> [1] -0.05507499 max(abs((data$biomarker1 - center) - archetype$nuisance_biomarker1)) #> [1] 0 # Re-center nuisance_biomarker1 at 0.75. archetype <- brm_recenter_nuisance(   data = archetype,   nuisance = \"nuisance_biomarker1\",   center = 0.75 ) attr(archetype$nuisance_biomarker1, \"brm_center\") # new center #> [1] 0.75 mean(archetype$nuisance_biomarker1) # no longer equal to the center #> [1] -0.805075 # nuisance_biomarker1 is now as though we centered it at 0.75. max(abs((data$biomarker1 - 0.75) - archetype$nuisance_biomarker1)) #> [1] 2.220446e-16"},{"path":"/reference/brm_simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated: simulate an MMRM. — brm_simulate","title":"Deprecated: simulate an MMRM. — brm_simulate","text":"Deprecated 2023-09-01 (version 0.0.2.9001). Use brm_simulate_simple() instead.","code":""},{"path":"/reference/brm_simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated: simulate an MMRM. — brm_simulate","text":"","code":"brm_simulate(   n_group = 2L,   n_patient = 100L,   n_time = 4L,   hyper_beta = 1,   hyper_sigma = 1,   hyper_correlation = 1 )"},{"path":"/reference/brm_simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated: simulate an MMRM. — brm_simulate","text":"n_group Positive integer length 1, number treatment groups. n_patient Positive integer length 1, number patients per treatment group. n_time Positive integer length 1, number discrete time points (e.g. scheduled study visits) per patient. hyper_beta Positive numeric length 1, hyperparameter. Prior standard deviation fixed effect parameters. hyper_sigma Positive numeric length 1, hyperparameter. Uniform prior upper bound time-specific residual standard deviation parameters. hyper_correlation Positive numeric length 1, hyperparameter. LKJ shape parameter correlation matrix among repeated measures within patient.","code":""},{"path":"/reference/brm_simulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deprecated: simulate an MMRM. — brm_simulate","text":"list three objects: data: tidy dataset one row per patient per discrete time point columns response covariates. model_matrix: matrix one row per row data columns represent levels covariates. parameters: named list parameter values sampled prior.","code":""},{"path":"/reference/brm_simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deprecated: simulate an MMRM. — brm_simulate","text":"","code":"set.seed(0L) simulation <- suppressWarnings(brm_simulate()) simulation$data #> # A tibble: 800 × 4 #>    response group   patient   time   #>       <dbl> <chr>   <chr>     <chr>  #>  1     1.30 group 1 patient 1 time 1 #>  2     2.52 group 1 patient 1 time 2 #>  3     2.63 group 1 patient 1 time 3 #>  4     1.98 group 1 patient 1 time 4 #>  5     1.22 group 1 patient 2 time 1 #>  6     2.63 group 1 patient 2 time 2 #>  7     2.38 group 1 patient 2 time 3 #>  8     2.52 group 1 patient 2 time 4 #>  9     1.32 group 1 patient 3 time 1 #> 10     2.63 group 1 patient 3 time 2 #> # ℹ 790 more rows"},{"path":"/reference/brm_simulate_categorical.html","id":null,"dir":"Reference","previous_headings":"","what":"Append simulated categorical covariates — brm_simulate_categorical","title":"Append simulated categorical covariates — brm_simulate_categorical","text":"Simulate append non-time-varying categorical covariates existing brm_data() dataset.","code":""},{"path":"/reference/brm_simulate_categorical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Append simulated categorical covariates — brm_simulate_categorical","text":"","code":"brm_simulate_categorical(data, names, levels, probabilities = NULL)"},{"path":"/reference/brm_simulate_categorical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Append simulated categorical covariates — brm_simulate_categorical","text":"data Classed tibble brm_data() brm_simulate_outline(). names Character vector names new covariates simulate append. Names must unique must already column names data. levels Character vector unique levels simulated categorical covariates. probabilities Either NULL numeric vector length length(levels) levels 0 1 elements sum 1. NULL, levels equally likely drawn. NULL, probabilities vector sampling probabilities corresponding respective level levels.","code":""},{"path":"/reference/brm_simulate_categorical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Append simulated categorical covariates — brm_simulate_categorical","text":"classed tibble, like brm_data() brm_simulate_outline(), new categorical covariate columns names new covariates appended brm_covariates attribute. new categorical covariate column character vector, factor type base R.","code":""},{"path":"/reference/brm_simulate_categorical.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Append simulated categorical covariates — brm_simulate_categorical","text":"covariate new column dataset one independent random categorical draw patient, using fixed set levels (via base::sample() replace = TRUE). covariates simulated way independent everything else data, including covariates (extent random number generators R work intended).","code":""},{"path":[]},{"path":"/reference/brm_simulate_categorical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Append simulated categorical covariates — brm_simulate_categorical","text":"","code":"data <- brm_simulate_outline() brm_simulate_categorical(   data = data,   names = c(\"site\", \"region\"),   levels = c(\"area1\", \"area2\") ) #> # A tibble: 800 × 7 #>    patient     time   group   missing response site  region #>    <chr>       <chr>  <chr>   <lgl>      <dbl> <chr> <chr>  #>  1 patient_001 time_1 group_1 FALSE         NA area2 area2  #>  2 patient_001 time_2 group_1 FALSE         NA area2 area2  #>  3 patient_001 time_3 group_1 FALSE         NA area2 area2  #>  4 patient_001 time_4 group_1 FALSE         NA area2 area2  #>  5 patient_002 time_1 group_1 FALSE         NA area1 area2  #>  6 patient_002 time_2 group_1 FALSE         NA area1 area2  #>  7 patient_002 time_3 group_1 TRUE          NA area1 area2  #>  8 patient_002 time_4 group_1 TRUE          NA area1 area2  #>  9 patient_003 time_1 group_1 FALSE         NA area2 area2  #> 10 patient_003 time_2 group_1 FALSE         NA area2 area2  #> # ℹ 790 more rows brm_simulate_categorical(   data = data,   names = c(\"site\", \"region\"),   levels = c(\"area1\", \"area2\"),   probabilities = c(0.1, 0.9) ) #> # A tibble: 800 × 7 #>    patient     time   group   missing response site  region #>    <chr>       <chr>  <chr>   <lgl>      <dbl> <chr> <chr>  #>  1 patient_001 time_1 group_1 FALSE         NA area2 area2  #>  2 patient_001 time_2 group_1 FALSE         NA area2 area2  #>  3 patient_001 time_3 group_1 FALSE         NA area2 area2  #>  4 patient_001 time_4 group_1 FALSE         NA area2 area2  #>  5 patient_002 time_1 group_1 FALSE         NA area2 area2  #>  6 patient_002 time_2 group_1 FALSE         NA area2 area2  #>  7 patient_002 time_3 group_1 TRUE          NA area2 area2  #>  8 patient_002 time_4 group_1 TRUE          NA area2 area2  #>  9 patient_003 time_1 group_1 FALSE         NA area2 area2  #> 10 patient_003 time_2 group_1 FALSE         NA area2 area2  #> # ℹ 790 more rows"},{"path":"/reference/brm_simulate_continuous.html","id":null,"dir":"Reference","previous_headings":"","what":"Append simulated continuous covariates — brm_simulate_continuous","title":"Append simulated continuous covariates — brm_simulate_continuous","text":"Simulate append non-time-varying continuous covariates existing brm_data() dataset.","code":""},{"path":"/reference/brm_simulate_continuous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Append simulated continuous covariates — brm_simulate_continuous","text":"","code":"brm_simulate_continuous(data, names, mean = 0, sd = 1)"},{"path":"/reference/brm_simulate_continuous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Append simulated continuous covariates — brm_simulate_continuous","text":"data Classed tibble brm_data() brm_simulate_outline(). names Character vector names new covariates simulate append. Names must unique must already column names data. mean Numeric length 1, mean normal distribution simulating covariate. sd Positive numeric length 1, standard deviation normal distribution simulating covariate.","code":""},{"path":"/reference/brm_simulate_continuous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Append simulated continuous covariates — brm_simulate_continuous","text":"classed tibble, like brm_data() brm_simulate_outline(), new numeric covariate columns names new covariates appended brm_covariates attribute.","code":""},{"path":"/reference/brm_simulate_continuous.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Append simulated continuous covariates — brm_simulate_continuous","text":"covariate new column dataset one independent random univariate normal draw patient. covariates simulated way independent everything else data, including covariates (extent random number generators R work intended).","code":""},{"path":[]},{"path":"/reference/brm_simulate_continuous.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Append simulated continuous covariates — brm_simulate_continuous","text":"","code":"data <- brm_simulate_outline() brm_simulate_continuous(   data = data,   names = c(\"age\", \"biomarker\") ) #> # A tibble: 800 × 7 #>    patient     time   group   missing response     age biomarker #>    <chr>       <chr>  <chr>   <lgl>      <dbl>   <dbl>     <dbl> #>  1 patient_001 time_1 group_1 FALSE         NA -0.0499    -1.30  #>  2 patient_001 time_2 group_1 FALSE         NA -0.0499    -1.30  #>  3 patient_001 time_3 group_1 FALSE         NA -0.0499    -1.30  #>  4 patient_001 time_4 group_1 FALSE         NA -0.0499    -1.30  #>  5 patient_002 time_1 group_1 FALSE         NA  1.75       0.592 #>  6 patient_002 time_2 group_1 FALSE         NA  1.75       0.592 #>  7 patient_002 time_3 group_1 FALSE         NA  1.75       0.592 #>  8 patient_002 time_4 group_1 FALSE         NA  1.75       0.592 #>  9 patient_003 time_1 group_1 FALSE         NA  0.400      1.05  #> 10 patient_003 time_2 group_1 FALSE         NA  0.400      1.05  #> # ℹ 790 more rows brm_simulate_continuous(   data = data,   names = c(\"biomarker1\", \"biomarker2\"),   mean = 1000,   sd = 100 ) #> # A tibble: 800 × 7 #>    patient     time   group   missing response biomarker1 biomarker2 #>    <chr>       <chr>  <chr>   <lgl>      <dbl>      <dbl>      <dbl> #>  1 patient_001 time_1 group_1 FALSE         NA      1154.      1066. #>  2 patient_001 time_2 group_1 FALSE         NA      1154.      1066. #>  3 patient_001 time_3 group_1 FALSE         NA      1154.      1066. #>  4 patient_001 time_4 group_1 FALSE         NA      1154.      1066. #>  5 patient_002 time_1 group_1 FALSE         NA      1108.      1084. #>  6 patient_002 time_2 group_1 FALSE         NA      1108.      1084. #>  7 patient_002 time_3 group_1 FALSE         NA      1108.      1084. #>  8 patient_002 time_4 group_1 FALSE         NA      1108.      1084. #>  9 patient_003 time_1 group_1 FALSE         NA       714.      1111. #> 10 patient_003 time_2 group_1 FALSE         NA       714.      1111. #> # ℹ 790 more rows"},{"path":"/reference/brm_simulate_outline.html","id":null,"dir":"Reference","previous_headings":"","what":"Start a simulated dataset — brm_simulate_outline","title":"Start a simulated dataset — brm_simulate_outline","text":"Begin creating simulated dataset.","code":""},{"path":"/reference/brm_simulate_outline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start a simulated dataset — brm_simulate_outline","text":"","code":"brm_simulate_outline(   n_group = 2L,   n_subgroup = NULL,   n_patient = 100L,   n_time = 4L,   rate_dropout = 0.1,   rate_lapse = 0.05 )"},{"path":"/reference/brm_simulate_outline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start a simulated dataset — brm_simulate_outline","text":"n_group Positive integer length 1, number treatment groups. n_subgroup Positive integer length 1, number subgroup levels. Set NULL omit subgroup entirely. n_patient Positive integer length 1. n_subgroup NULL, n_patient number patients per treatment group. Otherwise, n_patient number patients per treatment group per subgroup. cases, total number patients whole simulated dataset usually much greater n_patients argument brm_simulate_outline(). n_time Positive integer length 1, number discrete time points (e.g. scheduled study visits) per patient. rate_dropout Numeric length 1 0 1, post-baseline dropout rate. dropout intercurrent event data collection patient stops permanently, causing outcomes patient missing dropout occurred. first time point assumed baseline, dropout . Dropouts equally likely occur post-baseline time points. rate_lapse Numeric length 1, expected proportion post-baseline outcomes missing. Missing outcomes type independent uniformly distributed across data.","code":""},{"path":"/reference/brm_simulate_outline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Start a simulated dataset — brm_simulate_outline","text":"classed data frame brm_data(). data frame one row per patient per time point following columns: group: integer index treatment group. patient: integer index patient. time: integer index discrete time point.","code":""},{"path":[]},{"path":"/reference/brm_simulate_outline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start a simulated dataset — brm_simulate_outline","text":"","code":"brm_simulate_outline() #> # A tibble: 800 × 5 #>    patient     time   group   missing response #>    <chr>       <chr>  <chr>   <lgl>      <dbl> #>  1 patient_001 time_1 group_1 FALSE         NA #>  2 patient_001 time_2 group_1 FALSE         NA #>  3 patient_001 time_3 group_1 FALSE         NA #>  4 patient_001 time_4 group_1 FALSE         NA #>  5 patient_002 time_1 group_1 FALSE         NA #>  6 patient_002 time_2 group_1 FALSE         NA #>  7 patient_002 time_3 group_1 FALSE         NA #>  8 patient_002 time_4 group_1 FALSE         NA #>  9 patient_003 time_1 group_1 FALSE         NA #> 10 patient_003 time_2 group_1 FALSE         NA #> # ℹ 790 more rows"},{"path":"/reference/brm_simulate_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Prior predictive draws. — brm_simulate_prior","title":"Prior predictive draws. — brm_simulate_prior","text":"Simulate outcome variable prior predictive distribution MMRM using brms.","code":""},{"path":"/reference/brm_simulate_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prior predictive draws. — brm_simulate_prior","text":"","code":"brm_simulate_prior(   data,   formula,   prior = brms.mmrm::brm_prior_simple(data = data, formula = formula),   ... )"},{"path":"/reference/brm_simulate_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prior predictive draws. — brm_simulate_prior","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). formula object class \"brmsformula\" brm_formula() brms::brmsformula(). include full mapping model, including fixed effects, residual correlation, heterogeneity discrete-time-specific residual variance components. prior valid brms prior object proper priors parameters b (model coefficients), b_sigma (log residual standard deviations time point), cortime (residual correlations among time points within patients). See brm_prior_simple() function example. ... Named arguments specific brm_formula() methods.","code":""},{"path":"/reference/brm_simulate_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prior predictive draws. — brm_simulate_prior","text":"list following elements: data: classed tibble outcome variable simulated draw prior predictive distribution (final row outcome output). simulated missingness pattern brm_simulate_outline(), missingness pattern applied appropriate values outcome variable set NA. model: brms model fit object. model_matrix: model matrix fixed effects, obtained brms::make_standata(). outcome: numeric matrix one column per row data one row per saved prior predictive draw. parameters: tibble saved parameter draws prior predictive distribution.","code":""},{"path":"/reference/brm_simulate_prior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prior predictive draws. — brm_simulate_prior","text":"brm_simulate_prior() calls brms::brm() sample_prior = \"\", sets default intercept prior using outcome variable requires least elements outcome variable non-missing advance. provide feasible consistent output, brm_simulate_prior() temporarily sets outcome variable zeros invoking brms::brm().","code":""},{"path":[]},{"path":"/reference/brm_simulate_prior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prior predictive draws. — brm_simulate_prior","text":"","code":"if (identical(Sys.getenv(\"BRM_EXAMPLES\", unset = \"\"), \"true\")) { set.seed(0L) data <- brm_simulate_outline() data <- brm_simulate_continuous(data, names = c(\"age\", \"biomarker\")) data$response <- rnorm(nrow(data)) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) tmp <- utils::capture.output(   suppressMessages(     suppressWarnings(       out <- brm_simulate_prior(         data = data,         formula = formula       )     )   ) ) out$data }"},{"path":"/reference/brm_simulate_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple MMRM simulation. — brm_simulate_simple","title":"Simple MMRM simulation. — brm_simulate_simple","text":"Simple function simulate dataset simple specialized MMRM.","code":""},{"path":"/reference/brm_simulate_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple MMRM simulation. — brm_simulate_simple","text":"","code":"brm_simulate_simple(   n_group = 2L,   n_patient = 100L,   n_time = 4L,   hyper_beta = 1,   hyper_tau = 0.1,   hyper_lambda = 1 )"},{"path":"/reference/brm_simulate_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple MMRM simulation. — brm_simulate_simple","text":"n_group Positive integer length 1, number treatment groups. n_patient Positive integer length 1, number patients per treatment group. n_time Positive integer length 1, number discrete time points (e.g. scheduled study visits) per patient. hyper_beta Positive numeric length 1, hyperparameter. Prior standard deviation fixed effect parameters beta. hyper_tau Positive numeric length 1, hyperparameter. Prior standard deviation parameter residual log standard deviation parameters tau hyper_lambda Positive numeric length 1, hyperparameter. Prior shape parameter LKJ correlation matrix residuals among discrete time points.","code":""},{"path":"/reference/brm_simulate_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple MMRM simulation. — brm_simulate_simple","text":"list three objects: data: tidy dataset one row per patient per discrete time point columns outcome ID variables. model_matrix: matrix one row per row data columns represent levels covariates. parameters: named list parameter draws sampled prior: beta: numeric vector fixed effects. tau: numeric vector residual log standard parameters time point. sigma: numeric vector residual standard parameters time point. sigma equal exp(tau). lambda: correlation matrix residuals among time points within patient. covariance: covariance matrix residuals among time points within patient. covariance equal diag(sigma) %*% lambda %*% diag(sigma).","code":""},{"path":"/reference/brm_simulate_simple.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simple MMRM simulation. — brm_simulate_simple","text":"Refer methods vignette full model specification. brm_simulate_simple() function simulates dataset simple pre-defined MMRM. assumes cell means structure fixed effects, means one fixed effect scalar parameter (element vector beta) unique combination levels treatment group discrete time point. elements beta independent univariate normal priors mean 0 standard deviation hyper_beta. residual log standard deviation parameters (elements vector tau) normal priors mean 0 standard deviation hyper_tau. residual correlation matrix parameter lambda LKJ correlation prior shape parameter hyper_lambda.","code":""},{"path":[]},{"path":"/reference/brm_simulate_simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple MMRM simulation. — brm_simulate_simple","text":"","code":"set.seed(0L) simulation <- brm_simulate_simple() simulation$data #> # A tibble: 800 × 4 #>    patient     time   response group   #>    <chr>       <chr>     <dbl> <chr>   #>  1 patient_001 time_1    1.47  group_1 #>  2 patient_001 time_2    3.10  group_1 #>  3 patient_001 time_3    2.22  group_1 #>  4 patient_001 time_4    0.215 group_1 #>  5 patient_002 time_1    1.03  group_1 #>  6 patient_002 time_2    2.28  group_1 #>  7 patient_002 time_3    2.36  group_1 #>  8 patient_002 time_4    2.33  group_1 #>  9 patient_003 time_1    0.128 group_1 #> 10 patient_003 time_2    1.89  group_1 #> # ℹ 790 more rows"},{"path":"/reference/brm_transform_marginal.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal mean transformation — brm_transform_marginal","title":"Marginal mean transformation — brm_transform_marginal","text":"Transformation model parameters marginal means.","code":""},{"path":"/reference/brm_transform_marginal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal mean transformation — brm_transform_marginal","text":"","code":"brm_transform_marginal(   data,   formula,   average_within_subgroup = NULL,   prefix = \"b_\" )"},{"path":"/reference/brm_transform_marginal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal mean transformation — brm_transform_marginal","text":"data classed data frame brm_data(), informative prior archetype function like brm_archetype_successive_cells(). formula object class \"brmsformula\" brm_formula() brms::brmsformula(). include full mapping model, including fixed effects, residual correlation, heterogeneity discrete-time-specific residual variance components. average_within_subgroup TRUE average concomitant covariates proportionally within subgroup levels, FALSE average covariates across whole dataset. average_within_subgroup NULL (default), model subgroup nuisance variables, brm_transform_marginal() prints informative message (per session) sets average_within_subgroup FALSE. see message, please read https://openpharma.github.io/brms.mmrm/articles/inference.html, decide whether set average_within_subgroup TRUE FALSE brm_transform_marginal(), manually supply output brm_transform_marginal() transform argument brm_marginal_draws(). create marginal means, brms.mmrm conditions nuisance covariates averages across whole dataset (average_within_subgroup = FALSE NULL brm_transform_marginal()). may reasonable cases, mitigates kind hidden confounding subgroup variables may otherwise cause Simpson's paradox. However, subgroup-specific marginal means, may realistic condition single point estimate levels reference grid (example, subgroup female vs male, marginal means condition single overall observed pregnancy rate 5%). situations, may appropriate instead condition subgroup-specific averages nuisance variables (average_within_subgroup = TRUE brm_transform_marginal()). , responsibility investigate understand hidden interactions confounding dataset. information, please visit https://openpharma.github.io/brms.mmrm/articles/inference.html https://cran.r-project.org/package=emmeans/vignettes/interactions.html. prefix Character length 1, prefix add model matrix (\"X\") brms::make_standata() order reconstruct brms model parameter names. argument modified testing purposes.","code":""},{"path":"/reference/brm_transform_marginal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marginal mean transformation — brm_transform_marginal","text":"matrix transform model parameters (columns) marginal means (rows).","code":""},{"path":"/reference/brm_transform_marginal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Marginal mean transformation — brm_transform_marginal","text":"matrix brm_transform_marginal() passed transform_marginal argument brm_marginal_draws(), transforms posterior draws model parameters posterior draws marginal means. may customize output brm_transform_marginal() passing brm_marginal_draws(). However, please modify dimensions, row names, column names.","code":""},{"path":"/reference/brm_transform_marginal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Marginal mean transformation — brm_transform_marginal","text":"","code":"set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) transform <- brm_transform_marginal(data = data, formula = formula) equations <- summary(transform) #> # This is a matrix to transform model parameters to marginal means. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   group_1:time_1 = b_Intercept #> #   group_1:time_2 = b_Intercept + b_timetime_2 #> #   group_1:time_3 = b_Intercept + b_timetime_3 #> #   group_1:time_4 = b_Intercept + b_timetime_4 #> #   group_2:time_1 = b_Intercept + b_groupgroup_2 #> #   group_2:time_2 = b_Intercept + b_groupgroup_2 + b_timetime_2 + b_groupgroup_2:timetime_2 #> #   group_2:time_3 = b_Intercept + b_groupgroup_2 + b_timetime_3 + b_groupgroup_2:timetime_3 #> #   group_2:time_4 = b_Intercept + b_groupgroup_2 + b_timetime_4 + b_groupgroup_2:timetime_4 print(equations) #> [1] \"group_1:time_1 = b_Intercept\"                                                             #> [2] \"group_1:time_2 = b_Intercept + b_timetime_2\"                                              #> [3] \"group_1:time_3 = b_Intercept + b_timetime_3\"                                              #> [4] \"group_1:time_4 = b_Intercept + b_timetime_4\"                                              #> [5] \"group_2:time_1 = b_Intercept + b_groupgroup_2\"                                            #> [6] \"group_2:time_2 = b_Intercept + b_groupgroup_2 + b_timetime_2 + b_groupgroup_2:timetime_2\" #> [7] \"group_2:time_3 = b_Intercept + b_groupgroup_2 + b_timetime_3 + b_groupgroup_2:timetime_3\" #> [8] \"group_2:time_4 = b_Intercept + b_groupgroup_2 + b_timetime_4 + b_groupgroup_2:timetime_4\" summary(transform, message = FALSE) #> [1] \"group_1:time_1 = b_Intercept\"                                                             #> [2] \"group_1:time_2 = b_Intercept + b_timetime_2\"                                              #> [3] \"group_1:time_3 = b_Intercept + b_timetime_3\"                                              #> [4] \"group_1:time_4 = b_Intercept + b_timetime_4\"                                              #> [5] \"group_2:time_1 = b_Intercept + b_groupgroup_2\"                                            #> [6] \"group_2:time_2 = b_Intercept + b_groupgroup_2 + b_timetime_2 + b_groupgroup_2:timetime_2\" #> [7] \"group_2:time_3 = b_Intercept + b_groupgroup_2 + b_timetime_3 + b_groupgroup_2:timetime_3\" #> [8] \"group_2:time_4 = b_Intercept + b_groupgroup_2 + b_timetime_4 + b_groupgroup_2:timetime_4\" class(transform) #> [1] \"brms_mmrm_transform_marginal\" \"matrix\"                       #> [3] \"array\"                        print(transform) #>                b_Intercept b_groupgroup_2 b_timetime_2 b_timetime_3 #> group_1|time_1           1              0            0            0 #> group_1|time_2           1              0            1            0 #> group_1|time_3           1              0            0            1 #> group_1|time_4           1              0            0            0 #> group_2|time_1           1              1            0            0 #> group_2|time_2           1              1            1            0 #> group_2|time_3           1              1            0            1 #> group_2|time_4           1              1            0            0 #>                b_timetime_4 b_groupgroup_2:timetime_2 b_groupgroup_2:timetime_3 #> group_1|time_1            0                         0                         0 #> group_1|time_2            0                         0                         0 #> group_1|time_3            0                         0                         0 #> group_1|time_4            1                         0                         0 #> group_2|time_1            0                         0                         0 #> group_2|time_2            0                         1                         0 #> group_2|time_3            0                         0                         1 #> group_2|time_4            1                         0                         0 #>                b_groupgroup_2:timetime_4 #> group_1|time_1                         0 #> group_1|time_2                         0 #> group_1|time_3                         0 #> group_1|time_4                         0 #> group_2|time_1                         0 #> group_2|time_2                         0 #> group_2|time_3                         0 #> group_2|time_4                         1"},{"path":"/reference/brms.mmrm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"brms.mmrm: Bayesian MMRMs using brms — brms.mmrm-package","title":"brms.mmrm: Bayesian MMRMs using brms — brms.mmrm-package","text":"mixed model repeated measures (MMRM) popular model longitudinal clinical trial data continuous endpoints, brms powerful versatile package fitting Bayesian regression models. brms.mmrm R package leverages brms run MMRMs, supports simplified interfaced reduce difficulty align best practices life sciences.","code":""},{"path":"/reference/brms.mmrm-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"brms.mmrm: Bayesian MMRMs using brms — brms.mmrm-package","text":"Bürkner, P.-C. (2017), \"brms: R package Bayesian multilevel models using Stan,\" Journal Statistical Software, 80, 1–28. https://doi.org/10.18637/jss.v080.i01. Holzhauer, B., Weber, S. (2024), \"Bayesian mixed effects model repeated measures,\" Applied Modeling Drug Development, Novartis AG. https://opensource.nibr.com/bamdd/src/02h_mmrm.html. Mallinckrodt, C. H., Lane, P. W., Schnell, D., others (2008), \"Recommendations primary analysis continuous endpoints longitudinal clinical trials,\" Therapeutic Innovation Regulatory Science, 42, 303–319. https://doi.org/10.1177/009286150804200402. Mallinckrodt, C. H., Lipkovich, . (2017), Analyzing longitudinal clinical trial data: practical guide, CRC Press, Taylor & Francis Group.","code":""},{"path":"/reference/summary.brms_mmrm_archetype.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize an informative prior archetype. — summary.brms_mmrm_archetype","title":"Summarize an informative prior archetype. — summary.brms_mmrm_archetype","text":"informative prior archetype, show transformation model parameters marginal means.","code":""},{"path":"/reference/summary.brms_mmrm_archetype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize an informative prior archetype. — summary.brms_mmrm_archetype","text":"","code":"# S3 method for class 'brms_mmrm_archetype' summary(object, message = TRUE, ...)"},{"path":"/reference/summary.brms_mmrm_archetype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize an informative prior archetype. — summary.brms_mmrm_archetype","text":"object informative prior archetype summarize. message TRUE print informative message archetype invisibly return character vector equations. FALSE forgo verbose messages non-invisibly return equations. ... used, required S3 methods inherit base generic summary().","code":""},{"path":"/reference/summary.brms_mmrm_archetype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize an informative prior archetype. — summary.brms_mmrm_archetype","text":"Return character vector linear equations map model parameters marginal means. message argument TRUE (default) character vector returned invisibly verbose description equations printed.","code":""},{"path":"/reference/summary.brms_mmrm_archetype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize an informative prior archetype. — summary.brms_mmrm_archetype","text":"","code":"data <- brm_simulate_outline(   n_group = 2,   n_patient = 100,   n_time = 4,   rate_dropout = 0,   rate_lapse = 0 ) |>   dplyr::mutate(response = rnorm(n = dplyr::n())) |>   brm_data_change() |>   brm_simulate_continuous(names = c(\"biomarker1\", \"biomarker2\")) |>   brm_simulate_categorical(     names = c(\"status1\", \"status2\"),     levels = c(\"present\", \"absent\")   ) dplyr::select(   data,   group,   time,   patient,   starts_with(\"biomarker\"),   starts_with(\"status\") ) #> # A tibble: 600 × 7 #>    group   time   patient     biomarker1 biomarker2 status1 status2 #>    <chr>   <chr>  <chr>            <dbl>      <dbl> <chr>   <chr>   #>  1 group_1 time_2 patient_001     1.11       -0.222 present absent  #>  2 group_1 time_3 patient_001     1.11       -0.222 present absent  #>  3 group_1 time_4 patient_001     1.11       -0.222 present absent  #>  4 group_1 time_2 patient_002    -0.0254      1.52  absent  absent  #>  5 group_1 time_3 patient_002    -0.0254      1.52  absent  absent  #>  6 group_1 time_4 patient_002    -0.0254      1.52  absent  absent  #>  7 group_1 time_2 patient_003     0.0805     -0.139 absent  present #>  8 group_1 time_3 patient_003     0.0805     -0.139 absent  present #>  9 group_1 time_4 patient_003     0.0805     -0.139 absent  present #> 10 group_1 time_2 patient_004     0.0910     -1.54  present absent  #> # ℹ 590 more rows archetype <- brm_archetype_successive_cells(data) equations <- summary(archetype) #> # This is the \"successive cells\" informative prior archetype in brms.mmrm. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and important fixed effect parameters #> # (right-hand side). Nuisance parameters are omitted. #> #  #> #   group_1:time_2 = x_group_1_time_2 #> #   group_1:time_3 = x_group_1_time_2 + x_group_1_time_3 #> #   group_1:time_4 = x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4 #> #   group_2:time_2 = x_group_2_time_2 #> #   group_2:time_3 = x_group_2_time_2 + x_group_2_time_3 #> #   group_2:time_4 = x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4 print(equations) #> [1] \"group_1:time_2 = x_group_1_time_2\"                                       #> [2] \"group_1:time_3 = x_group_1_time_2 + x_group_1_time_3\"                    #> [3] \"group_1:time_4 = x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4\" #> [4] \"group_2:time_2 = x_group_2_time_2\"                                       #> [5] \"group_2:time_3 = x_group_2_time_2 + x_group_2_time_3\"                    #> [6] \"group_2:time_4 = x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4\" summary(archetype, message = FALSE) #> [1] \"group_1:time_2 = x_group_1_time_2\"                                       #> [2] \"group_1:time_3 = x_group_1_time_2 + x_group_1_time_3\"                    #> [3] \"group_1:time_4 = x_group_1_time_2 + x_group_1_time_3 + x_group_1_time_4\" #> [4] \"group_2:time_2 = x_group_2_time_2\"                                       #> [5] \"group_2:time_3 = x_group_2_time_2 + x_group_2_time_3\"                    #> [6] \"group_2:time_4 = x_group_2_time_2 + x_group_2_time_3 + x_group_2_time_4\""},{"path":"/reference/summary.brms_mmrm_transform_marginal.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize marginal transform. — summary.brms_mmrm_transform_marginal","title":"Summarize marginal transform. — summary.brms_mmrm_transform_marginal","text":"Summarize transformation model parameters marginal means.","code":""},{"path":"/reference/summary.brms_mmrm_transform_marginal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize marginal transform. — summary.brms_mmrm_transform_marginal","text":"","code":"# S3 method for class 'brms_mmrm_transform_marginal' summary(object, message = TRUE, ...)"},{"path":"/reference/summary.brms_mmrm_transform_marginal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize marginal transform. — summary.brms_mmrm_transform_marginal","text":"object brm_transform_marginal() matrix summarize. message TRUE print informative message archetype invisibly return character vector equations. FALSE forgo verbose messages non-invisibly return equations. ... used, required S3 methods inherit base generic summary().","code":""},{"path":"/reference/summary.brms_mmrm_transform_marginal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize marginal transform. — summary.brms_mmrm_transform_marginal","text":"Return character vector linear equations map model parameters marginal means. message argument TRUE (default) character vector returned invisibly verbose description equations printed.","code":""},{"path":"/reference/summary.brms_mmrm_transform_marginal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize marginal transform. — summary.brms_mmrm_transform_marginal","text":"","code":"set.seed(0L) data <- brm_data(   data = brm_simulate_simple()$data,   outcome = \"response\",   group = \"group\",   time = \"time\",   patient = \"patient\",   reference_group = \"group_1\",   reference_time = \"time_1\" ) formula <- brm_formula(   data = data,   baseline = FALSE,   baseline_time = FALSE ) transform <- brm_transform_marginal(data = data, formula = formula) equations <- summary(transform) #> # This is a matrix to transform model parameters to marginal means. #> # The following equations show the relationships between the #> # marginal means (left-hand side) and fixed effect parameters #> # (right-hand side). #> #  #> #   group_1:time_1 = b_Intercept #> #   group_1:time_2 = b_Intercept + b_timetime_2 #> #   group_1:time_3 = b_Intercept + b_timetime_3 #> #   group_1:time_4 = b_Intercept + b_timetime_4 #> #   group_2:time_1 = b_Intercept + b_groupgroup_2 #> #   group_2:time_2 = b_Intercept + b_groupgroup_2 + b_timetime_2 + b_groupgroup_2:timetime_2 #> #   group_2:time_3 = b_Intercept + b_groupgroup_2 + b_timetime_3 + b_groupgroup_2:timetime_3 #> #   group_2:time_4 = b_Intercept + b_groupgroup_2 + b_timetime_4 + b_groupgroup_2:timetime_4 print(equations) #> [1] \"group_1:time_1 = b_Intercept\"                                                             #> [2] \"group_1:time_2 = b_Intercept + b_timetime_2\"                                              #> [3] \"group_1:time_3 = b_Intercept + b_timetime_3\"                                              #> [4] \"group_1:time_4 = b_Intercept + b_timetime_4\"                                              #> [5] \"group_2:time_1 = b_Intercept + b_groupgroup_2\"                                            #> [6] \"group_2:time_2 = b_Intercept + b_groupgroup_2 + b_timetime_2 + b_groupgroup_2:timetime_2\" #> [7] \"group_2:time_3 = b_Intercept + b_groupgroup_2 + b_timetime_3 + b_groupgroup_2:timetime_3\" #> [8] \"group_2:time_4 = b_Intercept + b_groupgroup_2 + b_timetime_4 + b_groupgroup_2:timetime_4\" summary(transform, message = FALSE) #> [1] \"group_1:time_1 = b_Intercept\"                                                             #> [2] \"group_1:time_2 = b_Intercept + b_timetime_2\"                                              #> [3] \"group_1:time_3 = b_Intercept + b_timetime_3\"                                              #> [4] \"group_1:time_4 = b_Intercept + b_timetime_4\"                                              #> [5] \"group_2:time_1 = b_Intercept + b_groupgroup_2\"                                            #> [6] \"group_2:time_2 = b_Intercept + b_groupgroup_2 + b_timetime_2 + b_groupgroup_2:timetime_2\" #> [7] \"group_2:time_3 = b_Intercept + b_groupgroup_2 + b_timetime_3 + b_groupgroup_2:timetime_3\" #> [8] \"group_2:time_4 = b_Intercept + b_groupgroup_2 + b_timetime_4 + b_groupgroup_2:timetime_4\" class(transform) #> [1] \"brms_mmrm_transform_marginal\" \"matrix\"                       #> [3] \"array\"                        print(transform) #>                b_Intercept b_groupgroup_2 b_timetime_2 b_timetime_3 #> group_1|time_1           1              0            0            0 #> group_1|time_2           1              0            1            0 #> group_1|time_3           1              0            0            1 #> group_1|time_4           1              0            0            0 #> group_2|time_1           1              1            0            0 #> group_2|time_2           1              1            1            0 #> group_2|time_3           1              1            0            1 #> group_2|time_4           1              1            0            0 #>                b_timetime_4 b_groupgroup_2:timetime_2 b_groupgroup_2:timetime_3 #> group_1|time_1            0                         0                         0 #> group_1|time_2            0                         0                         0 #> group_1|time_3            0                         0                         0 #> group_1|time_4            1                         0                         0 #> group_2|time_1            0                         0                         0 #> group_2|time_2            0                         1                         0 #> group_2|time_3            0                         0                         1 #> group_2|time_4            1                         0                         0 #>                b_groupgroup_2:timetime_4 #> group_1|time_1                         0 #> group_1|time_2                         0 #> group_1|time_3                         0 #> group_1|time_4                         0 #> group_2|time_1                         0 #> group_2|time_2                         0 #> group_2|time_3                         0 #> group_2|time_4                         1"},{"path":[]},{"path":"/news/index.html","id":"brmsmmrm-111","dir":"Changelog","previous_headings":"","what":"brms.mmrm 1.1.1","title":"brms.mmrm 1.1.1","text":"CRAN release: 2024-10-02 Use FEV data usage vignette. Show visualize prior vs posterior usage vignette. Add center argument brms_formula.default() explain intercept parameter interpretation concerns (#128).","code":""},{"path":"/news/index.html","id":"brmsmmrm-110","dir":"Changelog","previous_headings":"","what":"brms.mmrm 1.1.0","title":"brms.mmrm 1.1.0","text":"CRAN release: 2024-07-29 Add brm_marginal_grid(). Show posterior samples sigma brm_marginal_draws() brm_marginal_summaries(). Allow outcome = \"response\" reference_time = NULL. Sometimes raw response analyzed data baseline time point. Preserve factors brm_data() encourage ordered factors time variable (#113). Add brm_data_chronologize() ensure correctness time variable. drop columns brm_data(). helps brm_data_chronologize() operate correctly calls brm_data(). Add new elements brms.mmrm_data brms.mmrm_formula brms fitted model object returned brm_model(). Take defaults data formula brm_marginal_draws(). Set default value effect_size attr(formula, \"brm_allow_effect_size\"). Remove defaults arguments brm_data() document examples. Deprecate role argument brm_data() favor reference_time (#119). Add new model_missing_outcomes brm_formula() optionally impute missing values model fitting described https://paulbuerkner.com/brms/articles/brms_missings.html (#121). Add new imputed argument accept mice multiply imputed dataset (“mids”) brm_model() (#121). Add summary() method brm_transform_marginal() objects. recheck rank formula brm_transform_marginal(). Support constrained longitudinal data analysis (cLDA) informative prior archetypes brm_archetype_cells(), brm_archetype_effects(), brm_archetype_successive_cells(), brm_archetype_successive_effects() (#125). support cLDA brm_archetype_average_cells() brm_archetype_average_effects() parameters longer averages others.","code":""},{"path":"/news/index.html","id":"brmsmmrm-101","dir":"Changelog","previous_headings":"","what":"brms.mmrm 1.0.1","title":"brms.mmrm 1.0.1","text":"CRAN release: 2024-06-25 Handle outcome NAs get_draws_sigma(). Improve summary() messages informative prior archetypes. Rewrite archetypes.Rmd vignette using FEV dataset mmrm package. Add brm_prior_template().","code":""},{"path":"/news/index.html","id":"brmsmmrm-100","dir":"Changelog","previous_headings":"","what":"brms.mmrm 1.0.0","title":"brms.mmrm 1.0.0","text":"CRAN release: 2024-06-04","code":""},{"path":"/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"New features","title":"brms.mmrm 1.0.0","text":"Add informative prior archetypes (#96, #101). Add [brm_formula_sigma()] allow flexibility modeling standard deviations distributional parameters (#102). Due complexities computing marginal means standard deviations rare scenarios, [brm_marginal_draws()] return effect size [brm_formula_sigma()] uses baseline covariates.","code":""},{"path":"/news/index.html","id":"guardrails-to-ensure-the-appropriateness-of-marginal-mean-estimation-1-0-0","dir":"Changelog","previous_headings":"","what":"Guardrails to ensure the appropriateness of marginal mean estimation","title":"brms.mmrm 1.0.0","text":"Require new formula argument brm_marginal_draws(). Change class name \"brm_data\" \"brms_mmrm_data\" align class names. Create special \"brms_mmrm_formula\" class wrap around model formula. class ensures formulas passed model created brms_formula(), attributes store user’s choice fixed effects. Create special \"brms_mmrm_model\" class fitted model objects. class ensures fitted models created brms_model(), attributes store \"brms_mmrm_formula\" object way brms modify. Deprecate use_subgroup brm_marginal_draws(). subgroup now always part reference grid declared brm_data(). marginalize subgroup, declare covariates instead. Prevent overplotting multiple subgroups brm_plot_compare(). Update subgroup vignette reflect changes .","code":""},{"path":"/news/index.html","id":"custom-estimation-of-marginal-means-1-0-0","dir":"Changelog","previous_headings":"","what":"Custom estimation of marginal means","title":"brms.mmrm 1.0.0","text":"Implement new brm_transform_marginal() transform model parameters marginal means (#53). Use brm_transform_marginal() instead emmeans brm_marginal_draws() derive posterior draws marginal means based posterior draws model parameters (#53). Explain custom marginal mean calculation new inference.Rmd vignette. Rename methods.Rmd model.Rmd since inference.Rmd also discusses methods.","code":""},{"path":"/news/index.html","id":"other-improvements-1-0-0","dir":"Changelog","previous_headings":"","what":"Other improvements","title":"brms.mmrm 1.0.0","text":"Extend brm_formula() brm_marginal_draws() optionally model homogeneous variances, well ARMA, AR, MA, compound symmetry correlation structures. Restrict brm_model() continuous families identity links. brm_prior_simple(), deprecate correlation argument favor individual correlation-specific arguments unstructured compound_symmetry. Ensure model matrices full rank (#99).","code":""},{"path":"/news/index.html","id":"brmsmmrm-010","dir":"Changelog","previous_headings":"","what":"brms.mmrm 0.1.0","title":"brms.mmrm 0.1.0","text":"CRAN release: 2024-02-15 Deprecate brm_simulate() favor brm_simulate_simple() (#3). latter specific name disambiguate simulation functions, parameterization conforms one methods vignette. Add new functions nuanced simulations: brm_simulate_outline(), brm_simulate_continuous(), brm_simulate_categorical() (#3). brm_model(), remove rows missing responses. rows automatically removed brms anyway, handling handling brms.mmrm, avoid warning. Add subgroup analysis functionality validate subgroup model simulation-based calibration (#18). Zero-pad numeric indexes simulated data levels sort expected. brm_data(), deprecate level_control favor reference_group. brm_data(), deprecate level_baseline favor reference_time. brm_formula(), deprecate arguments effect_baseline, effect_group, effect_time, interaction_baseline, interaction_group favor baseline, group, time, baseline_time, group_time, respectively. Propagate values missing column brm_data_change() value change baseline labeled missing either baseline response missing post-baseline response missing. Change names output brm_marginal_draws() internally consistent fit better addition subgroup-specific marginals (#18). Allow brm_plot_compare() brm_plot_draws() select x axis variable faceting variables. Allow brm_plot_compare() choose primary comparison interest (source data, discrete time, treatment group, subgroup level).","code":""},{"path":"/news/index.html","id":"brmsmmrm-002","dir":"Changelog","previous_headings":"","what":"brms.mmrm 0.0.2","title":"brms.mmrm 0.0.2","text":"CRAN release: 2023-08-18 Fix grammatical issues description.","code":""},{"path":"/news/index.html","id":"brmsmmrm-001","dir":"Changelog","previous_headings":"","what":"brms.mmrm 0.0.1","title":"brms.mmrm 0.0.1","text":"First version.","code":""}]
